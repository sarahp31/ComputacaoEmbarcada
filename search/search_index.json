{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bem vindo a disciplina de Computa\u00e7\u00e3o Embarcada Curso: Engenharia Da Computa\u00e7\u00e3o - Quinto Semestre - Insper Disciplina: Computa\u00e7\u00e3o Embarcada Reposit\u00f3rio: http:/github.com/Insper/ComputacaoEmbarcada Local: Laborat\u00f3rios de Arquitetura de Computadores e Laborat\u00f3rio de Inform\u00e1tica Equipe: Prof. Rafael Corsi : rafael.corsi@insper.edu.br T\u00e9cnico Marco Mello: marcoASMA@insper.edu.br Prof. Aux. Arnaldo Jr (Tioz\u00e3o): arnaldoavj@insper.edu.br J\u00e1 passou por aqui: (2021-2021) Prof. Aux. Fl\u00e1vio Batista (2016-2020) Prof. Aux. Eduardo Marossi \u00a9 Todos os direitos reservados Objetivos Ao final da disciplina o estudante deve ser capaz de: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Motiva\u00e7\u00e3o Sistemas embarcados movem o mundo! Come\u00e7ando Leia mais sobre o curso e a infra necess\u00e1ria em: Sobre Hist\u00f3rico Pequeno hist\u00f3rico da evolu\u00e7\u00e3o da disciplina: 2022-2: Sequ\u00eancia dos laborat\u00f3rios alterada, introduzi o RTOS antes dos timers (PIO, DRIVER, PIO-IRQ, RTOS, HCSR04 com RTT). As notas das prova pr\u00e1ticas s\u00e3o bin\u00e1rias e n\u00e3o fazem mais parte da nota final. 2022-1: Aulas 100% presenciais, criamos um grupo no whatsapp para comunicados r\u00e1pidos com a turma, reformulamos os requisitos de alguns de labs e montamos um mini est\u00fadio para grava\u00e7\u00e3o de v\u00eddeos onde o estudante demonstra o funcionamento dos projetos, a APS do IoT virou laborat\u00f3rio. Arnaldo come\u00e7ou como professor auxiliar. 2021-2: Microchip parou de fabricar o m\u00f3dulo de LCD que us\u00e1vamos, por conta disso migramos para um display da Adafruit, aproveitamos para inserir a biblioteca gr\u00e1fica LVGL. A APS gr\u00e1fica focou no desenvolvimento de um ox\u00edmetro. O Fabr\u00edcio foi professor auxiliar. 2021-1: Aulas de segunda online e labs no modelo h\u00edbrido. APS-1 musical/ Projeto 1 (controle) / APS-2 IHM ox\u00edmetro / APS-3 Wifi. A ideia da APS-2 virar o ox\u00edmetro \u00e9 para trazer um tema atual para dentro da disciplina. 2020-2: Aula 100% online por conta da pandemia: sai APS-1 e entra projeto 1, mant\u00e9m APS-2 e APS-3. 2020-1: Devido ao pandemia do corona v\u00edrus o projeto foi cancelado, os alunos receberam um complemento do kit para trabalharem de casa. As APS foram: Musica, LCD bike e WIFI. As avalia\u00e7\u00f5es individuais foram aprimoradas. A parte de UX foi bem trabalhada nesse semestre. 2019-2 (DP): Troquei a APS 2 da m\u00e1quina de lavar para a Bike. Como s\u00f3 tinha um aluno, as APS viraram projetos. 2019-1: Introduzi as APS: Musical; M\u00e1quina de Lavar e Wifi (tinha uma de sensores tamb\u00e9m), os alunos tiveram que entregar 2 projetos: controle/ vending machine e projeto livre. Primeira vez que aparece o projeto fechado do come\u00e7o de semestre. Estreia do lab de Arquitetura 2018-1: Um projeto ao longo do semestre todo. Introduzi avalia\u00e7\u00e3o pr\u00e1tica individual. 2017-1 (primeira turma): Um \u00fanico projeto ao longo do semestre todo. Alguns Projetos de turmas anteriores Video Video Video Video Video Video Video Video Video Video Video Video Video","title":"Home"},{"location":"#bem-vindo-a-disciplina-de-computacao-embarcada","text":"Curso: Engenharia Da Computa\u00e7\u00e3o - Quinto Semestre - Insper Disciplina: Computa\u00e7\u00e3o Embarcada Reposit\u00f3rio: http:/github.com/Insper/ComputacaoEmbarcada Local: Laborat\u00f3rios de Arquitetura de Computadores e Laborat\u00f3rio de Inform\u00e1tica Equipe: Prof. Rafael Corsi : rafael.corsi@insper.edu.br T\u00e9cnico Marco Mello: marcoASMA@insper.edu.br Prof. Aux. Arnaldo Jr (Tioz\u00e3o): arnaldoavj@insper.edu.br J\u00e1 passou por aqui: (2021-2021) Prof. Aux. Fl\u00e1vio Batista (2016-2020) Prof. Aux. Eduardo Marossi \u00a9 Todos os direitos reservados","title":"Bem vindo a disciplina de Computa\u00e7\u00e3o Embarcada"},{"location":"#objetivos","text":"Ao final da disciplina o estudante deve ser capaz de: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes.","title":"Objetivos"},{"location":"#motivacao","text":"Sistemas embarcados movem o mundo!","title":"Motiva\u00e7\u00e3o"},{"location":"#comecando","text":"Leia mais sobre o curso e a infra necess\u00e1ria em: Sobre","title":"Come\u00e7ando"},{"location":"#historico","text":"Pequeno hist\u00f3rico da evolu\u00e7\u00e3o da disciplina: 2022-2: Sequ\u00eancia dos laborat\u00f3rios alterada, introduzi o RTOS antes dos timers (PIO, DRIVER, PIO-IRQ, RTOS, HCSR04 com RTT). As notas das prova pr\u00e1ticas s\u00e3o bin\u00e1rias e n\u00e3o fazem mais parte da nota final. 2022-1: Aulas 100% presenciais, criamos um grupo no whatsapp para comunicados r\u00e1pidos com a turma, reformulamos os requisitos de alguns de labs e montamos um mini est\u00fadio para grava\u00e7\u00e3o de v\u00eddeos onde o estudante demonstra o funcionamento dos projetos, a APS do IoT virou laborat\u00f3rio. Arnaldo come\u00e7ou como professor auxiliar. 2021-2: Microchip parou de fabricar o m\u00f3dulo de LCD que us\u00e1vamos, por conta disso migramos para um display da Adafruit, aproveitamos para inserir a biblioteca gr\u00e1fica LVGL. A APS gr\u00e1fica focou no desenvolvimento de um ox\u00edmetro. O Fabr\u00edcio foi professor auxiliar. 2021-1: Aulas de segunda online e labs no modelo h\u00edbrido. APS-1 musical/ Projeto 1 (controle) / APS-2 IHM ox\u00edmetro / APS-3 Wifi. A ideia da APS-2 virar o ox\u00edmetro \u00e9 para trazer um tema atual para dentro da disciplina. 2020-2: Aula 100% online por conta da pandemia: sai APS-1 e entra projeto 1, mant\u00e9m APS-2 e APS-3. 2020-1: Devido ao pandemia do corona v\u00edrus o projeto foi cancelado, os alunos receberam um complemento do kit para trabalharem de casa. As APS foram: Musica, LCD bike e WIFI. As avalia\u00e7\u00f5es individuais foram aprimoradas. A parte de UX foi bem trabalhada nesse semestre. 2019-2 (DP): Troquei a APS 2 da m\u00e1quina de lavar para a Bike. Como s\u00f3 tinha um aluno, as APS viraram projetos. 2019-1: Introduzi as APS: Musical; M\u00e1quina de Lavar e Wifi (tinha uma de sensores tamb\u00e9m), os alunos tiveram que entregar 2 projetos: controle/ vending machine e projeto livre. Primeira vez que aparece o projeto fechado do come\u00e7o de semestre. Estreia do lab de Arquitetura 2018-1: Um projeto ao longo do semestre todo. Introduzi avalia\u00e7\u00e3o pr\u00e1tica individual. 2017-1 (primeira turma): Um \u00fanico projeto ao longo do semestre todo.","title":"Hist\u00f3rico"},{"location":"#alguns-projetos-de-turmas-anteriores","text":"Video Video Video Video Video Video Video Video Video Video Video Video Video","title":"Alguns Projetos de turmas anteriores"},{"location":"Aulas/","text":"Aulas Aula est\u00fadio - Segunda - 6/4 Recados Reorganizei canais Teams bancadas s\u00e3o p\u00fablicas Feedback interfaces APS2 github issues Estudar para a nossa primeira avalia\u00e7\u00e3o! J\u00e1 tenham fun\u00e7\u00f5es prontas: configura pinos toggle led ... Aula: In\u00edcio-Fim Atividade Canal Teams 15h45 - 15h55 Recados Geral 15h44 - 17h45 APS2 Bancadas Atendimento: In\u00edcio-Fim Atividade Canal Teams 17h45 - 19h15 Simulado Geral Lab RTOS - Quarta e Quinta - 1 / 4 e 2 / 4 Estudo pr\u00e9vio Recados Simulado AV1 liberado! https://classroom.github.com/a/sUluYIVb Lab entrega C, mas na prova cobraremos at\u00e9 B In\u00edcio-Fim Atividade Canal Teams 15h45 - 15h50 Recados Geral 15h50 - 16h20 Teoria Geral 16h20 - 17h45 Lab RTOS Bancada Segunda 30/3 Apresenta\u00e7\u00e3o APS-2 N\u00e3o pode repedir dupla APS1 Integrantes da mesma bancada! Criar reposit\u00f3rio via link: https://classroom.github.com/g/LFwxvNPN Entrega para sexta Primeira proposta de UI Rodar demos do LCD: https://github.com/Insper/SAME70-examples/tree/master/Screens/RTOS-LCD-maxTouch-Fontes https://github.com/Insper/SAME70-examples/tree/master/Screens/RTOS-LCD-maxTouch-Images https://github.com/Insper/SAME70-examples/tree/master/Screens/RTOS-LCD-maxTouch-Switch-Toggle","title":"Aulas"},{"location":"Aulas/#aulas","text":"","title":"Aulas"},{"location":"Aulas/#aula-estudio-segunda-64","text":"Recados Reorganizei canais Teams bancadas s\u00e3o p\u00fablicas Feedback interfaces APS2 github issues Estudar para a nossa primeira avalia\u00e7\u00e3o! J\u00e1 tenham fun\u00e7\u00f5es prontas: configura pinos toggle led ... Aula: In\u00edcio-Fim Atividade Canal Teams 15h45 - 15h55 Recados Geral 15h44 - 17h45 APS2 Bancadas Atendimento: In\u00edcio-Fim Atividade Canal Teams 17h45 - 19h15 Simulado Geral","title":"Aula est\u00fadio - Segunda - 6/4"},{"location":"Aulas/#lab-rtos-quarta-e-quinta-1-4-e-2-4","text":"Estudo pr\u00e9vio Recados Simulado AV1 liberado! https://classroom.github.com/a/sUluYIVb Lab entrega C, mas na prova cobraremos at\u00e9 B In\u00edcio-Fim Atividade Canal Teams 15h45 - 15h50 Recados Geral 15h50 - 16h20 Teoria Geral 16h20 - 17h45 Lab RTOS Bancada","title":"Lab RTOS - Quarta e Quinta - 1 / 4 e 2 / 4"},{"location":"Aulas/#segunda-303","text":"Apresenta\u00e7\u00e3o APS-2 N\u00e3o pode repedir dupla APS1 Integrantes da mesma bancada! Criar reposit\u00f3rio via link: https://classroom.github.com/g/LFwxvNPN Entrega para sexta Primeira proposta de UI Rodar demos do LCD: https://github.com/Insper/SAME70-examples/tree/master/Screens/RTOS-LCD-maxTouch-Fontes https://github.com/Insper/SAME70-examples/tree/master/Screens/RTOS-LCD-maxTouch-Images https://github.com/Insper/SAME70-examples/tree/master/Screens/RTOS-LCD-maxTouch-Switch-Toggle","title":"Segunda 30/3"},{"location":"Sobre-Curso/","text":"Sobre o curso Avalia\u00e7\u00e3o A avalia\u00e7\u00e3o \u00e9 composta de: Projeto, APS, Avalia\u00e7\u00e3o Pr\u00e1tica e Auto avalia\u00e7\u00e3o. APS: s\u00e3o realizadas em duplas, no total s\u00e3o 3 APS. Projeto: realizado em grupos, no total 1 projeto. Avalia\u00e7\u00e3o pr\u00e1tica: individual, no total s\u00e3o 4 avalia\u00e7\u00f5es. Auto avalia\u00e7\u00e3o: individual, inclui participa\u00e7\u00e3o em aula, desenvolvimento dos laborat\u00f3rios e mapeia os objetivos de aprendizagem. Crit\u00e9rios para o estudante ser aprovado no curso, \u00e9 necess\u00e1rio: Todas as APS com conceito igual ou superior a C. Possuir nota satisfat\u00f3ria em pelo menos 2 avalia\u00e7\u00f5es pr\u00e1ticas. Projeto com nota igual ou superior a C. Possuir participa\u00e7\u00e3o em aula satisfat\u00f3ria. A nota final se dar\u00e1 pela Avalia\u00e7\u00e3o Pr\u00e1tica (pelo menos 2 avalia\u00e7\u00f5es satisfat\u00f3ria) e m\u00e9dia simples entre APS e Projeto. Objetivos de aprendizagem Ao final da disciplina o estudante ser\u00e1 capaz de: Criar softwares para microcontroladores utilizando suas especificidades (perif\u00e9ricos/ lowpower); Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Conte\u00fado Program\u00e1tico Sistemas embarcados microcontrolados e suas tecnologias Linguagem C para sistemas embarcados (firmware) Interface com o mundo externo (digital/anal\u00f3gica) Perif\u00e9ricos de microcontoladores Interrup\u00e7\u00e3o, superloop, Multitask Alimenta\u00e7\u00e3o para sistemas embarcados Otimiza\u00e7\u00e3o energ\u00e9tica Protocolos de comunica\u00e7\u00e3o Conectividade em sistemas embarcados - IoT, computa\u00e7\u00e3o vest\u00edvel, computa\u00e7\u00e3o ub\u00edqua. Sistema operacional de tempo real (RTOS)","title":"Sobre o curso"},{"location":"Sobre-Curso/#sobre-o-curso","text":"","title":"Sobre o curso"},{"location":"Sobre-Curso/#avaliacao","text":"A avalia\u00e7\u00e3o \u00e9 composta de: Projeto, APS, Avalia\u00e7\u00e3o Pr\u00e1tica e Auto avalia\u00e7\u00e3o. APS: s\u00e3o realizadas em duplas, no total s\u00e3o 3 APS. Projeto: realizado em grupos, no total 1 projeto. Avalia\u00e7\u00e3o pr\u00e1tica: individual, no total s\u00e3o 4 avalia\u00e7\u00f5es. Auto avalia\u00e7\u00e3o: individual, inclui participa\u00e7\u00e3o em aula, desenvolvimento dos laborat\u00f3rios e mapeia os objetivos de aprendizagem. Crit\u00e9rios para o estudante ser aprovado no curso, \u00e9 necess\u00e1rio: Todas as APS com conceito igual ou superior a C. Possuir nota satisfat\u00f3ria em pelo menos 2 avalia\u00e7\u00f5es pr\u00e1ticas. Projeto com nota igual ou superior a C. Possuir participa\u00e7\u00e3o em aula satisfat\u00f3ria. A nota final se dar\u00e1 pela Avalia\u00e7\u00e3o Pr\u00e1tica (pelo menos 2 avalia\u00e7\u00f5es satisfat\u00f3ria) e m\u00e9dia simples entre APS e Projeto.","title":"Avalia\u00e7\u00e3o"},{"location":"Sobre-Curso/#objetivos-de-aprendizagem","text":"Ao final da disciplina o estudante ser\u00e1 capaz de: Criar softwares para microcontroladores utilizando suas especificidades (perif\u00e9ricos/ lowpower); Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes.","title":"Objetivos de aprendizagem"},{"location":"Sobre-Curso/#conteudo-programatico","text":"Sistemas embarcados microcontrolados e suas tecnologias Linguagem C para sistemas embarcados (firmware) Interface com o mundo externo (digital/anal\u00f3gica) Perif\u00e9ricos de microcontoladores Interrup\u00e7\u00e3o, superloop, Multitask Alimenta\u00e7\u00e3o para sistemas embarcados Otimiza\u00e7\u00e3o energ\u00e9tica Protocolos de comunica\u00e7\u00e3o Conectividade em sistemas embarcados - IoT, computa\u00e7\u00e3o vest\u00edvel, computa\u00e7\u00e3o ub\u00edqua. Sistema operacional de tempo real (RTOS)","title":"Conte\u00fado Program\u00e1tico"},{"location":"navigation/APS/APS-1-Musical-entregaveis/","text":"APS 1 - Musical - Entreg\u00e1veis Entreg\u00e1veis da APS 1 musical. Leia as regras: Regras Cada issue deve ser fechado com um commit e referenciado no issue. Todos do grupo devem participar (realizar commit, fechar issues) Iremos dar nota com base nessas evid\u00eancias. Somente Professores podem fechar os issues Entrega 1 Entregas referentes a configura\u00e7\u00e3o do hardware. Pino Buzzer Definir e configurar pino que ser\u00e1 usado para conectar o buzzer. Atualizar README.md com defini\u00e7\u00e3o. Inserir #defines no main.c com valores certos #define BUZZER_PIO #define BUZZER_PIO_ID #define BUZZER_PIO_IDX #define BUZZER_PIO_IDX_MASK Atualizar fun\u00e7\u00e3o init() configurando o pino do buzzer como output Pino bot\u00e3o start/pause Definir e configurar pino que ser\u00e1 usado para conectar o bot\u00e3o de start/pause. Atualizar README.md com defini\u00e7\u00e3o. Inserir #defines no main.c com valores certos #define START_PIO #define START_PIO_ID #define START_PIO_IDX #define START_PIO_IDX_MASK Atualizar fun\u00e7\u00e3o init() configurando o pino do bot\u00e3o como input Pino bot\u00e3o sele\u00e7\u00e3o musical Definir e configurar pino que ser\u00e1 usado para conectar o bot\u00e3o de sele\u00e7\u00e3o musical. Atualizar README.md com defini\u00e7\u00e3o. Inserir #defines no main.c com valores certos #define SELECAO_PIO #define SELECAO_PIO_ID #define SELECAO_PIO_IDX #define SELECAO_PIO_IDX_MASK Atualizar fun\u00e7\u00e3o init() configurando o pino do bot\u00e3o como input buzzer_test(int freq) Crie uma fun\u00e7\u00e3o ( buzzer_test(int freq) ) que gera no pino do buzzer uma onda quadrada de frequ\u00eancia definida, para isso voc\u00ea deve usar: pio_set() pio_clear() delay_ns() freq \u00e9 definido em Hz. Entrega 2","title":"APS 1 - Musical - Entreg\u00e1veis"},{"location":"navigation/APS/APS-1-Musical-entregaveis/#aps-1-musical-entregaveis","text":"Entreg\u00e1veis da APS 1 musical. Leia as regras: Regras Cada issue deve ser fechado com um commit e referenciado no issue. Todos do grupo devem participar (realizar commit, fechar issues) Iremos dar nota com base nessas evid\u00eancias. Somente Professores podem fechar os issues","title":"APS 1 - Musical - Entreg\u00e1veis"},{"location":"navigation/APS/APS-1-Musical-entregaveis/#entrega-1","text":"Entregas referentes a configura\u00e7\u00e3o do hardware.","title":"Entrega 1"},{"location":"navigation/APS/APS-1-Musical-entregaveis/#pino-buzzer","text":"Definir e configurar pino que ser\u00e1 usado para conectar o buzzer. Atualizar README.md com defini\u00e7\u00e3o. Inserir #defines no main.c com valores certos #define BUZZER_PIO #define BUZZER_PIO_ID #define BUZZER_PIO_IDX #define BUZZER_PIO_IDX_MASK Atualizar fun\u00e7\u00e3o init() configurando o pino do buzzer como output","title":"Pino Buzzer"},{"location":"navigation/APS/APS-1-Musical-entregaveis/#pino-botao-startpause","text":"Definir e configurar pino que ser\u00e1 usado para conectar o bot\u00e3o de start/pause. Atualizar README.md com defini\u00e7\u00e3o. Inserir #defines no main.c com valores certos #define START_PIO #define START_PIO_ID #define START_PIO_IDX #define START_PIO_IDX_MASK Atualizar fun\u00e7\u00e3o init() configurando o pino do bot\u00e3o como input","title":"Pino bot\u00e3o start/pause"},{"location":"navigation/APS/APS-1-Musical-entregaveis/#pino-botao-selecao-musical","text":"Definir e configurar pino que ser\u00e1 usado para conectar o bot\u00e3o de sele\u00e7\u00e3o musical. Atualizar README.md com defini\u00e7\u00e3o. Inserir #defines no main.c com valores certos #define SELECAO_PIO #define SELECAO_PIO_ID #define SELECAO_PIO_IDX #define SELECAO_PIO_IDX_MASK Atualizar fun\u00e7\u00e3o init() configurando o pino do bot\u00e3o como input","title":"Pino bot\u00e3o sele\u00e7\u00e3o musical"},{"location":"navigation/APS/APS-1-Musical-entregaveis/#buzzer_testint-freq","text":"Crie uma fun\u00e7\u00e3o ( buzzer_test(int freq) ) que gera no pino do buzzer uma onda quadrada de frequ\u00eancia definida, para isso voc\u00ea deve usar: pio_set() pio_clear() delay_ns() freq \u00e9 definido em Hz.","title":"buzzer_test(int freq)"},{"location":"navigation/APS/APS-1-Musical-entregaveis/#entrega-2","text":"","title":"Entrega 2"},{"location":"navigation/APS/APS-1-Musical-software/","text":"APS 1 - Musical - Firmware A seguir iremos explicar os conceitos e dicas de como voc\u00eas deverem prosseguir para executarem esta APS. Info Lembrem de trabalhar no reposit\u00f3rio criado pelo classroom: https://classroom.github.com/a/myFZ2tpa Leia atentamente como trabalhar no reposit\u00f3rio: APS HowTo M\u00fasicas monofonica M\u00fasicas monofonicas ^1 s\u00e3o aquelas que s\u00f3 possuem uma \u00fanica nota tocada por vez, como indicado na partitura a seguir: ref: wikipidia A m\u00fasica monofonica tem o som como a seguir: Pop Goes the Weasel.ogg (wiki) Your browser does not support the audio element. Esse tipo de m\u00fasica foi muito utilizada nos primeiros videogames, quando a sintetiza\u00e7\u00e3o de m\u00fasicas ainda estava no come\u00e7o. Veja como era feito nos Nintendo, aqui j\u00e1 era poss\u00edvel gerar mais de um tom por vez: Buzzer Para gerarmos o som \u00e9 necess\u00e1rio termos algum dispositivo capaz de gerar movimenta\u00e7\u00e3o no ar, o buzzer \u00e9 um dispositivo simples que a partir de uma bobina (controlada por um terminal) conseguimos movimentar um disco que por sua vez movimentar o ar. Os buzzers podem ser de duas categorias (piezoel\u00e9tricos): Ativo: basta energizar o terminal que o dispositivo vibra automaticamente em uma determinada frequ\u00eancia, muito usado para alarmes. Passivo: Um circuito externo (ou microcontrolador) deve gerar a frequ\u00eancia de vibra\u00e7\u00e3o, usado para gerar som. Buzzers s\u00e3o diferentes de altofalantes ^2 em v\u00e1rios aspectos (mec\u00e2nico, eletromec\u00e2nico): n\u00e3o necessitam de tens\u00e3o negativa; possuem um espectro de opera\u00e7\u00e3o menor; baixa resist\u00eancia; baixa pot\u00eancia ... . A conex\u00e3o do buzzer com um microcontrolador se da por dois pinos: Um conectado no terra (gnd) e outro conectado em um pino que o microcontrolador possui controle, conforme ilustra\u00e7\u00e3o a seguir: Gerando som Podemos fazer com que o buzzer oscile em uma determinada frequ\u00eancia, para isso basta gerarmos um sinal de onda quadrada no terminal positivo do dispositivo, isso ir\u00e1 fazer com que o piezo movimente na mesma frequ\u00eancia, gerando o tom desejado. Notas As notas musicais s\u00e3o definidas pela frequ\u00eancia principal que elas emitem, um D\u00f3-4 \u00e9 definido por 262 Hz, um L\u00e1-4 por 440Hz e assim por diante (o 4 se refere ao meio do piano). Al\u00e9m da frequ\u00eancia principal, cada instrumento musical emite outras frequ\u00eancias que comp\u00f5em o som, gerando um som \u00fanico para cada instrumento. Iremos usar a notacao americana para as notas: D\u00f3 R\u00e9 Mi F\u00e1 Sol L\u00e1 S\u00ed C D E F G A B Ref: https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/Frequency_vs_name.svg/350px-Frequency_vs_name.svg.png Wikipidia Frequ\u00eancias Lembre que uma onda quadrada pode ser decomposta em infinitas senoides pela transformada de Fourier. Sendo a componente principal (de maior energia) centrada na frequ\u00eancia da onda quadrada (no nosso caso): Portanto o som que iremos escutar ser\u00e1 composto da frequ\u00eancia principal mais as harm\u00f3nicas. ref: https://mathworld.wolfram.com/images/eps-gif/FourierSeriesSquareWave_800.gif Existem diversas maneiras de gerarmos uma onda quadrada em um pino do microcontrolador, a que estamos sugerindo aqui n\u00e3o envolve nenhum perif\u00e9rico espec\u00edfico do microcontrolador, logo iremos fazer tudo por c\u00f3digo. Por exemplo, para gerar uma onda quadrada de 1000 Hz: while ( 1 ){ pio_set (...); delay_us ( 500 ); pio_clear (...); delay_us ( 500 ); } Info Tudo depende do microcontrolador, mas podemos gerar uma onda quadrada com os perif\u00e9ricos: PWM, TimerCounter. As vantagens de fazermos isso s\u00e3o: N\u00e3o inutilizamos o CORE com as funcoes de delay Conseguimos facilmente ter mais de uma frequ\u00eancia gerada. Menor gasto energ\u00e9tico M\u00fasica Eu fiz por anos aula de sax alto e meu professor falava que para come\u00e7ar a tocar uma m\u00fasica bastava: tocar a nota certa no momento certo e n\u00e3o tocar quando n\u00e3o for para tocar , para quem tem pr\u00e1tica \u00e9 f\u00e1cil, mas para mim n\u00e3o era. Trouxe este assunto para explicar um pouco como iremos reproduzir uma m\u00fasica. Cada m\u00fasica ser\u00e1 formada por notas (frequ\u00eancias), pela dura\u00e7\u00e3o da nota e por um sil\u00eancio entre notas (que tamb\u00e9m tem dura\u00e7\u00e3o ). Toda essa informa\u00e7\u00e3o est\u00e1 presente na partitura: ref: https://www.musicnotes.com/now/tips/how-to-read-sheet-music/ Portanto para reproduzirmos uma m\u00fasica teremos que para cada intervalo de tempo: Reproduzir uma nota (gerar a frequ\u00eancia da nota no pino do buzzer) ou n\u00e3o tocar nada (pausa) Manter a nota/pausa pelo tempo determinado Ir para o pr\u00f3ximo intervalo de tempo Refer\u00eancia Nesta APS \u00e9 para utilizarem as m\u00fasicas fornecidas no reposit\u00f3rio a seguir: https://github.com/robsoncouto/arduino-songs Fornecido por: Robson Couto, 2019 Info Os exemplos deste reposit\u00f3rio s\u00f3 funcionam em Arduino, n\u00e3o conseguimos usar de maneira direta no nosso kit de desenvolvimento. Warning Lembre de referenciar o reposit\u00f3rio quando utilizar as m\u00fasicas por ele fornecido. Como descrito no pr\u00f3prio README. Every sketch here has been written by myself, although based on scores I found online or books I own. These scores are linked in each file when possible. You can use the sketches for anything, I only kindly ask that you give credit if you use these codes on a tutorial, video, example, etc. Analisando firmware O desenvolvedor disponibiliza diversas m\u00fasicas de v\u00e1rios temas diferentes: Filmes, Jogos, Cl\u00e1ssicas, ... . Vamos analisar como as m\u00fasicas s\u00e3o disponibilizadas. Para isso iremos pegar como exemplo a m\u00fasica tema do M\u00e1rio: https://github.com/robsoncouto/arduino-songs/blob/master/supermariobros/supermariobros.ino Notas No comece do arquivo temos as defini\u00e7\u00f5es das notas: #define NOTE_B0 31 #define NOTE_C1 33 #define NOTE_CS1 35 #define NOTE_D1 37 #define NOTE_DS1 39 #define NOTE_E1 41 #define NOTE_F1 44 #define NOTE_FS1 46 #define NOTE_G1 49 #define NOTE_GS1 52 #define NOTE_A1 55 M\u00fasica No arquivo dispon\u00edvel um vetor chamado melody que possui nos index pares ( 0 , 2 , ...) as notas e nos index \u00edmpares ( 1 , 3 , ... ) o tempo de furac\u00e3o da nota (com base em uma refer\u00eancia). // notes of the moledy followed by the duration. // a 4 means a quarter note, 8 an eighteenth , 16 sixteenth, so on // !!negative numbers are used to represent dotted notes, // so -4 means a dotted quarter note, that is, a quarter plus an eighteenth!! int melody [] = { // Super Mario Bros theme // Score available at https://musescore.com/user/2123/scores/2145 // Theme by Koji Kondo NOTE_E5 , 8 , NOTE_E5 , 8 , REST , 8 , NOTE_E5 , 8 , REST , 8 , NOTE_C5 , 8 , NOTE_E5 , 8 , //1 NOTE_G5 , 4 , REST , 4 , NOTE_G4 , 8 , REST , 4 , NOTE_C5 , -4 , NOTE_G4 , 8 , REST , 4 , NOTE_E4 , -4 , // 3 NOTE_A4 , 4 , NOTE_B4 , 4 , NOTE_AS4 , 8 , NOTE_A4 , 4 , Tempo Os tempos s\u00e3o definidos em partes de uma Semibreve/wholenote ^3 (que \u00e9 a nota de maior dura\u00e7\u00e3o), ou seja, o valor 4 refere-se a $\u00bc$ da semibreve, 8 a $\u215b$ do tempo total... . O valor da semibreve/wholenote \u00e9 definida no pr\u00f3prio c\u00f3digo: // change this to make the song slower or faster int tempo = 200 ; // hide code // .... // this calculates the duration of a whole note in ms int wholenote = ( 60000 * 4 ) / tempo ; Valores negativos de tempo ( -4 , -8 , ... ) representam que a nota tem a dura\u00e7\u00e3o dela mais meio tempo. No c\u00f3digo do reposit\u00f3rio, ele implementa o c\u00e1lculo da durac\u00e3o da nota da seguinte maneira: // calculates the duration of each note divider = melody [ thisNote + 1 ]; if ( divider > 0 ) { // regular note, just proceed noteDuration = ( wholenote ) / divider ; } else if ( divider < 0 ) { // dotted notes are represented with negative durations!! noteDuration = ( wholenote ) / abs ( divider ); noteDuration *= 1.5 ; // increases the duration in half for dotted notes } thisNote \u00e9 o index da nota atual. Tip Eu reescreveria este trecho de c\u00f3digo da seguinte maneira, com o objetivo de ficar mais simples e compacto: // calculates the duration of each note divider = melody [ thisNote + 1 ]; noteDuration = ( wholenote ) / abs ( divider ); if ( divider < 0 ) { noteDuration *= 1.5 ; // increases the duration in half for dotted notes } Reproduzindo Agora j\u00e1 temos tudo para reproduzir a m\u00fasica, precisamos varrer o vetor melody e para cada nota (index par) gerar a onda quadrada no pino pelo tempo determinado em: noteDuration , para isso definem o tamanho do vetor: // sizeof gives the number of bytes, each int value is composed of two bytes (16 bits) // there are two values per note (pitch and duration), so for each note there are four bytes int notes = sizeof ( melody ) / sizeof ( melody [ 0 ]) / 2 ; C: tipos A linguagem C opera com tipos de dados multiplos de um byte (8 bits), e possui duas maneiras de indicar o tipo da vari\u00e1vel: byte half word word duble word char short int long int8_t int16_t int32_t int64_t C: sizeof sizeof(type) recebe como par\u00e2metro um tipo (pode ser uma vari\u00e1vel, vetor ou struct) e retorna quantos bytes o tipo ocupa! Veja os exemplos a seguir: uint32_t foo ; printf ( \"Tamanho foo em bytes: %d \\n \" , sizeof ( foo )); // $ Tamanho foo em bytes: 4 uint32_t bar [ 2 ]; printf ( \"Tamanho bar em bytes: %d \\n \" , sizeof ( bar )) // $ Tamanho bar em bytes: 8 Note que a vari\u00e1vel foo ocupa 4 bytes (pois \u00e9 um inteiro: $32/8=4$) e o vetor bar ocupa 8 bytes , pois aloca dois enderecos de mem\u00f3ria do tipo int. O sizeof \u00e9 executado em tempo de compila\u00e7\u00e3o, n\u00e3o podemos usar para mem\u00f3rias alocadas din\u00e2micamente: // n\u00e3o podemos fazer isso! int * foo = malloc ( 32 ); printf ( \"Tamanho bar em bytes: %d \\n \" , sizeof ( foo )) E ent\u00e3o interage no vetor e reproduz a nota usando a fun\u00e7\u00e3o tone // iterate over the notes of the melody. // Remember, the array is twice the number of notes (notes + durations) for ( int thisNote = 0 ; thisNote < notes * 2 ; thisNote = thisNote + 2 ) { // calculates the duration of each note // ... // ... hide // we only play the note for 90% of the duration, leaving 10% as a pause tone ( buzzer , melody [ thisNote ], noteDuration * 0.9 ); // Wait for the specief duration before playing the next note. delay ( noteDuration ); // stop the waveform generation before the next note. noTone ( buzzer ); } A fun\u00e7\u00e3o tone do Arduino gera uma onda quadrada em um pino ( buzzer ), de frequ\u00eancia melody[thisNote] e dura\u00e7\u00e3o noteDuration * 0.9 . tone Voc\u00eas v\u00e3o ter que implementar uma fun\u00e7\u00e3o tone pr\u00f3pria! tone Tip Apenas uma sugest\u00e3o de como implementar. Sugerimos implementarem uma fun\u00e7\u00e3o que receba como par\u00e2metro uma frequ\u00eancia e um tempo (em milissegundos) e que reproduza uma onda quadrada em um pino do microcontrolador, na frequ\u00eancia e tempo passado como argumento para a fun\u00e7\u00e3o. /** * freq: Frequecia em Hz * time: Tempo em ms que o tom deve ser gerado */ void tone ( int freq , int time ){ .... .... } Info Como fazer? O melhor jeito \u00e9 contar quantos pulsos (freq) existem dentro de um tempo (time) e ent\u00e3o fazer um loop que gere a quantidade de pulsos (na frequ\u00eancia certa).","title":"APS 1 - Musical - Firmware"},{"location":"navigation/APS/APS-1-Musical-software/#aps-1-musical-firmware","text":"A seguir iremos explicar os conceitos e dicas de como voc\u00eas deverem prosseguir para executarem esta APS. Info Lembrem de trabalhar no reposit\u00f3rio criado pelo classroom: https://classroom.github.com/a/myFZ2tpa Leia atentamente como trabalhar no reposit\u00f3rio: APS HowTo","title":"APS 1 - Musical - Firmware"},{"location":"navigation/APS/APS-1-Musical-software/#musicas-monofonica","text":"M\u00fasicas monofonicas ^1 s\u00e3o aquelas que s\u00f3 possuem uma \u00fanica nota tocada por vez, como indicado na partitura a seguir: ref: wikipidia A m\u00fasica monofonica tem o som como a seguir: Pop Goes the Weasel.ogg (wiki) Your browser does not support the audio element. Esse tipo de m\u00fasica foi muito utilizada nos primeiros videogames, quando a sintetiza\u00e7\u00e3o de m\u00fasicas ainda estava no come\u00e7o. Veja como era feito nos Nintendo, aqui j\u00e1 era poss\u00edvel gerar mais de um tom por vez:","title":"M\u00fasicas monofonica"},{"location":"navigation/APS/APS-1-Musical-software/#buzzer","text":"Para gerarmos o som \u00e9 necess\u00e1rio termos algum dispositivo capaz de gerar movimenta\u00e7\u00e3o no ar, o buzzer \u00e9 um dispositivo simples que a partir de uma bobina (controlada por um terminal) conseguimos movimentar um disco que por sua vez movimentar o ar. Os buzzers podem ser de duas categorias (piezoel\u00e9tricos): Ativo: basta energizar o terminal que o dispositivo vibra automaticamente em uma determinada frequ\u00eancia, muito usado para alarmes. Passivo: Um circuito externo (ou microcontrolador) deve gerar a frequ\u00eancia de vibra\u00e7\u00e3o, usado para gerar som. Buzzers s\u00e3o diferentes de altofalantes ^2 em v\u00e1rios aspectos (mec\u00e2nico, eletromec\u00e2nico): n\u00e3o necessitam de tens\u00e3o negativa; possuem um espectro de opera\u00e7\u00e3o menor; baixa resist\u00eancia; baixa pot\u00eancia ... . A conex\u00e3o do buzzer com um microcontrolador se da por dois pinos: Um conectado no terra (gnd) e outro conectado em um pino que o microcontrolador possui controle, conforme ilustra\u00e7\u00e3o a seguir:","title":"Buzzer"},{"location":"navigation/APS/APS-1-Musical-software/#gerando-som","text":"Podemos fazer com que o buzzer oscile em uma determinada frequ\u00eancia, para isso basta gerarmos um sinal de onda quadrada no terminal positivo do dispositivo, isso ir\u00e1 fazer com que o piezo movimente na mesma frequ\u00eancia, gerando o tom desejado. Notas As notas musicais s\u00e3o definidas pela frequ\u00eancia principal que elas emitem, um D\u00f3-4 \u00e9 definido por 262 Hz, um L\u00e1-4 por 440Hz e assim por diante (o 4 se refere ao meio do piano). Al\u00e9m da frequ\u00eancia principal, cada instrumento musical emite outras frequ\u00eancias que comp\u00f5em o som, gerando um som \u00fanico para cada instrumento. Iremos usar a notacao americana para as notas: D\u00f3 R\u00e9 Mi F\u00e1 Sol L\u00e1 S\u00ed C D E F G A B Ref: https://upload.wikimedia.org/wikipedia/commons/thumb/6/65/Frequency_vs_name.svg/350px-Frequency_vs_name.svg.png Wikipidia Frequ\u00eancias Lembre que uma onda quadrada pode ser decomposta em infinitas senoides pela transformada de Fourier. Sendo a componente principal (de maior energia) centrada na frequ\u00eancia da onda quadrada (no nosso caso): Portanto o som que iremos escutar ser\u00e1 composto da frequ\u00eancia principal mais as harm\u00f3nicas. ref: https://mathworld.wolfram.com/images/eps-gif/FourierSeriesSquareWave_800.gif Existem diversas maneiras de gerarmos uma onda quadrada em um pino do microcontrolador, a que estamos sugerindo aqui n\u00e3o envolve nenhum perif\u00e9rico espec\u00edfico do microcontrolador, logo iremos fazer tudo por c\u00f3digo. Por exemplo, para gerar uma onda quadrada de 1000 Hz: while ( 1 ){ pio_set (...); delay_us ( 500 ); pio_clear (...); delay_us ( 500 ); } Info Tudo depende do microcontrolador, mas podemos gerar uma onda quadrada com os perif\u00e9ricos: PWM, TimerCounter. As vantagens de fazermos isso s\u00e3o: N\u00e3o inutilizamos o CORE com as funcoes de delay Conseguimos facilmente ter mais de uma frequ\u00eancia gerada. Menor gasto energ\u00e9tico","title":"Gerando som"},{"location":"navigation/APS/APS-1-Musical-software/#musica","text":"Eu fiz por anos aula de sax alto e meu professor falava que para come\u00e7ar a tocar uma m\u00fasica bastava: tocar a nota certa no momento certo e n\u00e3o tocar quando n\u00e3o for para tocar , para quem tem pr\u00e1tica \u00e9 f\u00e1cil, mas para mim n\u00e3o era. Trouxe este assunto para explicar um pouco como iremos reproduzir uma m\u00fasica. Cada m\u00fasica ser\u00e1 formada por notas (frequ\u00eancias), pela dura\u00e7\u00e3o da nota e por um sil\u00eancio entre notas (que tamb\u00e9m tem dura\u00e7\u00e3o ). Toda essa informa\u00e7\u00e3o est\u00e1 presente na partitura: ref: https://www.musicnotes.com/now/tips/how-to-read-sheet-music/ Portanto para reproduzirmos uma m\u00fasica teremos que para cada intervalo de tempo: Reproduzir uma nota (gerar a frequ\u00eancia da nota no pino do buzzer) ou n\u00e3o tocar nada (pausa) Manter a nota/pausa pelo tempo determinado Ir para o pr\u00f3ximo intervalo de tempo","title":"M\u00fasica"},{"location":"navigation/APS/APS-1-Musical-software/#referencia","text":"Nesta APS \u00e9 para utilizarem as m\u00fasicas fornecidas no reposit\u00f3rio a seguir: https://github.com/robsoncouto/arduino-songs Fornecido por: Robson Couto, 2019 Info Os exemplos deste reposit\u00f3rio s\u00f3 funcionam em Arduino, n\u00e3o conseguimos usar de maneira direta no nosso kit de desenvolvimento. Warning Lembre de referenciar o reposit\u00f3rio quando utilizar as m\u00fasicas por ele fornecido. Como descrito no pr\u00f3prio README. Every sketch here has been written by myself, although based on scores I found online or books I own. These scores are linked in each file when possible. You can use the sketches for anything, I only kindly ask that you give credit if you use these codes on a tutorial, video, example, etc.","title":"Refer\u00eancia"},{"location":"navigation/APS/APS-1-Musical-software/#analisando-firmware","text":"O desenvolvedor disponibiliza diversas m\u00fasicas de v\u00e1rios temas diferentes: Filmes, Jogos, Cl\u00e1ssicas, ... . Vamos analisar como as m\u00fasicas s\u00e3o disponibilizadas. Para isso iremos pegar como exemplo a m\u00fasica tema do M\u00e1rio: https://github.com/robsoncouto/arduino-songs/blob/master/supermariobros/supermariobros.ino","title":"Analisando firmware"},{"location":"navigation/APS/APS-1-Musical-software/#notas","text":"No comece do arquivo temos as defini\u00e7\u00f5es das notas: #define NOTE_B0 31 #define NOTE_C1 33 #define NOTE_CS1 35 #define NOTE_D1 37 #define NOTE_DS1 39 #define NOTE_E1 41 #define NOTE_F1 44 #define NOTE_FS1 46 #define NOTE_G1 49 #define NOTE_GS1 52 #define NOTE_A1 55","title":"Notas"},{"location":"navigation/APS/APS-1-Musical-software/#musica_1","text":"No arquivo dispon\u00edvel um vetor chamado melody que possui nos index pares ( 0 , 2 , ...) as notas e nos index \u00edmpares ( 1 , 3 , ... ) o tempo de furac\u00e3o da nota (com base em uma refer\u00eancia). // notes of the moledy followed by the duration. // a 4 means a quarter note, 8 an eighteenth , 16 sixteenth, so on // !!negative numbers are used to represent dotted notes, // so -4 means a dotted quarter note, that is, a quarter plus an eighteenth!! int melody [] = { // Super Mario Bros theme // Score available at https://musescore.com/user/2123/scores/2145 // Theme by Koji Kondo NOTE_E5 , 8 , NOTE_E5 , 8 , REST , 8 , NOTE_E5 , 8 , REST , 8 , NOTE_C5 , 8 , NOTE_E5 , 8 , //1 NOTE_G5 , 4 , REST , 4 , NOTE_G4 , 8 , REST , 4 , NOTE_C5 , -4 , NOTE_G4 , 8 , REST , 4 , NOTE_E4 , -4 , // 3 NOTE_A4 , 4 , NOTE_B4 , 4 , NOTE_AS4 , 8 , NOTE_A4 , 4 ,","title":"M\u00fasica"},{"location":"navigation/APS/APS-1-Musical-software/#tempo","text":"Os tempos s\u00e3o definidos em partes de uma Semibreve/wholenote ^3 (que \u00e9 a nota de maior dura\u00e7\u00e3o), ou seja, o valor 4 refere-se a $\u00bc$ da semibreve, 8 a $\u215b$ do tempo total... . O valor da semibreve/wholenote \u00e9 definida no pr\u00f3prio c\u00f3digo: // change this to make the song slower or faster int tempo = 200 ; // hide code // .... // this calculates the duration of a whole note in ms int wholenote = ( 60000 * 4 ) / tempo ; Valores negativos de tempo ( -4 , -8 , ... ) representam que a nota tem a dura\u00e7\u00e3o dela mais meio tempo. No c\u00f3digo do reposit\u00f3rio, ele implementa o c\u00e1lculo da durac\u00e3o da nota da seguinte maneira: // calculates the duration of each note divider = melody [ thisNote + 1 ]; if ( divider > 0 ) { // regular note, just proceed noteDuration = ( wholenote ) / divider ; } else if ( divider < 0 ) { // dotted notes are represented with negative durations!! noteDuration = ( wholenote ) / abs ( divider ); noteDuration *= 1.5 ; // increases the duration in half for dotted notes } thisNote \u00e9 o index da nota atual. Tip Eu reescreveria este trecho de c\u00f3digo da seguinte maneira, com o objetivo de ficar mais simples e compacto: // calculates the duration of each note divider = melody [ thisNote + 1 ]; noteDuration = ( wholenote ) / abs ( divider ); if ( divider < 0 ) { noteDuration *= 1.5 ; // increases the duration in half for dotted notes }","title":"Tempo"},{"location":"navigation/APS/APS-1-Musical-software/#reproduzindo","text":"Agora j\u00e1 temos tudo para reproduzir a m\u00fasica, precisamos varrer o vetor melody e para cada nota (index par) gerar a onda quadrada no pino pelo tempo determinado em: noteDuration , para isso definem o tamanho do vetor: // sizeof gives the number of bytes, each int value is composed of two bytes (16 bits) // there are two values per note (pitch and duration), so for each note there are four bytes int notes = sizeof ( melody ) / sizeof ( melody [ 0 ]) / 2 ; C: tipos A linguagem C opera com tipos de dados multiplos de um byte (8 bits), e possui duas maneiras de indicar o tipo da vari\u00e1vel: byte half word word duble word char short int long int8_t int16_t int32_t int64_t C: sizeof sizeof(type) recebe como par\u00e2metro um tipo (pode ser uma vari\u00e1vel, vetor ou struct) e retorna quantos bytes o tipo ocupa! Veja os exemplos a seguir: uint32_t foo ; printf ( \"Tamanho foo em bytes: %d \\n \" , sizeof ( foo )); // $ Tamanho foo em bytes: 4 uint32_t bar [ 2 ]; printf ( \"Tamanho bar em bytes: %d \\n \" , sizeof ( bar )) // $ Tamanho bar em bytes: 8 Note que a vari\u00e1vel foo ocupa 4 bytes (pois \u00e9 um inteiro: $32/8=4$) e o vetor bar ocupa 8 bytes , pois aloca dois enderecos de mem\u00f3ria do tipo int. O sizeof \u00e9 executado em tempo de compila\u00e7\u00e3o, n\u00e3o podemos usar para mem\u00f3rias alocadas din\u00e2micamente: // n\u00e3o podemos fazer isso! int * foo = malloc ( 32 ); printf ( \"Tamanho bar em bytes: %d \\n \" , sizeof ( foo )) E ent\u00e3o interage no vetor e reproduz a nota usando a fun\u00e7\u00e3o tone // iterate over the notes of the melody. // Remember, the array is twice the number of notes (notes + durations) for ( int thisNote = 0 ; thisNote < notes * 2 ; thisNote = thisNote + 2 ) { // calculates the duration of each note // ... // ... hide // we only play the note for 90% of the duration, leaving 10% as a pause tone ( buzzer , melody [ thisNote ], noteDuration * 0.9 ); // Wait for the specief duration before playing the next note. delay ( noteDuration ); // stop the waveform generation before the next note. noTone ( buzzer ); } A fun\u00e7\u00e3o tone do Arduino gera uma onda quadrada em um pino ( buzzer ), de frequ\u00eancia melody[thisNote] e dura\u00e7\u00e3o noteDuration * 0.9 . tone Voc\u00eas v\u00e3o ter que implementar uma fun\u00e7\u00e3o tone pr\u00f3pria!","title":"Reproduzindo"},{"location":"navigation/APS/APS-1-Musical-software/#tone","text":"Tip Apenas uma sugest\u00e3o de como implementar. Sugerimos implementarem uma fun\u00e7\u00e3o que receba como par\u00e2metro uma frequ\u00eancia e um tempo (em milissegundos) e que reproduza uma onda quadrada em um pino do microcontrolador, na frequ\u00eancia e tempo passado como argumento para a fun\u00e7\u00e3o. /** * freq: Frequecia em Hz * time: Tempo em ms que o tom deve ser gerado */ void tone ( int freq , int time ){ .... .... } Info Como fazer? O melhor jeito \u00e9 contar quantos pulsos (freq) existem dentro de um tempo (time) e ent\u00e3o fazer um loop que gere a quantidade de pulsos (na frequ\u00eancia certa).","title":"tone"},{"location":"navigation/APS/APS-1-Musical/","text":"APS 1 - Musical Entrega Final 20/3/2022 Nesta APS voc\u00eas ir\u00e3o desenvolver um sistema embarcado que reproduz uma m\u00fasica monofonia , para isso ir\u00e3o utilizar um buzzer conectado a um pino do microcontrolador. Veja um exemplo de entrega do semestre passado: Regras Leia atentamente as regras a seguir: Pl\u00e1gio Voc\u00ea n\u00e3o pode copiar c\u00f3digo (parcial ou total) de outro grupo (do mesmo ou de outro semestre). Voc\u00ea pode usar qualquer c\u00f3digo fornecido pela equipe. C\u00f3digo da internet? Voc\u00ea n\u00e3o pode copiar grandes trechos. C\u00f3digo da internet? Se usou alguma coisa, referencie no README. A regra completa pode ser acessada em: https://www.insper.edu.br/portaldoaluno/wp-content/uploads/2018/08/orientacoes_integridade_intelectual-Engenharias.pdf Atraso Para cada 3 dias de atraso ser\u00e1 descontado meia rubrica. Dupla A APS pode ser realizada em dupla. Voc\u00ea n\u00e3o vai poder repetir dupla na pr\u00f3xima APS. O desenvolvimento do projeto deve ser feito no reposit\u00f3rio criado pelo classroom: https://classroom.github.com/a/myFZ2tpa Leia atentamente como trabalhar no reposit\u00f3rio: APS HowTo Entrega Carregando\u2026 Descri\u00e7\u00e3o A entrega final dever\u00e1 ser um sistema embarcado que via a adi\u00e7\u00e3o de um buzzer ao uC o mesmo deve ser capaz de reproduzir m\u00fasicas 'conhecidas'. Al\u00e9m do buzzer deve-se adicionar dois bot\u00f5es ao kit, para ser usado para: mudar de m\u00fasica pause / play. O pause deve interromper a m\u00fasica e o play retomar do ponto que parou. Materiais Os materiais a seguir est\u00e3o dispon\u00edveis no kit de embarcados e s\u00e3o necess\u00e1rios para realizar a APS: 2x bot\u00f5es (push buttons) 1x protoboard 1x buzzer Refer\u00eancias A seguir algumas refer\u00eancias: https://github.com/robsoncouto/arduino-songs/ https://www.youtube.com/watch?v=-kkxs_fekWM https://www.princetronics.com/supermariothemesong/ https://www.hackster.io/muhammed-shameel-k-v/how-to-play-music-with-a-buzzer-and-arduino-b9a25d https://github.com/xitangg/-Pirates-of-the-Caribbean-Theme-Song/blob/master/Pirates_of_the_Caribbean_-_Theme_Song.ino Dicas A p\u00e1gina APS/APS 1 - Musical - Firmware possui dicas valiosas de como realizar a implementa\u00e7\u00e3o. Rubrica A rubrica a seguir ser\u00e1 aplicada a nota da entrega: https://forms.gle/ycM3f82Z7YhE9w9j7 A+ M\u00fasicas organizadas em vetores de structs (ponteiros) A Utiliza interrup\u00e7\u00e3o nos bot\u00f5es Cria um arquivo .c .h com as fun\u00e7\u00f5es de reprodu\u00e7\u00e3o musical B+ README.md explica como o software foi estruturado Faz uso de #define sempre que poss\u00edvel Terceira m\u00fasica Exibir uma barra com a indica\u00e7\u00e3o do progresso da m\u00fasica B M\u00fasica separadas em arquivos .h Utiliza struct para organizar as m\u00fasicas C\u00f3digo organizado em fun\u00e7\u00f5es e que recebem struct contendo m\u00fasica Exibir o nome da m\u00fasica no OLED Fecha todos os issues que forem abertos ap\u00f3s a entrega C+ LED piscando de acordo com a m\u00fasica (adicionar um LED ao projeto) C Reposit\u00f3rio cont\u00e9m README.md com liga\u00e7\u00f5es el\u00e9trica e passos de como usar o projeto, assim como link para o v\u00eddeo e refer\u00eancia a outros c\u00f3digos Funcionalidade de PAUSE / PLAY Bot\u00e3o de sele\u00e7\u00e3o musical Indica\u00e7\u00e3o visual de qual m\u00fasica foi selecionada Reproduz duas m\u00fasicas (de forma intelig\u00edvel) Utiliza m\u00fasicas do reposit\u00f3rio indicado Fecha todos os issues que forem abertos pela equipe D Faltando um item de C I Mais que dois itens de C faltando","title":"APS 1 - Musical"},{"location":"navigation/APS/APS-1-Musical/#aps-1-musical","text":"Entrega Final 20/3/2022 Nesta APS voc\u00eas ir\u00e3o desenvolver um sistema embarcado que reproduz uma m\u00fasica monofonia , para isso ir\u00e3o utilizar um buzzer conectado a um pino do microcontrolador. Veja um exemplo de entrega do semestre passado:","title":"APS 1 - Musical"},{"location":"navigation/APS/APS-1-Musical/#regras","text":"Leia atentamente as regras a seguir: Pl\u00e1gio Voc\u00ea n\u00e3o pode copiar c\u00f3digo (parcial ou total) de outro grupo (do mesmo ou de outro semestre). Voc\u00ea pode usar qualquer c\u00f3digo fornecido pela equipe. C\u00f3digo da internet? Voc\u00ea n\u00e3o pode copiar grandes trechos. C\u00f3digo da internet? Se usou alguma coisa, referencie no README. A regra completa pode ser acessada em: https://www.insper.edu.br/portaldoaluno/wp-content/uploads/2018/08/orientacoes_integridade_intelectual-Engenharias.pdf Atraso Para cada 3 dias de atraso ser\u00e1 descontado meia rubrica. Dupla A APS pode ser realizada em dupla. Voc\u00ea n\u00e3o vai poder repetir dupla na pr\u00f3xima APS. O desenvolvimento do projeto deve ser feito no reposit\u00f3rio criado pelo classroom: https://classroom.github.com/a/myFZ2tpa Leia atentamente como trabalhar no reposit\u00f3rio: APS HowTo Entrega Carregando\u2026","title":"Regras"},{"location":"navigation/APS/APS-1-Musical/#descricao","text":"A entrega final dever\u00e1 ser um sistema embarcado que via a adi\u00e7\u00e3o de um buzzer ao uC o mesmo deve ser capaz de reproduzir m\u00fasicas 'conhecidas'. Al\u00e9m do buzzer deve-se adicionar dois bot\u00f5es ao kit, para ser usado para: mudar de m\u00fasica pause / play. O pause deve interromper a m\u00fasica e o play retomar do ponto que parou.","title":"Descri\u00e7\u00e3o"},{"location":"navigation/APS/APS-1-Musical/#materiais","text":"Os materiais a seguir est\u00e3o dispon\u00edveis no kit de embarcados e s\u00e3o necess\u00e1rios para realizar a APS: 2x bot\u00f5es (push buttons) 1x protoboard 1x buzzer","title":"Materiais"},{"location":"navigation/APS/APS-1-Musical/#referencias","text":"A seguir algumas refer\u00eancias: https://github.com/robsoncouto/arduino-songs/ https://www.youtube.com/watch?v=-kkxs_fekWM https://www.princetronics.com/supermariothemesong/ https://www.hackster.io/muhammed-shameel-k-v/how-to-play-music-with-a-buzzer-and-arduino-b9a25d https://github.com/xitangg/-Pirates-of-the-Caribbean-Theme-Song/blob/master/Pirates_of_the_Caribbean_-_Theme_Song.ino","title":"Refer\u00eancias"},{"location":"navigation/APS/APS-1-Musical/#dicas","text":"A p\u00e1gina APS/APS 1 - Musical - Firmware possui dicas valiosas de como realizar a implementa\u00e7\u00e3o.","title":"Dicas"},{"location":"navigation/APS/APS-1-Musical/#rubrica","text":"A rubrica a seguir ser\u00e1 aplicada a nota da entrega: https://forms.gle/ycM3f82Z7YhE9w9j7 A+ M\u00fasicas organizadas em vetores de structs (ponteiros) A Utiliza interrup\u00e7\u00e3o nos bot\u00f5es Cria um arquivo .c .h com as fun\u00e7\u00f5es de reprodu\u00e7\u00e3o musical B+ README.md explica como o software foi estruturado Faz uso de #define sempre que poss\u00edvel Terceira m\u00fasica Exibir uma barra com a indica\u00e7\u00e3o do progresso da m\u00fasica B M\u00fasica separadas em arquivos .h Utiliza struct para organizar as m\u00fasicas C\u00f3digo organizado em fun\u00e7\u00f5es e que recebem struct contendo m\u00fasica Exibir o nome da m\u00fasica no OLED Fecha todos os issues que forem abertos ap\u00f3s a entrega C+ LED piscando de acordo com a m\u00fasica (adicionar um LED ao projeto) C Reposit\u00f3rio cont\u00e9m README.md com liga\u00e7\u00f5es el\u00e9trica e passos de como usar o projeto, assim como link para o v\u00eddeo e refer\u00eancia a outros c\u00f3digos Funcionalidade de PAUSE / PLAY Bot\u00e3o de sele\u00e7\u00e3o musical Indica\u00e7\u00e3o visual de qual m\u00fasica foi selecionada Reproduz duas m\u00fasicas (de forma intelig\u00edvel) Utiliza m\u00fasicas do reposit\u00f3rio indicado Fecha todos os issues que forem abertos pela equipe D Faltando um item de C I Mais que dois itens de C faltando","title":"Rubrica"},{"location":"navigation/APS/APS-2-Oximetro/","text":"APA 2 - Ox\u00edmetro N\u00e3o estamos desenvolvendo um equipamento m\u00e9dico, mas sim um prot\u00f3tipo acad\u00eamico. Desenvolver um prot\u00f3tipo de um ox\u00edmetro, dispositivo m\u00e9dico para medir indiretamente a quantidade de oxig\u00eanio no sangue. O dispositivo ser\u00e1 composto por um display de LCD colorido sens\u00edvel ao toque (touchscreen), a interface com o usu\u00e1rio ser\u00e1 atrav\u00e9s do display. fonte: https://pt.wikipedia.org/wiki/Ox%C3%ADmetro_de_pulso Info Para come\u00e7ar crie o reposit\u00f3rio no classroom: https://classroom.github.com/g/Sp5pYx1p Voc\u00ea deve utilizar como base o c\u00f3digo dispon\u00edvel no reposit\u00f3rio! firmware O projeto deve ser desenvolvido usando um RTOS , no desenvolvimento devem isolar as tarefas de processamento de dados das de exibic\u00e3o (LCD). Info O freeRTOS n\u00e3o possui certifica\u00e7\u00e3o na FDA, neste caso dever\u00edamos optar por um RTOS que possui a aprovac\u00e3o, na maioria dos casos s\u00e3o sistemas com licen\u00e7a comercial, tal como: SafeRTOS vxworks O plano original era utilizar o sensor max30100 (incluso no kit de voc\u00eas), mas ap\u00f3s muito tempo tentando n\u00e3o conseguimos fazer o sensor funcionar com nossa placa, acreditamos que o mesmo veio com problema de hardware que impossibilitou o seu uso. Por conta disso iremos simular os dados que seriam lidos pelo sensor (oxigena\u00e7\u00e3o e batimento card\u00edaco). Os dados ser\u00e3o gerados como indicado a seguir. task_aps2 A task_aps2 \u00e9 a tarefa respons\u00e1vel gerenciar e gerar os sinais de batimento card\u00edaco e oximetria. static void task_aps2 ( void * pvParameters ) {...} Voc\u00eas n\u00e3o devem mexer nesta tarefa. ECG Tip Para ter acesso ao batimento card\u00edaco leia o valor anal\u00f3gico que sai do pino PB13 Range do dado: 0..4095 Fa\u00e7a a leitura anal\u00f3gica em uma frequ\u00eancia de 250Hz O electrocardiograma (ECG) ser\u00e1 um valor anal\u00f3gico gerado pelo pr\u00f3prio microcontrolador, uma tabela do pulso el\u00e9trico foi gerado usando o pacote neurokit2 , trado e exportado para um vetor ( aps2/ecg.h ). Tip Se tiver curiosidade de como o dado foi gerado consulte o jupyter notebook na pasta APS2 do reposit\u00f3rio da disciplina. O TC0 foi configurado para operar a 1kHz onde a cada interrup\u00e7\u00e3o gera no pino um novo dado referente ao batimento. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502afec \u2502\u25c4\u251c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 ecg \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 tc0 \u251c\u2500\u25ba\u2502dac \u251c\u2500x\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 PB13 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Tudo acontece na interrup\u00e7\u00e3o do TCO: void TC0_Handler ( void ) { ... ... dacc_write_conversion_data ( DACC_BASE , ecg [ ecgCnt ], DACC_CHANNEL ); } N\u00e3o utilizar o TC0 O TC0 est\u00e1 sendo utilizado para gerar os valores, ent\u00e3o n\u00e3o utilize-o Oximometria Tip Para ter acesso ao dado de oxiometria leia o dado na fila 'xQueueOx'. Range do dado: 88-99 Um dado a cada 2s A oxiometria \u00e9 gerada na tarefa task_aps2 de forma artificial o dado gerado \u00e9 enviado para a fila xQueueOx como um char. O valor gerado est\u00e1 dentro do range 85 .. 100 e \u00e9 enviada para uma fila a cada 1 segundo, inserimos erros artificialmente no dado, se o valor n\u00e3o estiver no range correto voc\u00eas devem desconsiderar. Rubrica A interface deve possuir identidade visual com o logo da empresa que escolheram, os recursos m\u00ednimos e extras do projeto est\u00e3o listados a seguir. Ao finalizar preencher Vai precisar gravar um v\u00eddeo. Loading\u2026 https://docs.google.com/forms/d/e/1FAIpQLSe4OIkTlMoCxRAMqoH082zfQ1ibnrcfldery7pKzva5hYCeKg/viewform?usp=sf_link C Deve exibir: Logo da empresa Valalor instant\u00e2neo da Oximetria Valor instant\u00e2neo do batimento card\u00edaco (bpm) Gr\u00e1fico batimento card\u00edaco Valor salvo de oxigena\u00e7\u00e3o/batimento Alarme caso o valor de oximetria abaixe de 90 Rel\u00f3gio (HH:MM) O usu\u00e1rio deve ser capaz de: Iniciar/Parar coleta de dados Salvar o valor em um instante de oxigena\u00e7\u00e3o e batimento Desligar alarme Extras Possibilita ajustar rel\u00f3gio Permite que o usu\u00e1rio escolha novo n\u00edvel de alarme para a oxigena\u00e7\u00e3o Possibilita alterar o gr\u00e1fico temporal entre oxigena\u00e7\u00e3o e batimento card\u00edaco Salva e exibir mais de um valor (hist\u00f3rico) Indica\u00e7\u00e3o visual da tend\u00eancia da oxigena\u00e7\u00e3o (seta, cor, ...). Anima\u00e7\u00f5es Modo simplificado: Aumenta fonte e mostra apenas valores instant\u00e2neos.","title":"APA 2 - Ox\u00edmetro"},{"location":"navigation/APS/APS-2-Oximetro/#apa-2-oximetro","text":"N\u00e3o estamos desenvolvendo um equipamento m\u00e9dico, mas sim um prot\u00f3tipo acad\u00eamico. Desenvolver um prot\u00f3tipo de um ox\u00edmetro, dispositivo m\u00e9dico para medir indiretamente a quantidade de oxig\u00eanio no sangue. O dispositivo ser\u00e1 composto por um display de LCD colorido sens\u00edvel ao toque (touchscreen), a interface com o usu\u00e1rio ser\u00e1 atrav\u00e9s do display. fonte: https://pt.wikipedia.org/wiki/Ox%C3%ADmetro_de_pulso Info Para come\u00e7ar crie o reposit\u00f3rio no classroom: https://classroom.github.com/g/Sp5pYx1p Voc\u00ea deve utilizar como base o c\u00f3digo dispon\u00edvel no reposit\u00f3rio!","title":"APA 2 - Ox\u00edmetro"},{"location":"navigation/APS/APS-2-Oximetro/#firmware","text":"O projeto deve ser desenvolvido usando um RTOS , no desenvolvimento devem isolar as tarefas de processamento de dados das de exibic\u00e3o (LCD). Info O freeRTOS n\u00e3o possui certifica\u00e7\u00e3o na FDA, neste caso dever\u00edamos optar por um RTOS que possui a aprovac\u00e3o, na maioria dos casos s\u00e3o sistemas com licen\u00e7a comercial, tal como: SafeRTOS vxworks O plano original era utilizar o sensor max30100 (incluso no kit de voc\u00eas), mas ap\u00f3s muito tempo tentando n\u00e3o conseguimos fazer o sensor funcionar com nossa placa, acreditamos que o mesmo veio com problema de hardware que impossibilitou o seu uso. Por conta disso iremos simular os dados que seriam lidos pelo sensor (oxigena\u00e7\u00e3o e batimento card\u00edaco). Os dados ser\u00e3o gerados como indicado a seguir.","title":"firmware"},{"location":"navigation/APS/APS-2-Oximetro/#task_aps2","text":"A task_aps2 \u00e9 a tarefa respons\u00e1vel gerenciar e gerar os sinais de batimento card\u00edaco e oximetria. static void task_aps2 ( void * pvParameters ) {...} Voc\u00eas n\u00e3o devem mexer nesta tarefa.","title":"task_aps2"},{"location":"navigation/APS/APS-2-Oximetro/#ecg","text":"Tip Para ter acesso ao batimento card\u00edaco leia o valor anal\u00f3gico que sai do pino PB13 Range do dado: 0..4095 Fa\u00e7a a leitura anal\u00f3gica em uma frequ\u00eancia de 250Hz O electrocardiograma (ECG) ser\u00e1 um valor anal\u00f3gico gerado pelo pr\u00f3prio microcontrolador, uma tabela do pulso el\u00e9trico foi gerado usando o pacote neurokit2 , trado e exportado para um vetor ( aps2/ecg.h ). Tip Se tiver curiosidade de como o dado foi gerado consulte o jupyter notebook na pasta APS2 do reposit\u00f3rio da disciplina. O TC0 foi configurado para operar a 1kHz onde a cada interrup\u00e7\u00e3o gera no pino um novo dado referente ao batimento. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502afec \u2502\u25c4\u251c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 ecg \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 tc0 \u251c\u2500\u25ba\u2502dac \u251c\u2500x\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 PB13 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Tudo acontece na interrup\u00e7\u00e3o do TCO: void TC0_Handler ( void ) { ... ... dacc_write_conversion_data ( DACC_BASE , ecg [ ecgCnt ], DACC_CHANNEL ); } N\u00e3o utilizar o TC0 O TC0 est\u00e1 sendo utilizado para gerar os valores, ent\u00e3o n\u00e3o utilize-o","title":"ECG"},{"location":"navigation/APS/APS-2-Oximetro/#oximometria","text":"Tip Para ter acesso ao dado de oxiometria leia o dado na fila 'xQueueOx'. Range do dado: 88-99 Um dado a cada 2s A oxiometria \u00e9 gerada na tarefa task_aps2 de forma artificial o dado gerado \u00e9 enviado para a fila xQueueOx como um char. O valor gerado est\u00e1 dentro do range 85 .. 100 e \u00e9 enviada para uma fila a cada 1 segundo, inserimos erros artificialmente no dado, se o valor n\u00e3o estiver no range correto voc\u00eas devem desconsiderar.","title":"Oximometria"},{"location":"navigation/APS/APS-2-Oximetro/#rubrica","text":"A interface deve possuir identidade visual com o logo da empresa que escolheram, os recursos m\u00ednimos e extras do projeto est\u00e3o listados a seguir. Ao finalizar preencher Vai precisar gravar um v\u00eddeo. Loading\u2026 https://docs.google.com/forms/d/e/1FAIpQLSe4OIkTlMoCxRAMqoH082zfQ1ibnrcfldery7pKzva5hYCeKg/viewform?usp=sf_link","title":"Rubrica"},{"location":"navigation/APS/APS-2-Oximetro/#c","text":"Deve exibir: Logo da empresa Valalor instant\u00e2neo da Oximetria Valor instant\u00e2neo do batimento card\u00edaco (bpm) Gr\u00e1fico batimento card\u00edaco Valor salvo de oxigena\u00e7\u00e3o/batimento Alarme caso o valor de oximetria abaixe de 90 Rel\u00f3gio (HH:MM) O usu\u00e1rio deve ser capaz de: Iniciar/Parar coleta de dados Salvar o valor em um instante de oxigena\u00e7\u00e3o e batimento Desligar alarme","title":"C"},{"location":"navigation/APS/APS-2-Oximetro/#extras","text":"Possibilita ajustar rel\u00f3gio Permite que o usu\u00e1rio escolha novo n\u00edvel de alarme para a oxigena\u00e7\u00e3o Possibilita alterar o gr\u00e1fico temporal entre oxigena\u00e7\u00e3o e batimento card\u00edaco Salva e exibir mais de um valor (hist\u00f3rico) Indica\u00e7\u00e3o visual da tend\u00eancia da oxigena\u00e7\u00e3o (seta, cor, ...). Anima\u00e7\u00f5es Modo simplificado: Aumenta fonte e mostra apenas valores instant\u00e2neos.","title":"Extras"},{"location":"navigation/APS/APS-3-IoT/","text":"APS 3 - IoT Fonte: https://www.flickr.com/photos/thinkgizmo/36802620122 Um sistema embarcado de coleta e transmiss\u00e3o de dados via Wi-Fi (data logger), ser\u00e1 utilizado o m\u00f3dulo WINC1500 como placa de rede Wi-Fi do nosso uC. Info Criar reposit\u00f3rio pelo classroom: https://classroom.github.com/g/XY1XxJiK Descri\u00e7\u00e3o Nessa APS voc\u00eas dever\u00e3o desenvolver um sistema embarcado e uma aplica\u00e7\u00e3o web que coleta alguns dados do mundo real e os envia para um servidor Web. Esse envio ser\u00e1 feito via uma conex\u00e3o Wi-Fi (m\u00f3dulo conectado no kit de desenvolvimento) e dever\u00e1 ser armazenado por um servidor desenvolvido por voc\u00eas e hospedado na Web. Os dados devem possuir timestamp (TS) e para que ele represente um valor condizente, o sistema embarcado deve sincronizar a hora com o servidor Web. Al\u00e9m do TS, deve ser poss\u00edvel identificar a origem dos dados (imaginando um sistema com N dispositivos). Info Posso usar o WIFI com o LCD? Eles compartilham alguns pinos da comunicac\u00e3o SPI, mas estamos trabalhando em solu\u00e7\u00e3o. Rubrica O prot\u00f3tipo deve possuir os recursos m\u00ednimos (C) e para cada item extra \u00e9 adiconado meio conceito. Voc\u00eas Devem gravar um v\u00eddeo demonstrando o funcionamento da APS (embarcado, servidor) funcionando. Info Ao finalizar preencher o forms a seguir: https://docs.google.com/forms/d/e/1FAIpQLSf8Y3ZrmyTn0DkS5bNTRbRQCQ6lBXUE6E-o3fF7_GXiyv5tVg/viewform C Coletar e enviar para um servidor: Um valor anal\u00f3gico externo a placa (1s) Um valor digital externo a placa (1s) Dados devem possuir Timestamp - TS (identifica\u0107\u00e3o de quando foram coletos DD:MM:YY/HH:MM:SS ) Dados devem possuir identificador de dispositivo - ID Embarcado deve sincronizar hora com Web exemplo j\u00e1 pega calend\u00e1rio e hora da web, precisa atualizar RTC com esses valores. Servidor hospedado em nuvem (aws, ...) Demonstrar com mais de um dispositivo funcionando ao mesmo tempo os dois integrantes executam ao mesmo tempo. extras Cada item a mais adiciona meio conceito na nota. ID da placa \u00e9 coletado automaticamente. Dica: que tal usar o mac address? Envio dos dados a cada 5 min dado anal\u00f3gico: continua coletando a cada 1s, mas s\u00f3 envia de 5 em 5 minutos objetivo disso \u00e9 poupar bateria. N\u00e3o perder dado se servidor n\u00e3o estiver dispon\u00edvel Caso n\u00e3o haja conex\u00e3o com internet manter dado salvo at\u00e9 link ativo novamente Seguran\u00e7a Usar HTTPS, certificado HW e certificado server Criptografar os dados com AES Formatar dado para envio com json Forma f\u00e1cil de configurar dispositivo em rede WIFI SDCARD/ UART/ _provision_mode (+1.0) Servidor hospedado em nuvem (aws, ...)** (+0.5) Demonstrar com mais de um dispositivo funcionando ao mesmo tempo os dois integrantes executam ao mesmo tempo.","title":"APS 3 - IoT"},{"location":"navigation/APS/APS-3-IoT/#aps-3-iot","text":"Fonte: https://www.flickr.com/photos/thinkgizmo/36802620122 Um sistema embarcado de coleta e transmiss\u00e3o de dados via Wi-Fi (data logger), ser\u00e1 utilizado o m\u00f3dulo WINC1500 como placa de rede Wi-Fi do nosso uC. Info Criar reposit\u00f3rio pelo classroom: https://classroom.github.com/g/XY1XxJiK","title":"APS 3 - IoT"},{"location":"navigation/APS/APS-3-IoT/#descricao","text":"Nessa APS voc\u00eas dever\u00e3o desenvolver um sistema embarcado e uma aplica\u00e7\u00e3o web que coleta alguns dados do mundo real e os envia para um servidor Web. Esse envio ser\u00e1 feito via uma conex\u00e3o Wi-Fi (m\u00f3dulo conectado no kit de desenvolvimento) e dever\u00e1 ser armazenado por um servidor desenvolvido por voc\u00eas e hospedado na Web. Os dados devem possuir timestamp (TS) e para que ele represente um valor condizente, o sistema embarcado deve sincronizar a hora com o servidor Web. Al\u00e9m do TS, deve ser poss\u00edvel identificar a origem dos dados (imaginando um sistema com N dispositivos). Info Posso usar o WIFI com o LCD? Eles compartilham alguns pinos da comunicac\u00e3o SPI, mas estamos trabalhando em solu\u00e7\u00e3o.","title":"Descri\u00e7\u00e3o"},{"location":"navigation/APS/APS-3-IoT/#rubrica","text":"O prot\u00f3tipo deve possuir os recursos m\u00ednimos (C) e para cada item extra \u00e9 adiconado meio conceito. Voc\u00eas Devem gravar um v\u00eddeo demonstrando o funcionamento da APS (embarcado, servidor) funcionando. Info Ao finalizar preencher o forms a seguir: https://docs.google.com/forms/d/e/1FAIpQLSf8Y3ZrmyTn0DkS5bNTRbRQCQ6lBXUE6E-o3fF7_GXiyv5tVg/viewform","title":"Rubrica"},{"location":"navigation/APS/APS-3-IoT/#c","text":"Coletar e enviar para um servidor: Um valor anal\u00f3gico externo a placa (1s) Um valor digital externo a placa (1s) Dados devem possuir Timestamp - TS (identifica\u0107\u00e3o de quando foram coletos DD:MM:YY/HH:MM:SS ) Dados devem possuir identificador de dispositivo - ID Embarcado deve sincronizar hora com Web exemplo j\u00e1 pega calend\u00e1rio e hora da web, precisa atualizar RTC com esses valores. Servidor hospedado em nuvem (aws, ...) Demonstrar com mais de um dispositivo funcionando ao mesmo tempo os dois integrantes executam ao mesmo tempo.","title":"C"},{"location":"navigation/APS/APS-3-IoT/#extras","text":"Cada item a mais adiciona meio conceito na nota. ID da placa \u00e9 coletado automaticamente. Dica: que tal usar o mac address? Envio dos dados a cada 5 min dado anal\u00f3gico: continua coletando a cada 1s, mas s\u00f3 envia de 5 em 5 minutos objetivo disso \u00e9 poupar bateria. N\u00e3o perder dado se servidor n\u00e3o estiver dispon\u00edvel Caso n\u00e3o haja conex\u00e3o com internet manter dado salvo at\u00e9 link ativo novamente Seguran\u00e7a Usar HTTPS, certificado HW e certificado server Criptografar os dados com AES Formatar dado para envio com json Forma f\u00e1cil de configurar dispositivo em rede WIFI SDCARD/ UART/ _provision_mode (+1.0) Servidor hospedado em nuvem (aws, ...)** (+0.5) Demonstrar com mais de um dispositivo funcionando ao mesmo tempo os dois integrantes executam ao mesmo tempo.","title":"extras"},{"location":"navigation/APS/APS-howto/","text":"HowTo Neste semestre iremos tentar uma nova forma de trabalho com as APS, a ideia \u00e9 guiar voc\u00eas e introduzir boas pr\u00e1ticas de desenvolvimento e gest\u00e3o do tempo, temos o objetivo de adicionar uma maneira de verificarmos contribui\u00e7\u00e3o individual nas entregas. Todas APS ser\u00e3o desenvolvidas em um reposit\u00f3rio do github, os reposit\u00f3rios ser\u00e3o criados pelo github classroom (acess\u00edvel por um link). Voc\u00eas devem clonar este reposit\u00f3rio e iniciar o desenvolvimento por ele. Info Muito importante que todos do grupo realizem commits no c\u00f3digo, caso contr\u00e1rio n\u00e3o iremos considerar a entrega de quem n\u00e3o participou Issues Os reposit\u00f3rios ser\u00e3o populados automaticamente (seu professor precisa executar um script local ) com issues que devem ser resolvidos pelo grupo, o grupo n\u00e3o deve fechar os issues quem ir\u00e1 fazer isso s\u00e3o os membros da equipe de avalia\u00e7\u00e3o (Corsi, Edu, Marco). Por\u00e9m voc\u00eas devem referenciar nos issues quando necessitarem avalia\u00e7\u00e3o dos mesmos. Exemplo de issue aberto automaticamente: Detalhe de um issue: Exemplo de como pedir feedback em um commit: Ap\u00f3s an\u00e1lise do c\u00f3digo pela equipe o issue ser\u00e1 encerrado.","title":"HowTo"},{"location":"navigation/APS/APS-howto/#howto","text":"Neste semestre iremos tentar uma nova forma de trabalho com as APS, a ideia \u00e9 guiar voc\u00eas e introduzir boas pr\u00e1ticas de desenvolvimento e gest\u00e3o do tempo, temos o objetivo de adicionar uma maneira de verificarmos contribui\u00e7\u00e3o individual nas entregas. Todas APS ser\u00e3o desenvolvidas em um reposit\u00f3rio do github, os reposit\u00f3rios ser\u00e3o criados pelo github classroom (acess\u00edvel por um link). Voc\u00eas devem clonar este reposit\u00f3rio e iniciar o desenvolvimento por ele. Info Muito importante que todos do grupo realizem commits no c\u00f3digo, caso contr\u00e1rio n\u00e3o iremos considerar a entrega de quem n\u00e3o participou","title":"HowTo"},{"location":"navigation/APS/APS-howto/#issues","text":"Os reposit\u00f3rios ser\u00e3o populados automaticamente (seu professor precisa executar um script local ) com issues que devem ser resolvidos pelo grupo, o grupo n\u00e3o deve fechar os issues quem ir\u00e1 fazer isso s\u00e3o os membros da equipe de avalia\u00e7\u00e3o (Corsi, Edu, Marco). Por\u00e9m voc\u00eas devem referenciar nos issues quando necessitarem avalia\u00e7\u00e3o dos mesmos. Exemplo de issue aberto automaticamente: Detalhe de um issue: Exemplo de como pedir feedback em um commit: Ap\u00f3s an\u00e1lise do c\u00f3digo pela equipe o issue ser\u00e1 encerrado.","title":"Issues"},{"location":"navigation/APS/rubrica/","text":"Rubrica Entrega Loading\u2026 https://docs.google.com/forms/d/e/1FAIpQLSenta6G-hpTRxkiJK5Am8Z7sVmNVlXiV2LNQ21sJZ_0Z1Fj-w/viewform?usp=sf_link Rubrica da APS2 A / B (Cada item, soma meio conceito a partir do C ) SleepMode: se n\u00e3o detectado um pulso em X tempo, desliga o LCD (pode pintar de preto). Toque ou pulsos 'acorda' interface Possui alguma anima\u00e7\u00e3o na tela Possui tema dark/light Calcula velocidade instant\u00e2nea por tempo entre dois pulsos e n\u00e3o por acumulo Exibe velocidade 0 se ficar sem pulsos por um tempo Possibilita ter mais de um 'percurso' Tip Alguma outra ideia? Mandem mensagem para eu verificar se vale... C Cumpre com os requisitos de design Exibe informa\u00e7\u00f5es reais de velocidade, dist\u00e2ncia e tempo simuladas pelo bot\u00e3o da placa. D N\u00e3o cumpre com at\u00e9 dois requisitos de design/ engenharia I","title":"Rubrica"},{"location":"navigation/APS/rubrica/#rubrica","text":"","title":"Rubrica"},{"location":"navigation/APS/rubrica/#entrega","text":"Loading\u2026 https://docs.google.com/forms/d/e/1FAIpQLSenta6G-hpTRxkiJK5Am8Z7sVmNVlXiV2LNQ21sJZ_0Z1Fj-w/viewform?usp=sf_link","title":"Entrega"},{"location":"navigation/APS/rubrica/#rubrica-da-aps2","text":"A / B (Cada item, soma meio conceito a partir do C ) SleepMode: se n\u00e3o detectado um pulso em X tempo, desliga o LCD (pode pintar de preto). Toque ou pulsos 'acorda' interface Possui alguma anima\u00e7\u00e3o na tela Possui tema dark/light Calcula velocidade instant\u00e2nea por tempo entre dois pulsos e n\u00e3o por acumulo Exibe velocidade 0 se ficar sem pulsos por um tempo Possibilita ter mais de um 'percurso' Tip Alguma outra ideia? Mandem mensagem para eu verificar se vale... C Cumpre com os requisitos de design Exibe informa\u00e7\u00f5es reais de velocidade, dist\u00e2ncia e tempo simuladas pelo bot\u00e3o da placa. D N\u00e3o cumpre com at\u00e9 dois requisitos de design/ engenharia I","title":"Rubrica da APS2"},{"location":"navigation/APS/APS-2-Bike/Descricao/","text":"Vis\u00e3o geral Note Entrega: Pode ser feita em dupla!! Deve entregar um v\u00eddeo da entrega funcionando. Direitos Todo c\u00f3digo / arte que for utilizado e que n\u00e3o for de autoria da dupla, deve ser referenciado no projeto. Conceito > C Para conceito maior que C, deve-se corrigir os issues que ser\u00e3o abertos ap\u00f3s a entrega no reposit\u00f3rio do grupo. Descri\u00e7\u00e3o O marketing de uma empresa de equipamentos esportivos quer criar um novo ciclocomputador e voc\u00ea foi escolhido como desenvolvedor aut\u00f4nomo, dado seu background t\u00e9cnico e de UX, para criar um prot\u00f3tipo e validar a ideia. Entregas Ser\u00e3o duas entregas: a especifica\u00e7\u00e3o da interface e a entrega de um prot\u00f3tipo. Especifica\u00e7\u00e3o da interface Devem apresentar uma proposta de interface que satisfa\u00e7a os requisitos do marketing. Prot\u00f3tipo A entrega final deve ser o prot\u00f3tipo funcional da solu\u00e7\u00e3o, e um v\u00eddeo de algu\u00e9m utilizando todas as funcionalidades do prot\u00f3tipo enquanto est\u00e1 pedalando na bicicleta (algu\u00e9m que n\u00e3o pertence ao grupo).","title":"Vis\u00e3o geral"},{"location":"navigation/APS/APS-2-Bike/Descricao/#visao-geral","text":"Note Entrega: Pode ser feita em dupla!! Deve entregar um v\u00eddeo da entrega funcionando. Direitos Todo c\u00f3digo / arte que for utilizado e que n\u00e3o for de autoria da dupla, deve ser referenciado no projeto. Conceito > C Para conceito maior que C, deve-se corrigir os issues que ser\u00e3o abertos ap\u00f3s a entrega no reposit\u00f3rio do grupo.","title":"Vis\u00e3o geral"},{"location":"navigation/APS/APS-2-Bike/Descricao/#descricao","text":"O marketing de uma empresa de equipamentos esportivos quer criar um novo ciclocomputador e voc\u00ea foi escolhido como desenvolvedor aut\u00f4nomo, dado seu background t\u00e9cnico e de UX, para criar um prot\u00f3tipo e validar a ideia.","title":"Descri\u00e7\u00e3o"},{"location":"navigation/APS/APS-2-Bike/Descricao/#entregas","text":"Ser\u00e3o duas entregas: a especifica\u00e7\u00e3o da interface e a entrega de um prot\u00f3tipo. Especifica\u00e7\u00e3o da interface Devem apresentar uma proposta de interface que satisfa\u00e7a os requisitos do marketing. Prot\u00f3tipo A entrega final deve ser o prot\u00f3tipo funcional da solu\u00e7\u00e3o, e um v\u00eddeo de algu\u00e9m utilizando todas as funcionalidades do prot\u00f3tipo enquanto est\u00e1 pedalando na bicicleta (algu\u00e9m que n\u00e3o pertence ao grupo).","title":"Entregas"},{"location":"navigation/APS/APS-2-Bike/Design/","text":"Entrega 1: Design Entrega Data Design interface 15/05 15 % da nota final Info Criar o reposit\u00f3rio pelo classroom : A entrega dessa etapa deve ser realizada no README do reposit\u00f3rio. A equipe de novos produtos disponibilizou alguns requisitos do prot\u00f3tipo e voc\u00eas devem propor uma interface que satisfaca as necessidades do projeto. Requisitos A seguir a lista de requisitos de usabilidade e de funcionalidades para o projeto do ciclocomputador. Usabilidade Requisitos de usabilidade do produto req. ux. 0 - Operac\u00e3o A interface a ser projetada deve ser tal que o usu\u00e1rio consigo operar com apenas uma m\u00e3o (lembre que \u00e9 algo para ser usado na bike) e que as informa\u00e7\u00f5es devem ser exibidas de forma clara, considerando uma leitura e opera\u00e7\u00e3o em movimento. req. ux. 1 - Hardware O hardware a ser utilizado ser\u00e1 o LCD de 240 x 320 px touch colorido. req. ux. 2 - Branding A interface deve ser alinhada com o logo e nome da empresa que voc\u00ea escolheu (blanding) req. ux. 3 - Exibir o logo O logotipo da empresa deve estar presente na interface. Funcionalidade O ciclocomputador ir\u00e1 exibir a velocidade instant\u00e2nea da bicicleta assim como um rel\u00f3gio. req. fun. 1 - Rel\u00f3gio Indica\u00e7\u00e3o da hora atual, no formato: HH:MM:SS atualizada a cada segundo. req. fun. 2 - Velocidade instant\u00e2nea Exibir a velocidade em km/h. req. fun. 3 - Indica\u00e7\u00e3o da acelera\u00e7\u00e3o Indica\u00e7\u00e3o visual da acelera\u00e7\u00e3o da bicicleta (positiva/ negativa ou constante). O ciclista deve ser capaz de iniciar a contagem de um trajeto, isso ir\u00e1 exibir para o usu\u00e1rio informa\u00e7\u00f5es referentes a dist\u00e2ncia, velocidade m\u00e9dia e tempo no trajeto. O usu\u00e1rio iniciar um trajeto (informa\u00e7\u00f5es s\u00e3o atualizadas), parar a contagem do trajeto (n\u00e3o atualiza mais as informa\u00e7\u00f5es) ou comecar um novo trajeto. req. fun. 4 - Trajeto: Dist\u00e2ncia Indica\u00e7\u00e3o em km da dist\u00e2ncia percorrida no trajeto. req. fun. 5 - Trajeto: Velocidade m\u00e9dia Indica\u00e7\u00e3o em km/h da velocidade m\u00e9dia no trajeto. req. fun. 6 - Trajeto: Cronometro Indica\u00e7\u00e3o em HH:MM do tempo gasto em um trajeto. req. fun. 7 - Trajeto: Controle Deve possibilitar o usu\u00e1rio iniciar, parar ou reiniciar a contagem de um trajeto. Quando o usu\u00e1rio parar um percurso deve exibir apenas a velocidade instant\u00e2nea e n\u00e3o deve atualizar outras informa\u00e7\u00f5es referentes ao percurso (velocidade m\u00e9dia/ dist\u00e2ncia no percurso/ tempo no percurso). req. fun. 8 - Trajeto: Indicador status A tela deve possuir um indicador se a contagem da parte referente ao percurso est\u00e1 ou n\u00e3o ativada. O ciclocomputador pode ser usado em diferentes tamanhos de bicicleta e o usu\u00e1rio deve poder configurar o raio de sua bicicleta. req. fun. 9 - Configurac\u00e3o Deve possibilitar o usu\u00e1rio configurar o di\u00e2metro da roda. Entrega Nota A entrega deve ser no README do reposit\u00f3rio criado, mas para ajudar voc\u00eas na idealiza\u00e7\u00e3o voc\u00eas devem usar o mural a seguir: https://app.mural.co/t/elementos9119/m/elementos9119/1652116252461/f773497a764ead5f57048cedf89780811768c460?sender=ub569a9273c6e285461187641 Nessa etapa de design voc\u00eas devem apresentar uma vers\u00e3o inicial da interface que deve satisfazer os requisitos listados anteriormente. Na interface ser\u00e1 necess\u00e1rio indicar qual widget do LVGL pretendem utilizar. Lembrem de consultar sempre a p\u00e1gina do LVGL para saber o que est\u00e1 dispon\u00edvel: https://docs.lvgl.io/latest/en/html/widgets/index.html Al\u00e9m do widget voc\u00eas devem informar qual \u00edcones pretendem usar na interface, consultem o site a seguir para ideias: https://thenounproject.com/term/open/ Exemplo O exemplo a seguir \u00e9 de uma interface de uma m\u00e1quina de lavar roupa, voc\u00eas devem entregar algo parecido. Info A interface de voc\u00eas pode possuir multiplas telas. Validando no LCD Antes de sairmos implementando a interface no LVGL iremos validar a proposta que voc\u00eas desenvolveram no LCD. Para isso iremos gerar um PNG da interface do mural e exibir no LCD como uma imagem est\u00e1tica. A ideia aqui \u00e9 apenas validar o conceito antes de gastarmos tempo programando algo que n\u00e3o ficou bom. Para isso voc\u00ea deve: Gerar uma imagem da interface fazendo screenshot da imagem do mural nas dimens\u00f5es: 240x320 Seguir o roteiro em util/LVGL para exibir a imagem no LCD: https://insper.github.io/ComputacaoEmbarcada/navigation/Dicas/Util-lvgl/#exibindo-uma-imagem Use como demo o c\u00f3digo do reposit\u00f3rio criado pelo classroom modificando a task_lcd para exibir a imagem. Info Importante gerar a imagem nas dimens\u00f5es 240x320 , queremos ocupar o LCD todo com nossa imagem. Rubrica Rubrica referente ao design da interface. As notas s\u00e3o incrementais. Por exemplo, Para atingir o B deve apresentar todos os itens do C, ou seja, os dois v\u00eddeos e as duas imagens! No mural voc\u00eas tamb\u00e9m devem manter as diferentes vers\u00f5es. A Especifica e justifica as cores a serem usadas na interface Pega feedback com mais uma pessoa externa e incorpora na interface Grava em v\u00eddeo a entrevista Grava um v\u00eddeo atualizado explicando o que foi sugerido e o que fizeram para melhorar a interface Apresentar uma foto da interface sendo executada no LCD (imagem est\u00e1tica) B Especifica e justifica quais v\u00e3o ser as fontes (e tamanhos) a serem usadas na interface. Pega feedback com o Luiz do Fablab e incorpora na interface Grava em v\u00eddeo a entrevista Grava um v\u00eddeo atualizado explicando o que foi sugerido e o que fizeram para melhorar a interface Apresentar uma foto da interface sendo executada no LCD (imagem est\u00e1tica) C Mockup da interface: Satisfaz todos os requisitos do projeto Indica quais s\u00e3o os widgets do LVGL Apresentar uma foto da interface sendo executada no LCD (imagem est\u00e1tica) Grava um v\u00eddeo explicando a interface","title":"Entrega 1: Design"},{"location":"navigation/APS/APS-2-Bike/Design/#entrega-1-design","text":"Entrega Data Design interface 15/05 15 % da nota final Info Criar o reposit\u00f3rio pelo classroom : A entrega dessa etapa deve ser realizada no README do reposit\u00f3rio. A equipe de novos produtos disponibilizou alguns requisitos do prot\u00f3tipo e voc\u00eas devem propor uma interface que satisfaca as necessidades do projeto.","title":"Entrega 1: Design"},{"location":"navigation/APS/APS-2-Bike/Design/#requisitos","text":"A seguir a lista de requisitos de usabilidade e de funcionalidades para o projeto do ciclocomputador.","title":"Requisitos"},{"location":"navigation/APS/APS-2-Bike/Design/#usabilidade","text":"Requisitos de usabilidade do produto req. ux. 0 - Operac\u00e3o A interface a ser projetada deve ser tal que o usu\u00e1rio consigo operar com apenas uma m\u00e3o (lembre que \u00e9 algo para ser usado na bike) e que as informa\u00e7\u00f5es devem ser exibidas de forma clara, considerando uma leitura e opera\u00e7\u00e3o em movimento. req. ux. 1 - Hardware O hardware a ser utilizado ser\u00e1 o LCD de 240 x 320 px touch colorido. req. ux. 2 - Branding A interface deve ser alinhada com o logo e nome da empresa que voc\u00ea escolheu (blanding) req. ux. 3 - Exibir o logo O logotipo da empresa deve estar presente na interface.","title":"Usabilidade"},{"location":"navigation/APS/APS-2-Bike/Design/#funcionalidade","text":"O ciclocomputador ir\u00e1 exibir a velocidade instant\u00e2nea da bicicleta assim como um rel\u00f3gio. req. fun. 1 - Rel\u00f3gio Indica\u00e7\u00e3o da hora atual, no formato: HH:MM:SS atualizada a cada segundo. req. fun. 2 - Velocidade instant\u00e2nea Exibir a velocidade em km/h. req. fun. 3 - Indica\u00e7\u00e3o da acelera\u00e7\u00e3o Indica\u00e7\u00e3o visual da acelera\u00e7\u00e3o da bicicleta (positiva/ negativa ou constante). O ciclista deve ser capaz de iniciar a contagem de um trajeto, isso ir\u00e1 exibir para o usu\u00e1rio informa\u00e7\u00f5es referentes a dist\u00e2ncia, velocidade m\u00e9dia e tempo no trajeto. O usu\u00e1rio iniciar um trajeto (informa\u00e7\u00f5es s\u00e3o atualizadas), parar a contagem do trajeto (n\u00e3o atualiza mais as informa\u00e7\u00f5es) ou comecar um novo trajeto. req. fun. 4 - Trajeto: Dist\u00e2ncia Indica\u00e7\u00e3o em km da dist\u00e2ncia percorrida no trajeto. req. fun. 5 - Trajeto: Velocidade m\u00e9dia Indica\u00e7\u00e3o em km/h da velocidade m\u00e9dia no trajeto. req. fun. 6 - Trajeto: Cronometro Indica\u00e7\u00e3o em HH:MM do tempo gasto em um trajeto. req. fun. 7 - Trajeto: Controle Deve possibilitar o usu\u00e1rio iniciar, parar ou reiniciar a contagem de um trajeto. Quando o usu\u00e1rio parar um percurso deve exibir apenas a velocidade instant\u00e2nea e n\u00e3o deve atualizar outras informa\u00e7\u00f5es referentes ao percurso (velocidade m\u00e9dia/ dist\u00e2ncia no percurso/ tempo no percurso). req. fun. 8 - Trajeto: Indicador status A tela deve possuir um indicador se a contagem da parte referente ao percurso est\u00e1 ou n\u00e3o ativada. O ciclocomputador pode ser usado em diferentes tamanhos de bicicleta e o usu\u00e1rio deve poder configurar o raio de sua bicicleta. req. fun. 9 - Configurac\u00e3o Deve possibilitar o usu\u00e1rio configurar o di\u00e2metro da roda.","title":"Funcionalidade"},{"location":"navigation/APS/APS-2-Bike/Design/#entrega","text":"Nota A entrega deve ser no README do reposit\u00f3rio criado, mas para ajudar voc\u00eas na idealiza\u00e7\u00e3o voc\u00eas devem usar o mural a seguir: https://app.mural.co/t/elementos9119/m/elementos9119/1652116252461/f773497a764ead5f57048cedf89780811768c460?sender=ub569a9273c6e285461187641 Nessa etapa de design voc\u00eas devem apresentar uma vers\u00e3o inicial da interface que deve satisfazer os requisitos listados anteriormente. Na interface ser\u00e1 necess\u00e1rio indicar qual widget do LVGL pretendem utilizar. Lembrem de consultar sempre a p\u00e1gina do LVGL para saber o que est\u00e1 dispon\u00edvel: https://docs.lvgl.io/latest/en/html/widgets/index.html Al\u00e9m do widget voc\u00eas devem informar qual \u00edcones pretendem usar na interface, consultem o site a seguir para ideias: https://thenounproject.com/term/open/","title":"Entrega"},{"location":"navigation/APS/APS-2-Bike/Design/#exemplo","text":"O exemplo a seguir \u00e9 de uma interface de uma m\u00e1quina de lavar roupa, voc\u00eas devem entregar algo parecido. Info A interface de voc\u00eas pode possuir multiplas telas.","title":"Exemplo"},{"location":"navigation/APS/APS-2-Bike/Design/#validando-no-lcd","text":"Antes de sairmos implementando a interface no LVGL iremos validar a proposta que voc\u00eas desenvolveram no LCD. Para isso iremos gerar um PNG da interface do mural e exibir no LCD como uma imagem est\u00e1tica. A ideia aqui \u00e9 apenas validar o conceito antes de gastarmos tempo programando algo que n\u00e3o ficou bom. Para isso voc\u00ea deve: Gerar uma imagem da interface fazendo screenshot da imagem do mural nas dimens\u00f5es: 240x320 Seguir o roteiro em util/LVGL para exibir a imagem no LCD: https://insper.github.io/ComputacaoEmbarcada/navigation/Dicas/Util-lvgl/#exibindo-uma-imagem Use como demo o c\u00f3digo do reposit\u00f3rio criado pelo classroom modificando a task_lcd para exibir a imagem. Info Importante gerar a imagem nas dimens\u00f5es 240x320 , queremos ocupar o LCD todo com nossa imagem.","title":"Validando no LCD"},{"location":"navigation/APS/APS-2-Bike/Design/#rubrica","text":"Rubrica referente ao design da interface. As notas s\u00e3o incrementais. Por exemplo, Para atingir o B deve apresentar todos os itens do C, ou seja, os dois v\u00eddeos e as duas imagens! No mural voc\u00eas tamb\u00e9m devem manter as diferentes vers\u00f5es.","title":"Rubrica"},{"location":"navigation/APS/APS-2-Bike/Design/#a","text":"Especifica e justifica as cores a serem usadas na interface Pega feedback com mais uma pessoa externa e incorpora na interface Grava em v\u00eddeo a entrevista Grava um v\u00eddeo atualizado explicando o que foi sugerido e o que fizeram para melhorar a interface Apresentar uma foto da interface sendo executada no LCD (imagem est\u00e1tica)","title":"A"},{"location":"navigation/APS/APS-2-Bike/Design/#b","text":"Especifica e justifica quais v\u00e3o ser as fontes (e tamanhos) a serem usadas na interface. Pega feedback com o Luiz do Fablab e incorpora na interface Grava em v\u00eddeo a entrevista Grava um v\u00eddeo atualizado explicando o que foi sugerido e o que fizeram para melhorar a interface Apresentar uma foto da interface sendo executada no LCD (imagem est\u00e1tica)","title":"B"},{"location":"navigation/APS/APS-2-Bike/Design/#c","text":"Mockup da interface: Satisfaz todos os requisitos do projeto Indica quais s\u00e3o os widgets do LVGL Apresentar uma foto da interface sendo executada no LCD (imagem est\u00e1tica) Grava um v\u00eddeo explicando a interface","title":"C"},{"location":"navigation/APS/APS-2-Bike/Engenharia/","text":"Entrega 2: Engenharia Al\u00e9m do design com o usu\u00e1rio, voc\u00ea deve ter os seguintes cuidados com a engenharia do prot\u00f3tipo. Info Entregar pelo forms: Carregando\u2026 Sobre a bicicleta Iremos validar o projeto em uma bicicleta modelo Tilt 100 que compramos para essa finalidade. Na bicicleta n\u00f3s plugamos uma placa e um LCD, e tamb\u00e9m colocamos um sensor magn\u00e9tico na roda junto com um Im\u00e3 (para detectar rotac\u00e3o). Bike Diagrama Info O raio da nossa bicicleta \u00e9 20\" Voc\u00ea deve assumir as conex\u00f5es a seguir no seu projeto: Item Conex\u00e3o LCD EXT-2 Sensor magn\u00e9tico EXT-1 PA19 LED R ? LED G ? LED B ? A seguir detalhes sobre cada um dos dispositivos da bicicleta. Sensor magn\u00e9tico O sensor magn\u00e9tico gera um pulso el\u00e9trico (em LOW) sempre que a roda fizer uma rotac\u00e3o completa, voc\u00ea deve tratar esse pulso como um sinal digital. Considere que o sensor foi ligado no pino PA19 do EXT-1 . Diagrama da montagem: Info Quando for configurar o pino para realizar a leitura do sensor DESABILITAR o PULL_UP. Configurar IRQ em borda de descida. Medi\u00e7\u00f5es A seguir detalhes de como podem ser realizadas a medi\u00e7\u00f5es necess\u00e1rias ao projeto: Velocidade instant\u00e2nea Ser\u00e1 necess\u00e1rio realizar a leitura da velocidade da bicicleta, existem algumas solu\u00e7\u00f5es que podem ser utilizadas: A velocidade da bicicleta (v) \u00e9 decorrente da velocidade angular (w) de sua roda, sendo calculado por: v = w*r [m/s] . Existem duas maneiras de se calcular a velocidade angular: mede-se o tempo ( t ) entre dois pulsos e a partir da frequ\u00eancia ( f=1/t ) calcula-se w = 2*pi*f [rad/s] acumula-se pulsos ( N ) em um determinado tempo ( dT ): w = 2*pi*N/dT Como s\u00f3 conseguimos medir um pulso por rota\u00e7\u00e3o, \u00e9 necess\u00e1rio que esse dT seja: suficiente alto para medirmos uma velocidade relativamente baixa, mas n\u00e3o pode ser t\u00e3o elevado, caso contr\u00e1rio teremos uma taxa de atualiza\u00e7\u00e3o da velocidade muito lenta. Note Nesses dois casos n\u00e3o podemos utilizar o TC para medirmos a frequ\u00eancia ( f ) ou gerar o dT pois a menor frequ\u00eancia na qual o TC operar/medir \u00e9 de 0.5Hz (o que daria uma velocidade m\u00ednima de 3.3Km/h). Vamos usar um novo perif\u00e9rico chamado de RTT (detalhes a seguir) Indica\u00e7\u00e3o de acelera\u00e7\u00e3o \u00c9 a derivada da velocidade, se positiva indica que a bicicleta est\u00e1 ganhando velocidade, negativa perdendo e pr\u00f3xima a zero a velocidade est\u00e1 est\u00e1vel. Para derivarmos a velocidade de forma discreta, utilizamos a equa\u00e7\u00e3o a seguir: a(t) = K * (x[N] - x[N-1])/Ts onde: a(t) : \u00e9 a acelera\u00e7\u00e3o instant\u00e2nea K : constante opcional (ganho) x[N] : valor da velocidade atual x[N-1] : valor da velocidade no instante passado Ts : Per\u00edodo de amostragem Com essa informa\u00e7\u00e3o, voc\u00ea ser\u00e1 capaz de indicar na interface a indica\u00e7\u00e3o de acelera\u00e7\u00e3o. Velocidade m\u00e9dia Pode ser calculada por quantas revolu\u00e7\u00f5es a roda deu em um determinado delta de tempo: vm = Pulsos/dT dT deve ser o valor na qual voc\u00ea deseja atualizar a informa\u00e7\u00e3o de velocidade m\u00e9dia. Dist\u00e2ncia A dist\u00e2ncia ( d ) percorrida pela bicicleta \u00e9: d = 2*pi*r*N [m] . Testando Para facilitar o teste da leitura do pulso eu escrevi um c\u00f3digo que gera um pulso no pino PC31 (EXT1) e que simula os pulsos para uma velocidade fixa de 5km/h. O c\u00f3digo tamb\u00e9m \u00e9 capaz de ficar variando a velocidade em uma rampa, para isso basta descomentar a linha que possui o #define RAMP . Notem que estou gerando os pulsos com uma task do rtos, isso n\u00e3o garante uma boa precis\u00e3o e pode gerar um pouco de varia\u00e7\u00e3o na leitura da velocidade. C\u00f3digo #include \"arm_math.h\" #define TASK_SIMULATOR_STACK_SIZE (4096 / sizeof(portSTACK_TYPE)) #define TASK_SIMULATOR_STACK_PRIORITY (tskIDLE_PRIORITY) #define RAIO 0.508/2 #define VEL_MAX_KMH 5.0f #define VEL_MIN_KMH 0.5f //#define RAMP /** * raio 20\" => 50,8 cm (diametro) => 0.508/2 = 0.254m (raio) * w = 2 pi f (m/s) * v [km/h] = (w*r) / 3.6 = (2 pi f r) / 3.6 * f = v / (2 pi r 3.6) * Exemplo : 5 km / h = 1.38 m/s * f = 0.87Hz * t = 1/f => 1/0.87 = 1,149s */ float kmh_to_hz ( float vel , float raio ) { float f = vel / ( 2 * PI * raio * 3.6 ); return ( f ); } static void task_simulador ( void * pvParameters ) { pmc_enable_periph_clk ( ID_PIOC ); pio_set_output ( PIOC , PIO_PC31 , 1 , 0 , 0 ); float vel = VEL_MAX_KMH ; float f ; int ramp_up = 1 ; while ( 1 ){ pio_clear ( PIOC , PIO_PC31 ); delay_ms ( 1 ); pio_set ( PIOC , PIO_PC31 ); #ifdef RAMP if ( ramp_up ) { printf ( \"[SIMU] ACELERANDO: %d \\n \" , ( int ) ( 10 * vel )); vel += 0.5 ; } else { printf ( \"[SIMU] DESACELERANDO: %d \\n \" , ( int ) ( 10 * vel )); vel -= 0.5 ; } if ( vel >= VEL_MAX_KMH ) ramp_up = 0 ; else if ( vel <= VEL_MIN_KMH ) ramp_up = 1 ; #ifndef RAMP vel = 5 ; printf ( \"[SIMU] CONSTANTE: %d \\n \" , ( int ) ( 10 * vel )); #endif f = kmh_to_hz ( vel , RAIO ); int t = 965 * ( 1.0 / f ); //UTILIZADO 965 como multiplicador ao inv\u00e9s de 1000 //para compensar o atraso gerado pelo Escalonador do freeRTOS delay_ms ( t ); } } int main ( void ) { // ... // .... if ( xTaskCreate ( task_simulador , \"SIMUL\" , TASK_SIMULATOR_STACK_SIZE , NULL , TASK_SIMULATOR_STACK_PRIORITY , NULL ) != pdPASS ) { printf ( \"Failed to create lcd task \\r\\n \" ); } Interface Nesta etapa voc\u00eas devem tamb\u00e9m implementar a interface que foi proposta na entrega de design, uma dica \u00e9 a deixar a imagem desenhada no LCD e ent\u00e3o ir construindo a interface o LVGL por cima. O LVGL trabalha com camadas e os widgets mais novos s\u00e3o alocados no topo: https://docs.lvgl.io/master/overview/layer.html By default, LVGL draws new objects on top of old objects. Rubrica A seguir um resumo dos requisitos e da rubrica da entrega associada a eles. Lembrem que voc\u00eas devem utilizar os recursos do freeRTOS sempre que poss\u00edvel. Info A interface desenvolvida deve ser similar a interface prototipada, mesmo se voc\u00ea n\u00e3o for implementar alguns dos requisitos (pode apenas omitir eles da interface). Qualidade de software? Consulte a p\u00e1gina com regras de firmware: https://insper.github.io/ComputacaoEmbarcada/navigation/Dicas/Util-o-que-nao-pode/ Rubrica UX req. ux. 1 - Operac\u00e3o A interface a ser projetada deve ser tal que o usu\u00e1rio consigo operar com apenas uma m\u00e3o (lembre que \u00e9 algo para ser usado na bike) e que as informa\u00e7\u00f5es devem ser exibidas de forma clara, considerando uma leitura e opera\u00e7\u00e3o em movimento. C req. ux. 2 - Hardware O hardware a ser utilizado ser\u00e1 o LCD de 240x320px touch colorido. C req. ux. 3 - Exibir o logo O logotipo da empresa deve estar presente na interface. C req. ux. 4 - Branding A interface deve ser alinhada com o logo e nome da empresa que voc\u00ea escolheu (blanding) B Rubrica Funcional req. fun. 1 - Rel\u00f3gio Indica\u00e7\u00e3o da hora atual, no formato: HH:MM:SS atualizada a cada segundo. C req. fun. 2 - Velocidade instant\u00e2nea Exibir a velocidade em km/h. C req. fun. 3 - Indica\u00e7\u00e3o da acelera\u00e7\u00e3o Indica\u00e7\u00e3o visual da acelera\u00e7\u00e3o da bicicleta (positiva/ negativa ou constante). C req. fun. 4 - Trajeto: Dist\u00e2ncia Indica\u00e7\u00e3o em km da dist\u00e2ncia percorrida no trajeto. B req. fun. 5 - Trajeto: Velocidade m\u00e9dia Indica\u00e7\u00e3o em km/h da velocidade m\u00e9dia no trajeto. B req. fun. 6 - Trajeto: Cronometro Indica\u00e7\u00e3o em HH:MM do tempo gasto em um trajeto. B req. fun. 7 - Trajeto: Controle Deve possibilitar o usu\u00e1rio iniciar, parar ou reiniciar a contagem de um trajeto. B req. fun. 8 - Trajeto: Indicador status A tela deve possuir um indicador se a contagem da parte referente ao percurso est\u00e1 ou n\u00e3o ativada. B req. fun. 9 - Configurac\u00e3o Deve possibilitar o usu\u00e1rio configurar o di\u00e2metro da roda. A Rubrica extra req. extra. 1 - Extra Adicionar alguma coisa diferente na bicicleta, aqui voc\u00ea deve deixar a imagina\u00e7\u00e3o voar!! B","title":"Entrega 2: Engenharia"},{"location":"navigation/APS/APS-2-Bike/Engenharia/#entrega-2-engenharia","text":"Al\u00e9m do design com o usu\u00e1rio, voc\u00ea deve ter os seguintes cuidados com a engenharia do prot\u00f3tipo. Info Entregar pelo forms: Carregando\u2026","title":"Entrega 2: Engenharia"},{"location":"navigation/APS/APS-2-Bike/Engenharia/#sobre-a-bicicleta","text":"Iremos validar o projeto em uma bicicleta modelo Tilt 100 que compramos para essa finalidade. Na bicicleta n\u00f3s plugamos uma placa e um LCD, e tamb\u00e9m colocamos um sensor magn\u00e9tico na roda junto com um Im\u00e3 (para detectar rotac\u00e3o). Bike Diagrama Info O raio da nossa bicicleta \u00e9 20\" Voc\u00ea deve assumir as conex\u00f5es a seguir no seu projeto: Item Conex\u00e3o LCD EXT-2 Sensor magn\u00e9tico EXT-1 PA19 LED R ? LED G ? LED B ? A seguir detalhes sobre cada um dos dispositivos da bicicleta.","title":"Sobre a bicicleta"},{"location":"navigation/APS/APS-2-Bike/Engenharia/#sensor-magnetico","text":"O sensor magn\u00e9tico gera um pulso el\u00e9trico (em LOW) sempre que a roda fizer uma rotac\u00e3o completa, voc\u00ea deve tratar esse pulso como um sinal digital. Considere que o sensor foi ligado no pino PA19 do EXT-1 . Diagrama da montagem: Info Quando for configurar o pino para realizar a leitura do sensor DESABILITAR o PULL_UP. Configurar IRQ em borda de descida.","title":"Sensor magn\u00e9tico"},{"location":"navigation/APS/APS-2-Bike/Engenharia/#medicoes","text":"A seguir detalhes de como podem ser realizadas a medi\u00e7\u00f5es necess\u00e1rias ao projeto:","title":"Medi\u00e7\u00f5es"},{"location":"navigation/APS/APS-2-Bike/Engenharia/#velocidade-instantanea","text":"Ser\u00e1 necess\u00e1rio realizar a leitura da velocidade da bicicleta, existem algumas solu\u00e7\u00f5es que podem ser utilizadas: A velocidade da bicicleta (v) \u00e9 decorrente da velocidade angular (w) de sua roda, sendo calculado por: v = w*r [m/s] . Existem duas maneiras de se calcular a velocidade angular: mede-se o tempo ( t ) entre dois pulsos e a partir da frequ\u00eancia ( f=1/t ) calcula-se w = 2*pi*f [rad/s] acumula-se pulsos ( N ) em um determinado tempo ( dT ): w = 2*pi*N/dT Como s\u00f3 conseguimos medir um pulso por rota\u00e7\u00e3o, \u00e9 necess\u00e1rio que esse dT seja: suficiente alto para medirmos uma velocidade relativamente baixa, mas n\u00e3o pode ser t\u00e3o elevado, caso contr\u00e1rio teremos uma taxa de atualiza\u00e7\u00e3o da velocidade muito lenta. Note Nesses dois casos n\u00e3o podemos utilizar o TC para medirmos a frequ\u00eancia ( f ) ou gerar o dT pois a menor frequ\u00eancia na qual o TC operar/medir \u00e9 de 0.5Hz (o que daria uma velocidade m\u00ednima de 3.3Km/h). Vamos usar um novo perif\u00e9rico chamado de RTT (detalhes a seguir)","title":"Velocidade instant\u00e2nea"},{"location":"navigation/APS/APS-2-Bike/Engenharia/#indicacao-de-aceleracao","text":"\u00c9 a derivada da velocidade, se positiva indica que a bicicleta est\u00e1 ganhando velocidade, negativa perdendo e pr\u00f3xima a zero a velocidade est\u00e1 est\u00e1vel. Para derivarmos a velocidade de forma discreta, utilizamos a equa\u00e7\u00e3o a seguir: a(t) = K * (x[N] - x[N-1])/Ts onde: a(t) : \u00e9 a acelera\u00e7\u00e3o instant\u00e2nea K : constante opcional (ganho) x[N] : valor da velocidade atual x[N-1] : valor da velocidade no instante passado Ts : Per\u00edodo de amostragem Com essa informa\u00e7\u00e3o, voc\u00ea ser\u00e1 capaz de indicar na interface a indica\u00e7\u00e3o de acelera\u00e7\u00e3o.","title":"Indica\u00e7\u00e3o de acelera\u00e7\u00e3o"},{"location":"navigation/APS/APS-2-Bike/Engenharia/#velocidade-media","text":"Pode ser calculada por quantas revolu\u00e7\u00f5es a roda deu em um determinado delta de tempo: vm = Pulsos/dT dT deve ser o valor na qual voc\u00ea deseja atualizar a informa\u00e7\u00e3o de velocidade m\u00e9dia.","title":"Velocidade m\u00e9dia"},{"location":"navigation/APS/APS-2-Bike/Engenharia/#distancia","text":"A dist\u00e2ncia ( d ) percorrida pela bicicleta \u00e9: d = 2*pi*r*N [m] .","title":"Dist\u00e2ncia"},{"location":"navigation/APS/APS-2-Bike/Engenharia/#testando","text":"Para facilitar o teste da leitura do pulso eu escrevi um c\u00f3digo que gera um pulso no pino PC31 (EXT1) e que simula os pulsos para uma velocidade fixa de 5km/h. O c\u00f3digo tamb\u00e9m \u00e9 capaz de ficar variando a velocidade em uma rampa, para isso basta descomentar a linha que possui o #define RAMP . Notem que estou gerando os pulsos com uma task do rtos, isso n\u00e3o garante uma boa precis\u00e3o e pode gerar um pouco de varia\u00e7\u00e3o na leitura da velocidade. C\u00f3digo #include \"arm_math.h\" #define TASK_SIMULATOR_STACK_SIZE (4096 / sizeof(portSTACK_TYPE)) #define TASK_SIMULATOR_STACK_PRIORITY (tskIDLE_PRIORITY) #define RAIO 0.508/2 #define VEL_MAX_KMH 5.0f #define VEL_MIN_KMH 0.5f //#define RAMP /** * raio 20\" => 50,8 cm (diametro) => 0.508/2 = 0.254m (raio) * w = 2 pi f (m/s) * v [km/h] = (w*r) / 3.6 = (2 pi f r) / 3.6 * f = v / (2 pi r 3.6) * Exemplo : 5 km / h = 1.38 m/s * f = 0.87Hz * t = 1/f => 1/0.87 = 1,149s */ float kmh_to_hz ( float vel , float raio ) { float f = vel / ( 2 * PI * raio * 3.6 ); return ( f ); } static void task_simulador ( void * pvParameters ) { pmc_enable_periph_clk ( ID_PIOC ); pio_set_output ( PIOC , PIO_PC31 , 1 , 0 , 0 ); float vel = VEL_MAX_KMH ; float f ; int ramp_up = 1 ; while ( 1 ){ pio_clear ( PIOC , PIO_PC31 ); delay_ms ( 1 ); pio_set ( PIOC , PIO_PC31 ); #ifdef RAMP if ( ramp_up ) { printf ( \"[SIMU] ACELERANDO: %d \\n \" , ( int ) ( 10 * vel )); vel += 0.5 ; } else { printf ( \"[SIMU] DESACELERANDO: %d \\n \" , ( int ) ( 10 * vel )); vel -= 0.5 ; } if ( vel >= VEL_MAX_KMH ) ramp_up = 0 ; else if ( vel <= VEL_MIN_KMH ) ramp_up = 1 ; #ifndef RAMP vel = 5 ; printf ( \"[SIMU] CONSTANTE: %d \\n \" , ( int ) ( 10 * vel )); #endif f = kmh_to_hz ( vel , RAIO ); int t = 965 * ( 1.0 / f ); //UTILIZADO 965 como multiplicador ao inv\u00e9s de 1000 //para compensar o atraso gerado pelo Escalonador do freeRTOS delay_ms ( t ); } } int main ( void ) { // ... // .... if ( xTaskCreate ( task_simulador , \"SIMUL\" , TASK_SIMULATOR_STACK_SIZE , NULL , TASK_SIMULATOR_STACK_PRIORITY , NULL ) != pdPASS ) { printf ( \"Failed to create lcd task \\r\\n \" ); }","title":"Testando"},{"location":"navigation/APS/APS-2-Bike/Engenharia/#interface","text":"Nesta etapa voc\u00eas devem tamb\u00e9m implementar a interface que foi proposta na entrega de design, uma dica \u00e9 a deixar a imagem desenhada no LCD e ent\u00e3o ir construindo a interface o LVGL por cima. O LVGL trabalha com camadas e os widgets mais novos s\u00e3o alocados no topo: https://docs.lvgl.io/master/overview/layer.html By default, LVGL draws new objects on top of old objects.","title":"Interface"},{"location":"navigation/APS/APS-2-Bike/Engenharia/#rubrica","text":"A seguir um resumo dos requisitos e da rubrica da entrega associada a eles. Lembrem que voc\u00eas devem utilizar os recursos do freeRTOS sempre que poss\u00edvel. Info A interface desenvolvida deve ser similar a interface prototipada, mesmo se voc\u00ea n\u00e3o for implementar alguns dos requisitos (pode apenas omitir eles da interface). Qualidade de software? Consulte a p\u00e1gina com regras de firmware: https://insper.github.io/ComputacaoEmbarcada/navigation/Dicas/Util-o-que-nao-pode/ Rubrica UX req. ux. 1 - Operac\u00e3o A interface a ser projetada deve ser tal que o usu\u00e1rio consigo operar com apenas uma m\u00e3o (lembre que \u00e9 algo para ser usado na bike) e que as informa\u00e7\u00f5es devem ser exibidas de forma clara, considerando uma leitura e opera\u00e7\u00e3o em movimento. C req. ux. 2 - Hardware O hardware a ser utilizado ser\u00e1 o LCD de 240x320px touch colorido. C req. ux. 3 - Exibir o logo O logotipo da empresa deve estar presente na interface. C req. ux. 4 - Branding A interface deve ser alinhada com o logo e nome da empresa que voc\u00ea escolheu (blanding) B Rubrica Funcional req. fun. 1 - Rel\u00f3gio Indica\u00e7\u00e3o da hora atual, no formato: HH:MM:SS atualizada a cada segundo. C req. fun. 2 - Velocidade instant\u00e2nea Exibir a velocidade em km/h. C req. fun. 3 - Indica\u00e7\u00e3o da acelera\u00e7\u00e3o Indica\u00e7\u00e3o visual da acelera\u00e7\u00e3o da bicicleta (positiva/ negativa ou constante). C req. fun. 4 - Trajeto: Dist\u00e2ncia Indica\u00e7\u00e3o em km da dist\u00e2ncia percorrida no trajeto. B req. fun. 5 - Trajeto: Velocidade m\u00e9dia Indica\u00e7\u00e3o em km/h da velocidade m\u00e9dia no trajeto. B req. fun. 6 - Trajeto: Cronometro Indica\u00e7\u00e3o em HH:MM do tempo gasto em um trajeto. B req. fun. 7 - Trajeto: Controle Deve possibilitar o usu\u00e1rio iniciar, parar ou reiniciar a contagem de um trajeto. B req. fun. 8 - Trajeto: Indicador status A tela deve possuir um indicador se a contagem da parte referente ao percurso est\u00e1 ou n\u00e3o ativada. B req. fun. 9 - Configurac\u00e3o Deve possibilitar o usu\u00e1rio configurar o di\u00e2metro da roda. A Rubrica extra req. extra. 1 - Extra Adicionar alguma coisa diferente na bicicleta, aqui voc\u00ea deve deixar a imagina\u00e7\u00e3o voar!! B","title":"Rubrica"},{"location":"navigation/APS/APS-2-Bike/Rubrica/","text":"Rubrica Conceito > C Para conceito maior que C deve-se corrigir os issues que ser\u00e3o abertos ap\u00f3s a entrega no reposit\u00f3rio do grupo. Design Rubrica referente ao design da interface. A Pega feedback com duas pessoas externa e incorpora na interface Grava em \u00e1udio as entrevistas Grava um v\u00eddeo atualizado explicando o que foi sugerido e o que fizeram para melhorar a interface B Pega feedback com o Luiz do Fablab e incorpora na interface. Grava um v\u00eddeo atualizado explicando o que foi sugerido e o que fizeram para melhorar a interface. C Mockup da interface: Entrega um prot\u00f3tipo da interface Indica quais s\u00e3o os widgets do LVGL Indica quais s\u00e3o as fontes (nome e tamanho) Grava um v\u00eddeo explicando a interface Todos do grupo devem aparecer no v\u00eddeo (pode ser em call) Firmware A B C","title":"Rubrica"},{"location":"navigation/APS/APS-2-Bike/Rubrica/#rubrica","text":"Conceito > C Para conceito maior que C deve-se corrigir os issues que ser\u00e3o abertos ap\u00f3s a entrega no reposit\u00f3rio do grupo.","title":"Rubrica"},{"location":"navigation/APS/APS-2-Bike/Rubrica/#design","text":"Rubrica referente ao design da interface.","title":"Design"},{"location":"navigation/APS/APS-2-Bike/Rubrica/#a","text":"Pega feedback com duas pessoas externa e incorpora na interface Grava em \u00e1udio as entrevistas Grava um v\u00eddeo atualizado explicando o que foi sugerido e o que fizeram para melhorar a interface","title":"A"},{"location":"navigation/APS/APS-2-Bike/Rubrica/#b","text":"Pega feedback com o Luiz do Fablab e incorpora na interface. Grava um v\u00eddeo atualizado explicando o que foi sugerido e o que fizeram para melhorar a interface.","title":"B"},{"location":"navigation/APS/APS-2-Bike/Rubrica/#c","text":"Mockup da interface: Entrega um prot\u00f3tipo da interface Indica quais s\u00e3o os widgets do LVGL Indica quais s\u00e3o as fontes (nome e tamanho) Grava um v\u00eddeo explicando a interface Todos do grupo devem aparecer no v\u00eddeo (pode ser em call)","title":"C"},{"location":"navigation/APS/APS-2-Bike/Rubrica/#firmware","text":"","title":"Firmware"},{"location":"navigation/APS/APS-2-Bike/Rubrica/#a_1","text":"","title":"A"},{"location":"navigation/APS/APS-2-Bike/Rubrica/#b_1","text":"","title":"B"},{"location":"navigation/APS/APS-2-Bike/Rubrica/#c_1","text":"","title":"C"},{"location":"navigation/Avaliacoes_e_Simulados/AV-0-Simulado/","text":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1 Criar reposit\u00f3rio pelo link a seguir: https://classroom.github.com/a/sUluYIVb O reposit\u00f3rio original \u00e9: https://github.com/Insper/AV1-Embarcados-Simulado","title":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1"},{"location":"navigation/Avaliacoes_e_Simulados/AV-0-Simulado/#simulado-avaliacao-pratica-1","text":"Criar reposit\u00f3rio pelo link a seguir: https://classroom.github.com/a/sUluYIVb O reposit\u00f3rio original \u00e9: https://github.com/Insper/AV1-Embarcados-Simulado","title":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1"},{"location":"navigation/Avaliacoes_e_Simulados/AV-0/","text":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1 Esse \u00e9 um simulado de como ser\u00e1 a avalia\u00e7\u00e3o pr\u00e1tica aplicada na disciplina de Computa\u00e7\u00e3o Embarcada. Sugerimos voc\u00ea fazer como se fosse a avalia\u00e7\u00e3o de verdade, assim ter\u00e1 uma ideia de como est\u00e1 indo na disciplina. Essa avalia\u00e7\u00e3o cobre os objetivos de aprendizagem da disciplina: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Secund\u00e1rios: Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Regas Consulta a colegas/ internet constituir\u00e3o viola\u00e7\u00f5es ao C\u00f3digo de \u00c9tica e de Conduta e acarretar\u00e3o san\u00e7\u00f5es nele previstas. Fa\u00e7a o seu trabalho de maneira \u00e9tica! A cada 15 minutos voc\u00ea dever\u00e1 fazer um commit no seu c\u00f3digo! C\u00f3digos que n\u00e3o tiverem commit a cada 15min ou que mudarem drasticamente entre os commits ser\u00e3o descartados (conceito I) !! Voc\u00ea deve inserir mensagens condizentes nos commits! Dura\u00e7\u00e3o: 2h AV1-Simulado Come\u00e7ando Atualize o SAME70-examples Atualize o arquivo ALUNO.json com seu nome e email e fa\u00e7a um commit imediatamente. Nessa avalia\u00e7\u00e3o iremos criar um cronometro regressivo e utilizaremos o m\u00f3dulo OLED para exibir os valores, para isso copie o projeto same70-examples/screens/OLED-Xplained-Pro-SPI/ para o reposit\u00f3rio criado para entregar a avalia\u00e7\u00e3o. Nessa avalia\u00e7\u00e3o iremos trabalhar com um sensor chamado de encoder. O Encoder \u00e9 um componente eletr\u00f4nico muito utilizado, ele basicamente gera pulsos conforme o deslocamento (angular ou linear, depende do modelo). J\u00e1 pensou como \u00e9 implementando o volume do som dos carros? \u00c9 com um enconder rotativo! Iremos utilizar o encoder K1-040 nessa APS, esse componente al\u00e9m do encoder possui uma chave (SW) totalizando 5 pinos: GND: terra VCC: 3v3 SW: Push button do encoder, precisa ativar pull-up DT: Dire\u00e7\u00e3o CLK: pulsos (20/ rota\u00e7\u00e3o) C O encoder servir\u00e1 para configurar os minutor do seu cronometro, o sistema deve come\u00e7ar com o valor 0 e a cada pulso do enconder (pino clk ) ele deve aumentar em 1 segundo o tempo total do cronometro (at\u00e9 no m\u00e1ximo 60), quando o usu\u00e1rio apertar o bot\u00e3o do encoder SW o sistema deve come\u00e7ar uma contagem regressiva, e quando o valor da contagem for 0, o mesmo deve piscar todos os LEDs da placa OLED a uma frequ\u00eancia de 6HZ at\u00e9 que o usu\u00e1rio aperte o bot\u00e3o SW do enconder novamente. Ao mesmo tempo que exibe a contagem do cronometro, voc\u00ea deve exibir a hora atual no display OLED. Resumo: Exibir valor do cronometro Valor do cronometro deve ser ajustado com pulsos do Encoder usar pino de CLK do encoder leitura por interrup\u00e7\u00e3o A contagem do cronometro deve inicializar quando usu\u00e1rio apertar a chave do encoder usar pino SW do encoder (ativar pullup nesse pino) SW deve funcionar por interrup\u00e7\u00e3o Piscar LEDs da placa OLED at\u00e9 usu\u00e1rio apertar a chave SW Exibir hora no display: HH:MM:SS C+ Piscar LED do kit de desenvolvimento enquanto o cronometro estiver ativado B Usar um bot\u00e3o da placa OLED para possibilitar que escolha a dire\u00e7\u00e3o do ajuste do cronometro (para cima ou para baixo) A Usar o pino DT do enconder que indica a dire\u00e7\u00e3o da rota\u00e7\u00e3o.","title":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1"},{"location":"navigation/Avaliacoes_e_Simulados/AV-0/#simulado-avaliacao-pratica-1","text":"Esse \u00e9 um simulado de como ser\u00e1 a avalia\u00e7\u00e3o pr\u00e1tica aplicada na disciplina de Computa\u00e7\u00e3o Embarcada. Sugerimos voc\u00ea fazer como se fosse a avalia\u00e7\u00e3o de verdade, assim ter\u00e1 uma ideia de como est\u00e1 indo na disciplina. Essa avalia\u00e7\u00e3o cobre os objetivos de aprendizagem da disciplina: Criar softwares para microcontroladores utilizando suas especificidades; Avaliar e melhorar solu\u00e7\u00f5es embarcadas integrando hardware/software levando em conta adequa\u00e7\u00e3o a uma aplica\u00e7\u00e3o; Integrar em um prot\u00f3tipo hardware, software b\u00e1sico, sistema operacional de tempo real e m\u00f3dulos de interfaceamento com usu\u00e1rios, de comunica\u00e7\u00e3o e de alimenta\u00e7\u00e3o. Secund\u00e1rios: Compreender as limita\u00e7\u00f5es de microcontroladores e seus perif\u00e9ricos; Buscar e analisar documenta\u00e7\u00e3o (datasheet) e extrair informa\u00e7\u00f5es relevantes. Regas Consulta a colegas/ internet constituir\u00e3o viola\u00e7\u00f5es ao C\u00f3digo de \u00c9tica e de Conduta e acarretar\u00e3o san\u00e7\u00f5es nele previstas. Fa\u00e7a o seu trabalho de maneira \u00e9tica! A cada 15 minutos voc\u00ea dever\u00e1 fazer um commit no seu c\u00f3digo! C\u00f3digos que n\u00e3o tiverem commit a cada 15min ou que mudarem drasticamente entre os commits ser\u00e3o descartados (conceito I) !! Voc\u00ea deve inserir mensagens condizentes nos commits! Dura\u00e7\u00e3o: 2h","title":"Simulado Avalia\u00e7\u00e3o pr\u00e1tica 1"},{"location":"navigation/Avaliacoes_e_Simulados/AV-0/#av1-simulado","text":"Come\u00e7ando Atualize o SAME70-examples Atualize o arquivo ALUNO.json com seu nome e email e fa\u00e7a um commit imediatamente. Nessa avalia\u00e7\u00e3o iremos criar um cronometro regressivo e utilizaremos o m\u00f3dulo OLED para exibir os valores, para isso copie o projeto same70-examples/screens/OLED-Xplained-Pro-SPI/ para o reposit\u00f3rio criado para entregar a avalia\u00e7\u00e3o. Nessa avalia\u00e7\u00e3o iremos trabalhar com um sensor chamado de encoder. O Encoder \u00e9 um componente eletr\u00f4nico muito utilizado, ele basicamente gera pulsos conforme o deslocamento (angular ou linear, depende do modelo). J\u00e1 pensou como \u00e9 implementando o volume do som dos carros? \u00c9 com um enconder rotativo! Iremos utilizar o encoder K1-040 nessa APS, esse componente al\u00e9m do encoder possui uma chave (SW) totalizando 5 pinos: GND: terra VCC: 3v3 SW: Push button do encoder, precisa ativar pull-up DT: Dire\u00e7\u00e3o CLK: pulsos (20/ rota\u00e7\u00e3o)","title":"AV1-Simulado"},{"location":"navigation/Avaliacoes_e_Simulados/AV-0/#c","text":"O encoder servir\u00e1 para configurar os minutor do seu cronometro, o sistema deve come\u00e7ar com o valor 0 e a cada pulso do enconder (pino clk ) ele deve aumentar em 1 segundo o tempo total do cronometro (at\u00e9 no m\u00e1ximo 60), quando o usu\u00e1rio apertar o bot\u00e3o do encoder SW o sistema deve come\u00e7ar uma contagem regressiva, e quando o valor da contagem for 0, o mesmo deve piscar todos os LEDs da placa OLED a uma frequ\u00eancia de 6HZ at\u00e9 que o usu\u00e1rio aperte o bot\u00e3o SW do enconder novamente. Ao mesmo tempo que exibe a contagem do cronometro, voc\u00ea deve exibir a hora atual no display OLED. Resumo: Exibir valor do cronometro Valor do cronometro deve ser ajustado com pulsos do Encoder usar pino de CLK do encoder leitura por interrup\u00e7\u00e3o A contagem do cronometro deve inicializar quando usu\u00e1rio apertar a chave do encoder usar pino SW do encoder (ativar pullup nesse pino) SW deve funcionar por interrup\u00e7\u00e3o Piscar LEDs da placa OLED at\u00e9 usu\u00e1rio apertar a chave SW Exibir hora no display: HH:MM:SS","title":"C"},{"location":"navigation/Avaliacoes_e_Simulados/AV-0/#c_1","text":"Piscar LED do kit de desenvolvimento enquanto o cronometro estiver ativado","title":"C+"},{"location":"navigation/Avaliacoes_e_Simulados/AV-0/#b","text":"Usar um bot\u00e3o da placa OLED para possibilitar que escolha a dire\u00e7\u00e3o do ajuste do cronometro (para cima ou para baixo)","title":"B"},{"location":"navigation/Avaliacoes_e_Simulados/AV-0/#a","text":"Usar o pino DT do enconder que indica a dire\u00e7\u00e3o da rota\u00e7\u00e3o.","title":"A"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/","text":"Simulado P1 Termostato digital Nesse simulado voc\u00ea deve desenvolver um prot\u00f3tipo de um termostato digital, com interface gr\u00e1fica e controle da pot\u00eancia via PWM. Dura\u00e7\u00e3o 3 horas Rubrica Aten\u00e7\u00e3o Lei o documento na integra antes de come\u00e7ar A (+ 2 itens) B (obrigat\u00f3rio +2 itens) ( obrigat\u00f3rio ) utiliza queue para comunica\u00e7\u00e3o entre AFEC e tarefa Adiciona um novo PWM para controle de velocidade do ventilador LED2 OLED Possibilita usu\u00e1rio definir pot\u00eancia do ventilador Possibilita usu\u00e1rio selecionar cen\u00e1rios pr\u00e9 definidos Pelo menos dois (turbo frio / frio e circula\u00e7\u00e3o) Modo soneca (touch screen) Desliga ar condicionado ap\u00f3s 3 minutos. Exibe que modo est\u00e1 ativado Exibe graficamente o valor da temperatura (n\u00e3o s\u00f3 num\u00e9rico) C Dica Foque primeiro no C! Faz uso de RTOS Uma tarefa para o LCD Sem\u00e1foros para comunica\u00e7\u00e3o com a tarefa (n\u00e3o usar flags!!) Coleta o valor da temperatura a cada 4 segundos N\u00e3o deve usar TC/ RTT! Usar funcionalidades do RTOS para isso Atua no ar condicionado via PWM (duty cicle) LED1 OLED Possibilita que o usu\u00e1rio controle a pot\u00eancia do ar condicionado (bot\u00f5es) Interface Cria interface pr\u00e9 definida. Exibe numericamente o valor da temperatura Exibe numericamente a pot\u00eancia do ar condicionado Exibe hora no display D Dois itens de C faltando/errado I Tr\u00eas ou mais itens de C faltando/errado Descri\u00e7\u00e3o Voc\u00ea deve projetar um prot\u00f3tipo de um termostato, nesse prot\u00f3tipo deve exibir de forma gr\u00e1fica a temperatura do ambiente e permitir ao usu\u00e1rio controlar a pot\u00eancia do ar condicionado, usando um RTOS. Come\u00e7ando Atualize os dois reposit\u00f3rios da disciplina Crie um reposit\u00f3rio no github Preencha o forms a seguir: (no simulado n\u00e3o tem) Copie o projeto exemplo: RTOS-LCD-maXTouch para seu reposit\u00f3rio Reposit\u00f3rio: $ git add * $ git commit -am \"comecando\" PWM Nessa APS iremos trabalhar com o perif\u00e9rico PWM, utilize de exemplo o projeto: SAME70-examples/perifericos-uc/PWM Abra o projeto Execute o exemplo Entenda o que est\u00e1 acontecendo Interface Voc\u00ea deve implementar a interface a seguir: Os icones e a fonte j\u00e1 foram convertidos e est\u00e3o na pasta do exemplo RTOS-LCD-maxTouch : Arquivo Img soneca.h termometro.h digital521.h Fonte a ser usada Temperatura A temperatura deve ser simulada por um potenci\u00f4metro conectado a placa, sendo o m\u00ednimo 0 graus c\u00e9lcios e o m\u00e1ximo 100. Dicas Note Cada item deve ser testado e validado, n\u00e3o continue se n\u00e3o estiver funcionando! Entendendo o perif\u00e9rico PWM Desenvolva a interface proposta V\u00e1 inserindo os icones, um a um Insira os textos (valor padr\u00e3o) Incorpore a leitura anal\u00f3gica no projeto (AFEC) Leia a temperatura a cada 4s Cuidado com a rubrica! Voc\u00ea n\u00e3o deve usar TC ou RTT Crie uma tarefa no RTOS para isso! Altere para ler o potenci\u00f4metro externo a placa Atualize a interface para exibir a temperatura real Incorpore o PWM ao projeto (use como refer\u00eancia o demo) Configure dois bot\u00f5es com interrup\u00e7\u00e3o para servir de controle da pot\u00eancia Comunique os callbacks com a tarefa do LCD via sem\u00e1foros Na tarefa do LCD controle o duty-cycle Exiba o novo valor do duty-cycle","title":"Simulado P1"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/#simulado-p1","text":"Termostato digital Nesse simulado voc\u00ea deve desenvolver um prot\u00f3tipo de um termostato digital, com interface gr\u00e1fica e controle da pot\u00eancia via PWM. Dura\u00e7\u00e3o 3 horas","title":"Simulado P1"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/#rubrica","text":"Aten\u00e7\u00e3o Lei o documento na integra antes de come\u00e7ar","title":"Rubrica"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/#a-2-itens","text":"","title":"A (+ 2 itens)"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/#b-obrigatorio-2-itens","text":"( obrigat\u00f3rio ) utiliza queue para comunica\u00e7\u00e3o entre AFEC e tarefa Adiciona um novo PWM para controle de velocidade do ventilador LED2 OLED Possibilita usu\u00e1rio definir pot\u00eancia do ventilador Possibilita usu\u00e1rio selecionar cen\u00e1rios pr\u00e9 definidos Pelo menos dois (turbo frio / frio e circula\u00e7\u00e3o) Modo soneca (touch screen) Desliga ar condicionado ap\u00f3s 3 minutos. Exibe que modo est\u00e1 ativado Exibe graficamente o valor da temperatura (n\u00e3o s\u00f3 num\u00e9rico)","title":"B (obrigat\u00f3rio +2 itens)"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/#c","text":"Dica Foque primeiro no C! Faz uso de RTOS Uma tarefa para o LCD Sem\u00e1foros para comunica\u00e7\u00e3o com a tarefa (n\u00e3o usar flags!!) Coleta o valor da temperatura a cada 4 segundos N\u00e3o deve usar TC/ RTT! Usar funcionalidades do RTOS para isso Atua no ar condicionado via PWM (duty cicle) LED1 OLED Possibilita que o usu\u00e1rio controle a pot\u00eancia do ar condicionado (bot\u00f5es) Interface Cria interface pr\u00e9 definida. Exibe numericamente o valor da temperatura Exibe numericamente a pot\u00eancia do ar condicionado Exibe hora no display","title":"C"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/#d","text":"Dois itens de C faltando/errado","title":"D"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/#i","text":"Tr\u00eas ou mais itens de C faltando/errado","title":"I"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/#descricao","text":"Voc\u00ea deve projetar um prot\u00f3tipo de um termostato, nesse prot\u00f3tipo deve exibir de forma gr\u00e1fica a temperatura do ambiente e permitir ao usu\u00e1rio controlar a pot\u00eancia do ar condicionado, usando um RTOS.","title":"Descri\u00e7\u00e3o"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/#comecando","text":"Atualize os dois reposit\u00f3rios da disciplina Crie um reposit\u00f3rio no github Preencha o forms a seguir: (no simulado n\u00e3o tem) Copie o projeto exemplo: RTOS-LCD-maXTouch para seu reposit\u00f3rio Reposit\u00f3rio: $ git add * $ git commit -am \"comecando\"","title":"Come\u00e7ando"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/#pwm","text":"Nessa APS iremos trabalhar com o perif\u00e9rico PWM, utilize de exemplo o projeto: SAME70-examples/perifericos-uc/PWM Abra o projeto Execute o exemplo Entenda o que est\u00e1 acontecendo","title":"PWM"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/#interface","text":"Voc\u00ea deve implementar a interface a seguir: Os icones e a fonte j\u00e1 foram convertidos e est\u00e3o na pasta do exemplo RTOS-LCD-maxTouch : Arquivo Img soneca.h termometro.h digital521.h Fonte a ser usada","title":"Interface"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/#temperatura","text":"A temperatura deve ser simulada por um potenci\u00f4metro conectado a placa, sendo o m\u00ednimo 0 graus c\u00e9lcios e o m\u00e1ximo 100.","title":"Temperatura"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1-Simulado/#dicas","text":"Note Cada item deve ser testado e validado, n\u00e3o continue se n\u00e3o estiver funcionando! Entendendo o perif\u00e9rico PWM Desenvolva a interface proposta V\u00e1 inserindo os icones, um a um Insira os textos (valor padr\u00e3o) Incorpore a leitura anal\u00f3gica no projeto (AFEC) Leia a temperatura a cada 4s Cuidado com a rubrica! Voc\u00ea n\u00e3o deve usar TC ou RTT Crie uma tarefa no RTOS para isso! Altere para ler o potenci\u00f4metro externo a placa Atualize a interface para exibir a temperatura real Incorpore o PWM ao projeto (use como refer\u00eancia o demo) Configure dois bot\u00f5es com interrup\u00e7\u00e3o para servir de controle da pot\u00eancia Comunique os callbacks com a tarefa do LCD via sem\u00e1foros Na tarefa do LCD controle o duty-cycle Exiba o novo valor do duty-cycle","title":"Dicas"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1/","text":"Avalia\u00e7\u00e3o 1<<1 Microondas! Nessa avalia\u00e7\u00e3o voc\u00ea deve desenvolver um prot\u00f3tipo de um controlador para microondas, com interface gr\u00e1fica e controle da pot\u00eancia via PWM. Dura\u00e7\u00e3o 3 horas Come\u00e7ando Atualize os dois reposit\u00f3rios da disciplina Crie um reposit\u00f3rio no github Preencha o forms a seguir: (no simulado n\u00e3o tem) Copie o projeto exemplo: RTOS-LCD-maXTouch para seu reposit\u00f3rio Reposit\u00f3rio: $ git add * $ git commit -am \"comecando\" Rubrica Aten\u00e7\u00e3o Lei o documento na integra antes de come\u00e7ar Perde conceito se: Voc\u00ea n\u00e3o deve utilizar fun\u00e7\u00e3o de delay, que n\u00e3o a do RTOS -\u00bd conceito Voc\u00ea n\u00e3o deve utilizar vari\u00e1veis globais, que n\u00e3o fila e queue -\u00bd conceito C LCD exibe interface pr\u00e9 definida Exibe icone de fim quando acaba Exibe icone de em progresso, quando o micro ondas estiver ligado Timer implementando Bot\u00e3o: incrementa +10 segundos Bot\u00e3o: incrementa +1 minuto Fun\u00e7\u00e3o de Start/ Stop A (+ 4 pts) / B (+ 2 pts) (2 pts) Interface touch (1 pt ) Adicionar PWM para controlar pot\u00eancia do microondas (1 pt ) Adicionar rel\u00f3gio (2 pts) Adicionar ADC para controlar tempo do timer (1 pt ) Start sem tempo, adiciona 30 segundos D/ I (D) Dois itens de C faltando/errado (I) Tr\u00eas ou mais itens de C faltando/errado Descri\u00e7\u00e3o Voc\u00ea deve projetar um prot\u00f3tipo de um controlador de microondas. Essa interface deve possuir um constador regressivo (timer) que indicar\u00e1 quanto tempo o micro ondas ficar\u00e1 ligado, e quanto tempo vai levar para acabar o ciclo atual. Uma vez ligado, a interface deve exibir o icone de que est\u00e1 em funcionamento. E no fim, o icone de que acabou. O microondas deve possuir tr\u00eas bot\u00f5es (placa OLED1), cada bot\u00e3o servir\u00e1 para: Bot\u00e3o 0 : Start / Pause/ Stop Bot\u00e3o 1 : +10 segundos / Stop Bot\u00e3o 2 : +60 segundos Quando o microondas estiver funcionando, os LEDs da placa OLED devem estar ligados, quando acabar o ciclo, os leds devem apagarem. Interface Voc\u00ea deve implementar a interface a seguir: Os icones e a fonte j\u00e1 foram convertidos e est\u00e3o na pasta do exemplo RTOS-LCD-maxTouch : digital521.h done.h pause.h on.h Fonte a ser usada Firmware Voc\u00ea deve desenvolver um firmware que possui duas tarefas: Uma respons\u00e1vel por atualizar o LCD e outra respons\u00e1vel pela contagem. A comunica\u00e7\u00e3o entre as tarefas e entre tarefas e interrup\u00e7\u00e3o deve ser realizada sempre com recursos do RTOS (fila/ sem\u00e1foro ...). Start/Stop/Pause O bot\u00e3o de start/stop e pause deve ser da seguinte maneira: Botao 0: --> Run --> Pause --> Run --> \\ Bot\u00e3o 1: \\ Stop --> Botao 0: --> Run --> Pause --> \\ Bot\u00e3o 1: \\ Stop -->","title":"Avalia\u00e7\u00e3o 1<<1"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1/#avaliacao-11","text":"Microondas! Nessa avalia\u00e7\u00e3o voc\u00ea deve desenvolver um prot\u00f3tipo de um controlador para microondas, com interface gr\u00e1fica e controle da pot\u00eancia via PWM. Dura\u00e7\u00e3o 3 horas","title":"Avalia\u00e7\u00e3o 1&lt;&lt;1"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1/#comecando","text":"Atualize os dois reposit\u00f3rios da disciplina Crie um reposit\u00f3rio no github Preencha o forms a seguir: (no simulado n\u00e3o tem) Copie o projeto exemplo: RTOS-LCD-maXTouch para seu reposit\u00f3rio Reposit\u00f3rio: $ git add * $ git commit -am \"comecando\"","title":"Come\u00e7ando"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1/#rubrica","text":"Aten\u00e7\u00e3o Lei o documento na integra antes de come\u00e7ar Perde conceito se: Voc\u00ea n\u00e3o deve utilizar fun\u00e7\u00e3o de delay, que n\u00e3o a do RTOS -\u00bd conceito Voc\u00ea n\u00e3o deve utilizar vari\u00e1veis globais, que n\u00e3o fila e queue -\u00bd conceito","title":"Rubrica"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1/#c","text":"LCD exibe interface pr\u00e9 definida Exibe icone de fim quando acaba Exibe icone de em progresso, quando o micro ondas estiver ligado Timer implementando Bot\u00e3o: incrementa +10 segundos Bot\u00e3o: incrementa +1 minuto Fun\u00e7\u00e3o de Start/ Stop","title":"C"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1/#a-4-pts-b-2-pts","text":"(2 pts) Interface touch (1 pt ) Adicionar PWM para controlar pot\u00eancia do microondas (1 pt ) Adicionar rel\u00f3gio (2 pts) Adicionar ADC para controlar tempo do timer (1 pt ) Start sem tempo, adiciona 30 segundos","title":"A (+ 4 pts) /  B (+ 2 pts)"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1/#d-i","text":"(D) Dois itens de C faltando/errado (I) Tr\u00eas ou mais itens de C faltando/errado","title":"D/ I"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1/#descricao","text":"Voc\u00ea deve projetar um prot\u00f3tipo de um controlador de microondas. Essa interface deve possuir um constador regressivo (timer) que indicar\u00e1 quanto tempo o micro ondas ficar\u00e1 ligado, e quanto tempo vai levar para acabar o ciclo atual. Uma vez ligado, a interface deve exibir o icone de que est\u00e1 em funcionamento. E no fim, o icone de que acabou. O microondas deve possuir tr\u00eas bot\u00f5es (placa OLED1), cada bot\u00e3o servir\u00e1 para: Bot\u00e3o 0 : Start / Pause/ Stop Bot\u00e3o 1 : +10 segundos / Stop Bot\u00e3o 2 : +60 segundos Quando o microondas estiver funcionando, os LEDs da placa OLED devem estar ligados, quando acabar o ciclo, os leds devem apagarem.","title":"Descri\u00e7\u00e3o"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1/#interface","text":"Voc\u00ea deve implementar a interface a seguir: Os icones e a fonte j\u00e1 foram convertidos e est\u00e3o na pasta do exemplo RTOS-LCD-maxTouch : digital521.h done.h pause.h on.h Fonte a ser usada","title":"Interface"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1/#firmware","text":"Voc\u00ea deve desenvolver um firmware que possui duas tarefas: Uma respons\u00e1vel por atualizar o LCD e outra respons\u00e1vel pela contagem. A comunica\u00e7\u00e3o entre as tarefas e entre tarefas e interrup\u00e7\u00e3o deve ser realizada sempre com recursos do RTOS (fila/ sem\u00e1foro ...).","title":"Firmware"},{"location":"navigation/Avaliacoes_e_Simulados/AV-1/#startstoppause","text":"O bot\u00e3o de start/stop e pause deve ser da seguinte maneira: Botao 0: --> Run --> Pause --> Run --> \\ Bot\u00e3o 1: \\ Stop --> Botao 0: --> Run --> Pause --> \\ Bot\u00e3o 1: \\ Stop -->","title":"Start/Stop/Pause"},{"location":"navigation/Avaliacoes_e_Simulados/Avaliacoes/","text":"Avalia\u00e7\u00f5es e Simulados Aqui um resumo das avalia\u00e7\u00f5es e simulados para voc\u00eas usarem como base de estudo. As avalia\u00e7\u00f5es s\u00e3o com proctorio, e \u00e9 liberado consulta local (ao seus c\u00f3digos, exemplos da disciplina) e ao site da mat\u00e9ria. Tip Ser\u00e1 necess\u00e1rio configurar os perif\u00e9ricos do uC, sugerimos voc\u00eas criarem resumos de cada perif\u00e9rico, com as fun\u00e7\u00f5es e suas configura\u00e7\u00f5es, assim n\u00e3o perdem muito tempo na prova. \u00c9 importante voc\u00eas cronometrarem o tempo que levaram para realizar o estudo, pois a avalia\u00e7\u00e3o deve ser realizada em 2h . As avalia\u00e7\u00f5es pr\u00e1ticas s\u00e3o bin\u00e1rias (A ou I), possuem um requisito m\u00ednimo que se atingido o aluno ganha A , caso contr\u00e1rio I . Como crit\u00e9rio de barreira, voc\u00eas precisam de 2 notas A nas avalia\u00e7\u00f5es pr\u00e1ticas. AV1 Conte\u00fado: APS-1 Lab1-PIO, Lab2-Driver, Lab3-PIO-IRQ, Lab4-RTOS, Lab5_RTOS_HC_SR04 Perif\u00e9ricos: PIO, AFEC, RTT, OLED, RTOS Os simulados (atualizados para 2022b) est\u00e3o no reposit\u00f3rio: https://github.com/Insper/embarcados-simulados Cada simulado foi inspirado em uma avalia\u00e7\u00e3o j\u00e1 aplicada na disciplina, mas adaptado para a vers\u00e3o atual do curso: \u2b50\u2b50 cafe-expresso : M\u00e1quina de caf\u00e9 expresso \u2b50\u2b50 patinete : Controle de um patinete el\u00e9trico \u2b50 cofre : Implementar um cofre no sistema embarcado, o forte desse aqui \u00e9 programa\u00e7\u00e3o em C. \u2b50 geladeira : Fazer o controle de uma geladeira.","title":"Avalia\u00e7\u00f5es e Simulados"},{"location":"navigation/Avaliacoes_e_Simulados/Avaliacoes/#avaliacoes-e-simulados","text":"Aqui um resumo das avalia\u00e7\u00f5es e simulados para voc\u00eas usarem como base de estudo. As avalia\u00e7\u00f5es s\u00e3o com proctorio, e \u00e9 liberado consulta local (ao seus c\u00f3digos, exemplos da disciplina) e ao site da mat\u00e9ria. Tip Ser\u00e1 necess\u00e1rio configurar os perif\u00e9ricos do uC, sugerimos voc\u00eas criarem resumos de cada perif\u00e9rico, com as fun\u00e7\u00f5es e suas configura\u00e7\u00f5es, assim n\u00e3o perdem muito tempo na prova. \u00c9 importante voc\u00eas cronometrarem o tempo que levaram para realizar o estudo, pois a avalia\u00e7\u00e3o deve ser realizada em 2h . As avalia\u00e7\u00f5es pr\u00e1ticas s\u00e3o bin\u00e1rias (A ou I), possuem um requisito m\u00ednimo que se atingido o aluno ganha A , caso contr\u00e1rio I . Como crit\u00e9rio de barreira, voc\u00eas precisam de 2 notas A nas avalia\u00e7\u00f5es pr\u00e1ticas.","title":"Avalia\u00e7\u00f5es e Simulados"},{"location":"navigation/Avaliacoes_e_Simulados/Avaliacoes/#av1","text":"Conte\u00fado: APS-1 Lab1-PIO, Lab2-Driver, Lab3-PIO-IRQ, Lab4-RTOS, Lab5_RTOS_HC_SR04 Perif\u00e9ricos: PIO, AFEC, RTT, OLED, RTOS Os simulados (atualizados para 2022b) est\u00e3o no reposit\u00f3rio: https://github.com/Insper/embarcados-simulados Cada simulado foi inspirado em uma avalia\u00e7\u00e3o j\u00e1 aplicada na disciplina, mas adaptado para a vers\u00e3o atual do curso: \u2b50\u2b50 cafe-expresso : M\u00e1quina de caf\u00e9 expresso \u2b50\u2b50 patinete : Controle de um patinete el\u00e9trico \u2b50 cofre : Implementar um cofre no sistema embarcado, o forte desse aqui \u00e9 programa\u00e7\u00e3o em C. \u2b50 geladeira : Fazer o controle de uma geladeira.","title":"AV1"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/","text":"21b - EMB - AV1 Manter o proctorio aberto o tempo todo! A cada 30 minutos voc\u00ea dever\u00e1 fazer um commit no seu c\u00f3digo! C\u00f3digos que n\u00e3o tiverem commit a cada 30min ou que mudarem drasticamente entre os commits podem ter a entrega anulada. Tente inserir mensagens condizentes nos commits! Dura\u00e7\u00e3o total: 3h Info Criar o reposit\u00f3rio de entrega pelo link: https://classroom.github.com/a/j8AgL-mu Usem como base o c\u00f3digo dispon\u00edvel neste reposit\u00f3rio. Voc\u00eas v\u00e3o precisar: \u25b6\ufe0f Conectar o OLED1 ao EXT-1 Descri\u00e7\u00e3o Voc\u00eas ir\u00e3o desenvolver um sensor/ sistema embarcado para leitura da roda f\u00f4nica de uma inje\u00e7\u00e3o eletr\u00f4nica, esse sensor \u00e9 um dos muitos existentes em um autom\u00f3vel. A roda f\u00f4nica \u00e9 um disco com dentes atrelada ao rotor do motor, um sensor magn\u00e9tico faz a leitura dos dentes do disco e gera um sinal el\u00e9trico (pulso) conforme os dentes v\u00e3o passando por ele. Essa informa\u00e7\u00e3o \u00e9 utilizada pela inje\u00e7\u00e3o eletr\u00f4nica para: Saber a fase atual do motor (ciclo oto) Identificar a velocidade de rota\u00e7\u00e3o do motor A imagem a seguir ilustra uma roda f\u00f4nica de um motor com 60 dentes e 2 faltando. Info Notem que na figura a seguir existe um dente da roda \"faltando\", isso serve para identificar a posi\u00e7\u00e3o ZERO do disco. Imagem adaptada de https://www.canaldapeca.com.br/blog/qual-diferenca-entre-distribuidor-e-roda-fonica/ O per\u00edodo dos pulsos indica a velocidade angular do disco e por consequ\u00eancia a velocidade de rota\u00e7\u00e3o do motor. A imagem a seguir \u00e9 um exemplo dos pulsos gerados pelo sensor atrelado a uma roda f\u00f4nica com 10-1 dentes , neste caso o motor est\u00e1 girando a uma rota\u00e7\u00e3o constante. Notem que existe um pulso faltando, isso \u00e9 por conta do dente \"faltando\", esse pulso faltando que define o ponto zero. Voc\u00eas ter\u00e3o que desenvolver um sistema embarcado que: Calcula a velocidade angula do motor e exibe no LCD. Identifica o ponto Zero da roda. Sistema de testes Iremos utilizar uma t\u00e9cnica de simula\u00e7\u00e3o chamada de Hardware-in-the-loop Simulation (HIL), que de forma simplificada \u00e9 um sistema que simula em tempo real uma planta/ sinal. No nosso caso, iremos simular a rota\u00e7\u00e3o da roda f\u00f4nica (gerando os pulsos). Isso ser\u00e1 feito no pr\u00f3prio uC que voc\u00eas estar\u00e3o desenvolvendo o sensor, em um sistema mais completo talvez seja necess\u00e1rio uma eletr\u00f4nica mais sofisticada. O projeto dispon\u00edvel no reposit\u00f3rio gera os pulsos simulados de uma roda f\u00f4nica no pino PD30 do EXT2, para isso utilizamos o timer 2 ( TC2 ), conforme imagem a seguir: /-----------\\ | | TC2 | PD30 | | |-----> | | | | | | | | | | | | | | | | | ------ | pulsos | | | uc | \\-----------/ Warning N\u00e3o usar nenhum canal do TC2! N\u00e3o usar o bot\u00e3o da placa (serve para desacelerar o disco)! N\u00e3o usar o LED da placa (pisco a cada pulso do Zero)! N\u00e3o tirar a fun\u00e7\u00e3o roda_fonica_init do main N\u00e3o modificar nada nos arquivos abs.h e abs.c Utilizar os seguintes par\u00e2metros como refer\u00eancia: Par\u00e2metro valor n total de dentes da roda 10 n de dentes faltando 1 velocidade de rota\u00e7\u00e3o nominal dado roda (passagem pelo zero) 120 rpm velocidade m\u00e1xima 500 rpm Tip 600 rpm = 600/60 = 10 rota\u00e7\u00f5es da roda por segundo Mas temos que lembrar que teremos 10 pulsos -1 da roda a cada rotac\u00e3o total, com isso iremos obter uma frequ\u00eancia de pulsos de aproximadamente: 10*10 = 90 Hz Avaliac\u00e3o A seguir a rubrica da avalia\u00e7\u00e3o. C Para obterem o conceito C, voc\u00eas devem entregar um firmware que: Preencher o formul\u00e1rio https://docs.google.com/forms/d/e/1FAIpQLSd3oTNrgGqiqt2wiommtRfXj2Urx23XGpDZYRgxIxpJBVhi8g/viewform Faz a leitura dos pulsos simulados da roda f\u00f4nica Identifica quando a roda passa pela origem. Piscar o LED 3 da placa OLED a cada pulso da roda! Piscar os LED 1 e LED 2 da placa OLED a cada sinal de refer\u00eancia (Zero)! usar pin_toggler ! Exibe no OLED a velocidade de rota\u00e7\u00e3o m\u00e9dia da roda em rota\u00e7\u00f5es por minuto - rpm (atualizar valor ap\u00f3s uma rota\u00e7\u00e3o completa) Voc\u00eas devem utilizar um perif\u00e9rico de tempo para calcular o dT entre os pulsos e interrup\u00e7\u00e3o no pino para a leitura do sinal gerado no PD30. B/ A Os pontos aqui valem apenas se o conceito C foi atingido (todos os itens!). (+1.0 conceito) Identifica quando a roda parou de girar e indicar velocidade de rota\u00e7\u00e3o: 0 rpm no LCD (+0.50 conceito) Organiza o c\u00f3digo em fun\u00e7\u00f5es: C\u00e1lculo do rpm Fun\u00e7\u00e3o para exibir o valor no LCD (+0.25 conceito) S\u00f3 exibe a velocidade uma vez por rota\u00e7\u00e3o, quando encontrado (+0.50 conceito) Utiliza m\u00e9dia m\u00f3vel para o c\u00e1lculo do rpm (+0.50 conceito) Exibe graficamente a velocidade no LCD. Dicas A seguir dicas para realizarem a entrega Debug Depurar \u00e9 importante e ajuda bastante, mas tomem cuidado que os rel\u00f3gios n\u00e3o param de contar quando o programa estiver em \"pause\". Terminal + printf Eu habilitei o terminal para voc\u00eas, podem usar printf !. S\u00f3 cuidado com o uso pois ele \u00e9 lento e as vezes n\u00e3o podemos perder tempo... C - Oscilosc\u00f3pio A imagem a seguir \u00e9 referente aos pulsos que s\u00e3o gerados no HIL, o tempo entre os pulsos \u00e9 de 50 ms. 50ms = 20Hz / 10 dentes = 2 rps ou 120 rpm C - Lendo o sinal Voc\u00eas devem escolher um pino qualquer do uC, configurar como entrada sem pull_up ou debounce (usar PIO_DEFAULT ), configurar interrup\u00e7\u00e3o e atrelar uma fun\u00e7\u00e3o de callback. Pisque o LED3 da placa OLED a cada pulso recebido, com isso sabemos que a fun\u00e7\u00e3o est\u00e1 funcionando e \u00e9 um dos itens da rubrica! Tip Usar a fun\u00e7\u00e3o pin_toggle que j\u00e1 foi definida! N\u00e3o usar IT_EDGE N\u00e3o usar debounce N\u00e3o usar PULL_UP C - Calculando dT Utilizem o RTT para calcular o tempo entre os pulsos, reiniciando o contador a cada novo pulso. Detecta pulso e inicializa contagem de tempo L\u00ea o valor do tempo entre um pulso e outro Como indicado na figura a seguir: Info A fun\u00e7\u00e3o RTT init fornecida n\u00e3o tem o IRQ de incremento! Apenas o alarme. Se quiser fazer com o TC tamb\u00e9m da, mas ai tem que manter um contador global dos pulsos. Tip Utilize 1000 como prescale para o RTT, \u00e9 um bom valor (eu testei aqui)! Imprima no terminal sempre que obtiver um novo valor de dT, lembre de fazer a impress\u00e3o no main e n\u00e3o dentro do callback! Voc\u00eas devem obter algo como: Notem que temos um dT com valor 102 ms isso \u00e9 referente ao pulso faltante, como ilustrado a seguir: ^ ^ ^ ^ ^ | | | | | | | | | | 51 102 51 51 ms C - Velocidade angular Agora com o dT voc\u00ea \u00e9 capaz de: Calcular a velocidade do disco em rps: $w = \\frac{1}{dT}$ Converta de rota\u00e7\u00f5es por segundo para rota\u00e7\u00f5es por minuto (*60) Exiba no LCD a velocidade Warning Lembre de n\u00e3o atualizar o LCD dentro de interrup\u00e7\u00e3o / callback! Tip Lembre de converter dT para segundos! Cuidado com a convers\u00e3o float/ int/ ... C - Identificando Zero Para identificar o dente faltante \u00e9 necess\u00e1rio \"prevermos\" quando um pulso deveria acontecer, isso pode ser feito atrav\u00e9s do alarme do RTT que deve ser configurado utilizando como base o dT calculado do pulso anterior (ou de uma m\u00e9dia). Um cuidado que voc\u00eas devem ter \u00e9 com o valor usado no timeout do RTT, n\u00e3o usar o valor do dT com o dente estimado, usar o \u00faltimo valor v\u00e1lido . Tip Definam uma toler\u00e2ncia para o pulso, eu experimentei aqui e 20% \u00e9 um bom valor! Ou seja, o alarme para o pulso \u00e9 dT*1.2 . Podemos interpretar isso como: se passado 20% do tempo esperado para um pulso sem o recebimento do mesmo, esse slot \u00e9 do dente faltante. Lembrem de zerar o RTT quando o pulso faltante for detectado. Voc\u00eas devem obter algo como: Eu estou imprimendo um * toda vez que o pulso zero \u00e9 detectado. A/B - M\u00e9dia m\u00f3vel A m\u00e9dia m\u00f3vel \u00e9 um dos filtros mais simples que existe, suavizando o sinal no tempo e removendo ru\u00eddos (n), sua ideia \u00e9 bem simples e vou explicar com um exemplo (filtro de janela 5). | sinal filtrado v y [ 1 ] = ( x [ 1 ] + 0 + 0 + 0 + 0 ) / 5 y [ 2 ] = ( x [ 2 ] + x [ 1 ] + 0 + 0 + 0 ) / 5 y [ 3 ] = ( x [ 3 ] + x [ 2 ] + x [ 1 ] + 0 + 0 ) / 5 ... y [ 5 ] = ( x [ 4 ] + x [ 3 ] + x [ 2 ] + x [ 1 ] + x [ 0 ]) / 5 y [ 6 ] = ( x [ 5 ] + x [ 4 ] + x [ 3 ] + x [ 2 ] + x [ 1 ]) / 5 / / ---------------------> shift Novo dado Implemente o filtro em C e use para exibir o valor. Info Existe uma vers\u00e3o recursiva do filtro onde n\u00e3o \u00e9 necess\u00e1rio armazenar o buffer e fazer o shift. A/B - Identifica quando a roda parou de girar e indicar velocidade de rota\u00e7\u00e3o: 0 rpm no LCD O bot\u00e3o da placa foi configurado para iniciar a frenagem do motor, uma vez apertado os pulsos v\u00e3o se espa\u00e7ando at\u00e9 parar. Se apertar novamente os pulsos voltam a velocidade padr\u00e3o.","title":"21b - EMB - AV1"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#21b-emb-av1","text":"Manter o proctorio aberto o tempo todo! A cada 30 minutos voc\u00ea dever\u00e1 fazer um commit no seu c\u00f3digo! C\u00f3digos que n\u00e3o tiverem commit a cada 30min ou que mudarem drasticamente entre os commits podem ter a entrega anulada. Tente inserir mensagens condizentes nos commits! Dura\u00e7\u00e3o total: 3h Info Criar o reposit\u00f3rio de entrega pelo link: https://classroom.github.com/a/j8AgL-mu Usem como base o c\u00f3digo dispon\u00edvel neste reposit\u00f3rio. Voc\u00eas v\u00e3o precisar: \u25b6\ufe0f Conectar o OLED1 ao EXT-1","title":"21b - EMB - AV1"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#descricao","text":"Voc\u00eas ir\u00e3o desenvolver um sensor/ sistema embarcado para leitura da roda f\u00f4nica de uma inje\u00e7\u00e3o eletr\u00f4nica, esse sensor \u00e9 um dos muitos existentes em um autom\u00f3vel. A roda f\u00f4nica \u00e9 um disco com dentes atrelada ao rotor do motor, um sensor magn\u00e9tico faz a leitura dos dentes do disco e gera um sinal el\u00e9trico (pulso) conforme os dentes v\u00e3o passando por ele. Essa informa\u00e7\u00e3o \u00e9 utilizada pela inje\u00e7\u00e3o eletr\u00f4nica para: Saber a fase atual do motor (ciclo oto) Identificar a velocidade de rota\u00e7\u00e3o do motor A imagem a seguir ilustra uma roda f\u00f4nica de um motor com 60 dentes e 2 faltando. Info Notem que na figura a seguir existe um dente da roda \"faltando\", isso serve para identificar a posi\u00e7\u00e3o ZERO do disco. Imagem adaptada de https://www.canaldapeca.com.br/blog/qual-diferenca-entre-distribuidor-e-roda-fonica/ O per\u00edodo dos pulsos indica a velocidade angular do disco e por consequ\u00eancia a velocidade de rota\u00e7\u00e3o do motor. A imagem a seguir \u00e9 um exemplo dos pulsos gerados pelo sensor atrelado a uma roda f\u00f4nica com 10-1 dentes , neste caso o motor est\u00e1 girando a uma rota\u00e7\u00e3o constante. Notem que existe um pulso faltando, isso \u00e9 por conta do dente \"faltando\", esse pulso faltando que define o ponto zero. Voc\u00eas ter\u00e3o que desenvolver um sistema embarcado que: Calcula a velocidade angula do motor e exibe no LCD. Identifica o ponto Zero da roda.","title":"Descri\u00e7\u00e3o"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#sistema-de-testes","text":"Iremos utilizar uma t\u00e9cnica de simula\u00e7\u00e3o chamada de Hardware-in-the-loop Simulation (HIL), que de forma simplificada \u00e9 um sistema que simula em tempo real uma planta/ sinal. No nosso caso, iremos simular a rota\u00e7\u00e3o da roda f\u00f4nica (gerando os pulsos). Isso ser\u00e1 feito no pr\u00f3prio uC que voc\u00eas estar\u00e3o desenvolvendo o sensor, em um sistema mais completo talvez seja necess\u00e1rio uma eletr\u00f4nica mais sofisticada. O projeto dispon\u00edvel no reposit\u00f3rio gera os pulsos simulados de uma roda f\u00f4nica no pino PD30 do EXT2, para isso utilizamos o timer 2 ( TC2 ), conforme imagem a seguir: /-----------\\ | | TC2 | PD30 | | |-----> | | | | | | | | | | | | | | | | | ------ | pulsos | | | uc | \\-----------/ Warning N\u00e3o usar nenhum canal do TC2! N\u00e3o usar o bot\u00e3o da placa (serve para desacelerar o disco)! N\u00e3o usar o LED da placa (pisco a cada pulso do Zero)! N\u00e3o tirar a fun\u00e7\u00e3o roda_fonica_init do main N\u00e3o modificar nada nos arquivos abs.h e abs.c Utilizar os seguintes par\u00e2metros como refer\u00eancia: Par\u00e2metro valor n total de dentes da roda 10 n de dentes faltando 1 velocidade de rota\u00e7\u00e3o nominal dado roda (passagem pelo zero) 120 rpm velocidade m\u00e1xima 500 rpm Tip 600 rpm = 600/60 = 10 rota\u00e7\u00f5es da roda por segundo Mas temos que lembrar que teremos 10 pulsos -1 da roda a cada rotac\u00e3o total, com isso iremos obter uma frequ\u00eancia de pulsos de aproximadamente: 10*10 = 90 Hz","title":"Sistema de testes"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#avaliacao","text":"A seguir a rubrica da avalia\u00e7\u00e3o.","title":"Avaliac\u00e3o"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#c","text":"Para obterem o conceito C, voc\u00eas devem entregar um firmware que: Preencher o formul\u00e1rio https://docs.google.com/forms/d/e/1FAIpQLSd3oTNrgGqiqt2wiommtRfXj2Urx23XGpDZYRgxIxpJBVhi8g/viewform Faz a leitura dos pulsos simulados da roda f\u00f4nica Identifica quando a roda passa pela origem. Piscar o LED 3 da placa OLED a cada pulso da roda! Piscar os LED 1 e LED 2 da placa OLED a cada sinal de refer\u00eancia (Zero)! usar pin_toggler ! Exibe no OLED a velocidade de rota\u00e7\u00e3o m\u00e9dia da roda em rota\u00e7\u00f5es por minuto - rpm (atualizar valor ap\u00f3s uma rota\u00e7\u00e3o completa) Voc\u00eas devem utilizar um perif\u00e9rico de tempo para calcular o dT entre os pulsos e interrup\u00e7\u00e3o no pino para a leitura do sinal gerado no PD30.","title":"C"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#b-a","text":"Os pontos aqui valem apenas se o conceito C foi atingido (todos os itens!). (+1.0 conceito) Identifica quando a roda parou de girar e indicar velocidade de rota\u00e7\u00e3o: 0 rpm no LCD (+0.50 conceito) Organiza o c\u00f3digo em fun\u00e7\u00f5es: C\u00e1lculo do rpm Fun\u00e7\u00e3o para exibir o valor no LCD (+0.25 conceito) S\u00f3 exibe a velocidade uma vez por rota\u00e7\u00e3o, quando encontrado (+0.50 conceito) Utiliza m\u00e9dia m\u00f3vel para o c\u00e1lculo do rpm (+0.50 conceito) Exibe graficamente a velocidade no LCD.","title":"B/ A"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#dicas","text":"A seguir dicas para realizarem a entrega Debug Depurar \u00e9 importante e ajuda bastante, mas tomem cuidado que os rel\u00f3gios n\u00e3o param de contar quando o programa estiver em \"pause\". Terminal + printf Eu habilitei o terminal para voc\u00eas, podem usar printf !. S\u00f3 cuidado com o uso pois ele \u00e9 lento e as vezes n\u00e3o podemos perder tempo...","title":"Dicas"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#c-osciloscopio","text":"A imagem a seguir \u00e9 referente aos pulsos que s\u00e3o gerados no HIL, o tempo entre os pulsos \u00e9 de 50 ms. 50ms = 20Hz / 10 dentes = 2 rps ou 120 rpm","title":"C - Oscilosc\u00f3pio"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#c-lendo-o-sinal","text":"Voc\u00eas devem escolher um pino qualquer do uC, configurar como entrada sem pull_up ou debounce (usar PIO_DEFAULT ), configurar interrup\u00e7\u00e3o e atrelar uma fun\u00e7\u00e3o de callback. Pisque o LED3 da placa OLED a cada pulso recebido, com isso sabemos que a fun\u00e7\u00e3o est\u00e1 funcionando e \u00e9 um dos itens da rubrica! Tip Usar a fun\u00e7\u00e3o pin_toggle que j\u00e1 foi definida! N\u00e3o usar IT_EDGE N\u00e3o usar debounce N\u00e3o usar PULL_UP","title":"C - Lendo o sinal"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#c-calculando-dt","text":"Utilizem o RTT para calcular o tempo entre os pulsos, reiniciando o contador a cada novo pulso. Detecta pulso e inicializa contagem de tempo L\u00ea o valor do tempo entre um pulso e outro Como indicado na figura a seguir: Info A fun\u00e7\u00e3o RTT init fornecida n\u00e3o tem o IRQ de incremento! Apenas o alarme. Se quiser fazer com o TC tamb\u00e9m da, mas ai tem que manter um contador global dos pulsos. Tip Utilize 1000 como prescale para o RTT, \u00e9 um bom valor (eu testei aqui)! Imprima no terminal sempre que obtiver um novo valor de dT, lembre de fazer a impress\u00e3o no main e n\u00e3o dentro do callback! Voc\u00eas devem obter algo como: Notem que temos um dT com valor 102 ms isso \u00e9 referente ao pulso faltante, como ilustrado a seguir: ^ ^ ^ ^ ^ | | | | | | | | | | 51 102 51 51 ms","title":"C - Calculando dT"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#c-velocidade-angular","text":"Agora com o dT voc\u00ea \u00e9 capaz de: Calcular a velocidade do disco em rps: $w = \\frac{1}{dT}$ Converta de rota\u00e7\u00f5es por segundo para rota\u00e7\u00f5es por minuto (*60) Exiba no LCD a velocidade Warning Lembre de n\u00e3o atualizar o LCD dentro de interrup\u00e7\u00e3o / callback! Tip Lembre de converter dT para segundos! Cuidado com a convers\u00e3o float/ int/ ...","title":"C - Velocidade angular"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#c-identificando-zero","text":"Para identificar o dente faltante \u00e9 necess\u00e1rio \"prevermos\" quando um pulso deveria acontecer, isso pode ser feito atrav\u00e9s do alarme do RTT que deve ser configurado utilizando como base o dT calculado do pulso anterior (ou de uma m\u00e9dia). Um cuidado que voc\u00eas devem ter \u00e9 com o valor usado no timeout do RTT, n\u00e3o usar o valor do dT com o dente estimado, usar o \u00faltimo valor v\u00e1lido . Tip Definam uma toler\u00e2ncia para o pulso, eu experimentei aqui e 20% \u00e9 um bom valor! Ou seja, o alarme para o pulso \u00e9 dT*1.2 . Podemos interpretar isso como: se passado 20% do tempo esperado para um pulso sem o recebimento do mesmo, esse slot \u00e9 do dente faltante. Lembrem de zerar o RTT quando o pulso faltante for detectado. Voc\u00eas devem obter algo como: Eu estou imprimendo um * toda vez que o pulso zero \u00e9 detectado.","title":"C - Identificando Zero"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#ab-media-movel","text":"A m\u00e9dia m\u00f3vel \u00e9 um dos filtros mais simples que existe, suavizando o sinal no tempo e removendo ru\u00eddos (n), sua ideia \u00e9 bem simples e vou explicar com um exemplo (filtro de janela 5). | sinal filtrado v y [ 1 ] = ( x [ 1 ] + 0 + 0 + 0 + 0 ) / 5 y [ 2 ] = ( x [ 2 ] + x [ 1 ] + 0 + 0 + 0 ) / 5 y [ 3 ] = ( x [ 3 ] + x [ 2 ] + x [ 1 ] + 0 + 0 ) / 5 ... y [ 5 ] = ( x [ 4 ] + x [ 3 ] + x [ 2 ] + x [ 1 ] + x [ 0 ]) / 5 y [ 6 ] = ( x [ 5 ] + x [ 4 ] + x [ 3 ] + x [ 2 ] + x [ 1 ]) / 5 / / ---------------------> shift Novo dado Implemente o filtro em C e use para exibir o valor. Info Existe uma vers\u00e3o recursiva do filtro onde n\u00e3o \u00e9 necess\u00e1rio armazenar o buffer e fazer o shift.","title":"A/B - M\u00e9dia m\u00f3vel"},{"location":"navigation/Avaliacoes_e_Simulados/21b-av1/#ab-identifica-quando-a-roda-parou-de-girar-e-indicar-velocidade-de-rotacao-0-rpm-no-lcd","text":"O bot\u00e3o da placa foi configurado para iniciar a frenagem do motor, uma vez apertado os pulsos v\u00e3o se espa\u00e7ando at\u00e9 parar. Se apertar novamente os pulsos voltam a velocidade padr\u00e3o.","title":"A/B - Identifica quando a roda parou de girar e indicar velocidade de rota\u00e7\u00e3o: 0 rpm no LCD"},{"location":"navigation/Dicas/Lab-PIO-Dicas/","text":"Lab-PIO-Dicas Dicas de como lidar com a entrada e sa\u00edda (I/O) digital do microcontrolador SAME-70. Passos Antes de comecar \u00e9 necess\u00e1rio: Definir a dire\u00e7\u00e3o do pino e propriedades Entrada ou Sa\u00edda? Precisa de Pullup? e pullDown ? Identificar o pino e seu PIO ex: PC18 Extrair para o firmware esses dados #define Ativar no PMC o PIO que controla o pino: pmc_enable_periph_clk(ID_PIOA) Configurar PIO para gerenciar pino no modo correto pio_output() pio_input() Agir/ ler o pino pio_set() / pio_clear() pio_get() N\u00e3o consigo ler uma entrada Est\u00e1 com problema em ler uma entrada? Siga os seguintes passos de debug: Verifique se o pino que est\u00e1 tentando ler \u00e9 o correto. Muitas vezes decidimos por ler um pino mas acabamos por ligar o sinal que desejamos ler no lugar errado. Verifique se passou as informa\u00e7\u00f5es corretas para o c\u00f3digo (PIO/ PIO_ID/ M\u00e1scara) est\u00e3o corretas? Voc\u00ea est\u00e1 executando em um c\u00f3digo que funciona? Pegue um c\u00f3digo bem simples apenas para testar o pino, s\u00f3 quando funcionar incorpore o mesmo no seu projeto. Pode ser algum problema na conex\u00e3o. Remova qualquer conex\u00e3o do pino e ligue um jumper a ele. Conecte esse jumper ao gnd da placa. Execute o firmware e voc\u00ea deve ler 0, agora conecte o pino ao 3,3 da placa e voc\u00ea deve ler 1 . O sinal que voc\u00ea pretende ler precisa de pull-up / pull-down ? O pino pode estar queimado (essas coisas acontecem), mude de pino e teste novamente. Voc\u00ea est\u00e1 executando em um c\u00f3digo que funciona? Pegue um c\u00f3digo bem simples apenas para testar o pino, s\u00f3 quando funcionar incorpore o mesmo no seu projeto (est\u00e1 repetido para garantir que voc\u00ea leu). Estrutura de c\u00f3digo A seguinte estrutura \u00e9 utilizado para acionarmos um pino desse microcontrolador: Biblioteca ASF Todas as func\u00f5es que controlam o PIO est\u00e3o documentadas em: http://asf.atmel.com/docs/latest/same70/html/group__sam__drivers__pio__group.html Perif\u00e9rico ID (ul_id) O ID do PIO (ou de qualquer outro perif\u00e9rico) \u00e9 um n\u00famero inteiro \u00fanico que identifica o perif\u00e9rico. Esse valor pode ser extra\u00eddo do manual do microcontrolador (sec\u00e7\u00e3o 13), ou utilizando o valor j\u00e1 definido no arquivo .h de configura\u00e7\u00e3o do uC. Exemplo: #define LED_PIO_ID ID_PIOC // PIOC possui ID 12 Podemos usar o ID que j\u00e1 foi definido no arquivo .h : #define LED_PIO_ID ID_PIOC Sendo esse segundo m\u00e9todo mais aconselh\u00e1vel pois possibilita maior portabilidad do c\u00f3digo. M\u00e1scara (ul_mask) A m\u00e1scara \u00e9 utilizada para configurarmos apenas alguns bits espec\u00edficos. Vamos considerar o exemplo do LED do kit SAME70-XPLD: #define LED_PIO_IDX 8u // ID do LED no PIO #define LED_PIO_IDX_MASK (1u << LED_PIO_IDX) // Mascara para CONTROLARMOS o LED Podemos ler a linha que define o LED_PIO_IDX_MASK como: pegue o valor em bin\u00e1rio 1 ( 0000 0000 0000 0001 ) e desloque (todos os bits) oito casas para direita: 1u = 0000 0000 0000 0001 <--- LED_PIO_IDX vezes (8x) resultando: LED_PIO_IDX_MASK = 0000 0001 0000 0000 ^ | | Apenas esse bit est\u00e1 'ativado' nosso uC \u00e9 de 32 bits, nesse exemplo estamos exibindo apenas 16 bits. p_pio","title":"Dicas"},{"location":"navigation/Dicas/Lab-PIO-Dicas/#lab-pio-dicas","text":"Dicas de como lidar com a entrada e sa\u00edda (I/O) digital do microcontrolador SAME-70.","title":"Lab-PIO-Dicas"},{"location":"navigation/Dicas/Lab-PIO-Dicas/#passos","text":"Antes de comecar \u00e9 necess\u00e1rio: Definir a dire\u00e7\u00e3o do pino e propriedades Entrada ou Sa\u00edda? Precisa de Pullup? e pullDown ? Identificar o pino e seu PIO ex: PC18 Extrair para o firmware esses dados #define Ativar no PMC o PIO que controla o pino: pmc_enable_periph_clk(ID_PIOA) Configurar PIO para gerenciar pino no modo correto pio_output() pio_input() Agir/ ler o pino pio_set() / pio_clear() pio_get()","title":"Passos"},{"location":"navigation/Dicas/Lab-PIO-Dicas/#nao-consigo-ler-uma-entrada","text":"Est\u00e1 com problema em ler uma entrada? Siga os seguintes passos de debug: Verifique se o pino que est\u00e1 tentando ler \u00e9 o correto. Muitas vezes decidimos por ler um pino mas acabamos por ligar o sinal que desejamos ler no lugar errado. Verifique se passou as informa\u00e7\u00f5es corretas para o c\u00f3digo (PIO/ PIO_ID/ M\u00e1scara) est\u00e3o corretas? Voc\u00ea est\u00e1 executando em um c\u00f3digo que funciona? Pegue um c\u00f3digo bem simples apenas para testar o pino, s\u00f3 quando funcionar incorpore o mesmo no seu projeto. Pode ser algum problema na conex\u00e3o. Remova qualquer conex\u00e3o do pino e ligue um jumper a ele. Conecte esse jumper ao gnd da placa. Execute o firmware e voc\u00ea deve ler 0, agora conecte o pino ao 3,3 da placa e voc\u00ea deve ler 1 . O sinal que voc\u00ea pretende ler precisa de pull-up / pull-down ? O pino pode estar queimado (essas coisas acontecem), mude de pino e teste novamente. Voc\u00ea est\u00e1 executando em um c\u00f3digo que funciona? Pegue um c\u00f3digo bem simples apenas para testar o pino, s\u00f3 quando funcionar incorpore o mesmo no seu projeto (est\u00e1 repetido para garantir que voc\u00ea leu).","title":"N\u00e3o consigo ler uma entrada"},{"location":"navigation/Dicas/Lab-PIO-Dicas/#estrutura-de-codigo","text":"A seguinte estrutura \u00e9 utilizado para acionarmos um pino desse microcontrolador:","title":"Estrutura de c\u00f3digo"},{"location":"navigation/Dicas/Lab-PIO-Dicas/#biblioteca-asf","text":"Todas as func\u00f5es que controlam o PIO est\u00e3o documentadas em: http://asf.atmel.com/docs/latest/same70/html/group__sam__drivers__pio__group.html","title":"Biblioteca ASF"},{"location":"navigation/Dicas/Lab-PIO-Dicas/#periferico-id-ul_id","text":"O ID do PIO (ou de qualquer outro perif\u00e9rico) \u00e9 um n\u00famero inteiro \u00fanico que identifica o perif\u00e9rico. Esse valor pode ser extra\u00eddo do manual do microcontrolador (sec\u00e7\u00e3o 13), ou utilizando o valor j\u00e1 definido no arquivo .h de configura\u00e7\u00e3o do uC. Exemplo: #define LED_PIO_ID ID_PIOC // PIOC possui ID 12 Podemos usar o ID que j\u00e1 foi definido no arquivo .h : #define LED_PIO_ID ID_PIOC Sendo esse segundo m\u00e9todo mais aconselh\u00e1vel pois possibilita maior portabilidad do c\u00f3digo.","title":"Perif\u00e9rico ID (ul_id)"},{"location":"navigation/Dicas/Lab-PIO-Dicas/#mascara-ul_mask","text":"A m\u00e1scara \u00e9 utilizada para configurarmos apenas alguns bits espec\u00edficos. Vamos considerar o exemplo do LED do kit SAME70-XPLD: #define LED_PIO_IDX 8u // ID do LED no PIO #define LED_PIO_IDX_MASK (1u << LED_PIO_IDX) // Mascara para CONTROLARMOS o LED Podemos ler a linha que define o LED_PIO_IDX_MASK como: pegue o valor em bin\u00e1rio 1 ( 0000 0000 0000 0001 ) e desloque (todos os bits) oito casas para direita: 1u = 0000 0000 0000 0001 <--- LED_PIO_IDX vezes (8x) resultando: LED_PIO_IDX_MASK = 0000 0001 0000 0000 ^ | | Apenas esse bit est\u00e1 'ativado' nosso uC \u00e9 de 32 bits, nesse exemplo estamos exibindo apenas 16 bits.","title":"M\u00e1scara (ul_mask)"},{"location":"navigation/Dicas/Lab-PIO-Dicas/#p_pio","text":"","title":"p_pio"},{"location":"navigation/Dicas/Util-FloatPrint/","text":"Float Print (Atmel Studio) Configura\u00e7\u00f5es necess\u00e1rias para executar o c\u00f3digo printf(\"%f\",var) na IDE Atmel Studio V\u00e1 na janela Solution Explorer e clique com o bot\u00e3o direito no seu Project Properties e depois clique em Properties V\u00e1 na aba Toolchain e clique na op\u00e7\u00e3o Symbols dentro de ARM/GNU C Compiler Selecione o define printf=iprintf e clique na op\u00e7\u00e3o Delete Item Basta compilar seu c\u00f3digo novamente que o comando printf(\"%f\",var) ir\u00e1 funcionar.","title":"Float Print (Atmel Studio)"},{"location":"navigation/Dicas/Util-FloatPrint/#float-print-atmel-studio","text":"Configura\u00e7\u00f5es necess\u00e1rias para executar o c\u00f3digo printf(\"%f\",var) na IDE Atmel Studio V\u00e1 na janela Solution Explorer e clique com o bot\u00e3o direito no seu Project Properties e depois clique em Properties V\u00e1 na aba Toolchain e clique na op\u00e7\u00e3o Symbols dentro de ARM/GNU C Compiler Selecione o define printf=iprintf e clique na op\u00e7\u00e3o Delete Item Basta compilar seu c\u00f3digo novamente que o comando printf(\"%f\",var) ir\u00e1 funcionar.","title":"Float Print (Atmel Studio)"},{"location":"navigation/Dicas/Util-freertos/","text":"Freertos Resumo dos principais recursos do freertos utilizados no curso de computa\u00e7\u00e3o embarcada. Refer\u00eancia extra consultar a API do freeRtos: https://www.freertos.org/a00106.html Dicas gerais Fa\u00e7a o c\u00f3digo por partes e DEBUG!! N\u00e3o tente implementar tudo de uma \u00fanica vez. Leia a documenta\u00e7\u00e3o!! Antes de \"sair fazendo\" desenho no papel um diagrama do que pretende implementar. Interrup\u00e7\u00e3o Toda interrup\u00e7\u00e3o de HW deve interagir com as tarefas via um dos recursos do RTOS (sem\u00e1foro, fila, ...) Todo recurso que for usado na interrup\u00e7\u00e3o (sem\u00e1foro, fila) deve ser iniciado antes do uso! Para interagir com o freeRTOS da interrup\u00e7\u00e3o, voc\u00ea deve usar as funcoes especificas que possuem FromISR . Criando uma tarefa M\u00e9todo de como indicamos ao freertos de que uma tarefa deve ser criada (alocar mem\u00f3ria, alocar no escalonador, ...). API: https://www.freertos.org/a00019.html Para criarmos uma tarefa \u00e9 necess\u00e1rio: Criar uma fun\u00e7\u00e3o que ser\u00e1 a task Essa fun\u00e7\u00e3o n\u00e3o deve retornar while(1) Chamar a fun\u00e7\u00e3o xTaskCreate C\u00f3digo exemplo: static void task_led ( void * pvParameters ){ for (;;) { LED_Toggle ( LED0 ); vTaskDelay ( 300 ); } } void main ( void ){ // ---- hiden code block ---- // if ( xTaskCreate ( task_led , \"Led\" , 1024 , NULL , 0 , NULL ) != pdPASS ) { printf ( \"Failed to create test led task \\r\\n \" ); } } xTaskCreate BaseType_t xTaskCreate(TaskFunction_t pvTaskCode, const char * const pcName configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); par0: ponteiro para a fun\u00e7\u00e3o que ser\u00e1 uma task par1: uma string para nomear a task par2: tamanho da stack reservado para a task par3: se desejar passar alguma informa\u00e7\u00e3o na cria\u00e7\u00e3o da task par4: prioridade par5: um handler da tarefa, normalmente NULL vTaskDelay \u00c9 uma fun\u00e7\u00e3o de delay do pr\u00f3prio RTOS que faz a tarefa em quest\u00e3o entrar em estado bloqueada , ou seja, n\u00e3o ser\u00e1 chamada pelo escalonador do sistema operacional. API: https://www.freertos.org/a00127.html void vTaskDelay ( const TickType_t xTicksToDelay ); Esse m\u00e9todo possui avantagem de 'n\u00e3o ocupar' processamento do CORE. O tempo especificado para a fun\u00e7\u00e3o \u00e9 a quantidade em ticks na qual a task ficara bloqueada. DOC: https://freertos.org/RTOS-software-timer.html API: https://www.freertos.org/a00127.html C\u00f3digo exemplo: void vTaskFunction ( void * pvParameters ){ // inicializa LED1 init_led1 (); /* Block for 500ms. */ const TickType_t xDelay = 500 / portTICK_PERIOD_MS ; for ( ;; ){ /* Simply toggle the LED every 500ms, blocking between each toggle. */ vToggleLED (); vTaskDelay ( xDelay ); } } Tip const TickType_t xDelay = 500 / portTICK_PERIOD_MS; converte ticks para ms. Software Timer Rel\u00f3gios de software s\u00e3o fun\u00e7\u00f5es de callbacks que s\u00e3o executados pelo RTOS, os callbacks podem ser executados de forma recorrente ou uma \u00fanica vez (quando o tempo tiver passado). API: https://www.freertos.org/FreeRTOS-Software-Timer-API-Functions.html Para usarmos um timer de software \u00e9 necess\u00e1rio: Criar a vari\u00e1vel global que representar\u00e1 o timer TimerHandle_t xTimer Criar a fun\u00e7\u00e3o de callback : void vTimerCallback(TimerHandle_t xTimer) { ... } Na task, criar o timer: xTimer = xTimerCreate(\"Timer\", 100, pdTRUE, 0, vTimerCallback); E ent\u00e3o ativar o timer: xTimerStart(xTimer, 0); A fun\u00e7\u00e3o possui os seguintes argumentos: xTimerCreate(pcTimerName, xTimerPeriod, uxAutoReload, pvTimerID, pxCallbackFunction) . pcTimerName : \u00c9 um nome \u00fanico para o Timer (string). xTimerPeriod : \u00c9 o per\u00edodo em ticks que o timer vai executar. Ex: 100 executa a aproximadamente 100ms uxAutoReload : pdTRUE se o timer for recorrente e pdFALSE se for executar uma \u00fanica vez pvTimerID : N\u00e3o faco ideia.. =) pxCallbackFunction : Fun\u00e7\u00e3o que ser\u00e1 chamada quando o timer estourar. C\u00f3digo exemplo: TimerHandle_t xTimer ; void vTimerCallback ( TimerHandle_t xTimer ) { printf ( \"estourou \\n \" ); } static void task_foo ( void * pvParameters ) { xTimer = xTimerCreate ( \"Timer\" , 100 , pdTRUE , 0 , vTimerCallback ); while ( 1 ) { vtaskDelay ( 1000 ); } } Sem\u00e1foro bin\u00e1rio - Semaphore Sem\u00e1foros s\u00e3o utilizados para sincroniza\u00e7\u00e3o de tarefas, eles podem ser 'liberados' por outra tarefa ou de uma interrup\u00e7\u00e3o. Eles devem ser utilizados como substituto a flag. Descri\u00e7\u00e3o: https://www.freertos.org/Embedded-RTOS-Binary-Semaphores.html API: https://www.freertos.org/a00113.html Para criarmos e usarmos um sem\u00e1foro \u00e9 necess\u00e1rio: Criar a vari\u00e1vel global que representar\u00e1 o sem\u00e1foro SemaphoreHandle_t xSemaphore; Criar o sem\u00e1foro (na fun\u00e7\u00e3o main ) xSemaphoreCreateBinary(); Liberar o sem\u00e1foro xSemaphoreGiveFromISR(xSemaphore, 0); (se for liberado de uma ISR) xSemaphoreGive(xSemaphore); (se for liberado de outra task) Esperar pelo sem\u00e1foro xSemaphoreTake(xSemaphore, 500) C\u00f3digo exemplo: // vari\u00e1vel global que \u00e9 o endere\u00e7o // do sem\u00e1foro SemaphoreHandle_t xSemaphore ; void but_callback ( void ){ // libera sem\u00e1foro xSemaphoreGiveFromISR ( xSemaphore , 0 ); } static void task_led ( void * pvParameters ){ init_led1 (); // inicializa LED1 init_but1 (); // inicializa botao 1, com callback for (;;) { // aguarda por at\u00e9 500 ms pelo se for liberado entra no if if ( xSemaphoreTake ( xSemaphore , 500 / portTICK_PERIOD_MS ) == pdTRUE ){ LED_Toggle ( LED0 ); } } } void main ( void ) { // .... // // cria sem\u00e1foro bin\u00e1rio xSemaphore = xSemaphoreCreateBinary (); // verifica se sem\u00e1foro foi criado corretamente if ( xSemaphore == NULL ) printf ( \"falha em criar o semaforo \\n \" ); Tip O sem\u00e1foro deve ser sempre alocado antes do seu uso, caso alguma parte do firmware tente liberar o sem\u00e1foro antes dele ser criado ( xSemaphoreCreateBinary() ) o c\u00f3digo ir\u00e1 travar. Voc\u00ea deve usar fromISR SEMPRE que liberar um sem\u00e1foro de uma interrup\u00e7\u00e3o, caso contr\u00e1rio usar a fun\u00e7\u00e3o xSemaphoreGive() Fila - Queue Fila \u00e9 um recurso do freertos que permite troca de mensagens (qualquer tipo de dado) entre tarefas e entre IRQ e tarefas. Descri\u00e7\u00e3o: https://www.freertos.org/Embedded-RTOS-Queues.html API: https://freertos.org/a00018.html Para criarmos e usarmos um sem\u00e1foro \u00e9 necess\u00e1rio: Criar a vari\u00e1vel global que representar\u00e1 a fila QueueHandle_t xQueueButId; Criar a fila (na fun\u00e7\u00e3o main ) xQueueButId = xQueueCreate(32, sizeof(char) ); Ao criar a fila voc\u00ea deve informar a quantidade de itens ( 32 ) nessa fila e o tipo dos itens ( sizeof(char) ). Colocar dados na fila: xQueueSendFromISR(xQueueButId, &id, 0); (se for de uma ISR) xQueueSend(xQueueButId, &id); (se for de uma outra task) Receber dados da fila: xQueueReceive( xQueueButId, &id, ( TickType_t ) 500 ) C\u00f3digo exemplo que: Cria uma fila de chars, e cada bot\u00e3o envia para essa fila uma informa\u00e7\u00e3o referente ao seu id. Uma task fica lendo essa fila e aciona o LED referente ao ID do bot\u00e3o. // fila QueueHandle_t xQueueButId ; void but1_callback ( void ){ // envia o char `1` na fila char id = '1' ; xQueueSendFromISR ( xQueueButId , & id , 0 ); } void but2_callback ( void ){ // envia o char `2` na fila char id = '2' ; xQueueSendFromISR ( xQueueButId , & id , 0 ); } static void task_led ( void * pvParameters ){ init_led1 (); // inicializa LED1 init_but1 (); // inicializa botao 1, com callback init_but2 (); // inicializa botao 2, com callback // vari\u00e1vel local para leitura do dado da fila char id ; for (;;) { // aguarda por at\u00e9 500 ms pelo se for liberado entra no if if ( xQueueReceive ( xQueueButId , & id , ( TickType_t ) 500 )){ if ( id == '1' ) pin_toggle ( LED1_PIO , LED1_PIO_IDX_MASK ); else if ( id == '2' ) pin_toggle ( LED2_PIO , LED2_PIO_IDX_MASK ); } } } void main ( void ) { // .... // // cria fila de 32 slots de char xQueueButId = xQueueCreate ( 32 , sizeof ( char ) ); // verifica se fila foi criada corretamente if ( xQueueButId == NULL ) printf ( \"falha em criar a fila \\n \" ); }","title":"Freertos"},{"location":"navigation/Dicas/Util-freertos/#freertos","text":"Resumo dos principais recursos do freertos utilizados no curso de computa\u00e7\u00e3o embarcada. Refer\u00eancia extra consultar a API do freeRtos: https://www.freertos.org/a00106.html","title":"Freertos"},{"location":"navigation/Dicas/Util-freertos/#dicas-gerais","text":"Fa\u00e7a o c\u00f3digo por partes e DEBUG!! N\u00e3o tente implementar tudo de uma \u00fanica vez. Leia a documenta\u00e7\u00e3o!! Antes de \"sair fazendo\" desenho no papel um diagrama do que pretende implementar.","title":"Dicas gerais"},{"location":"navigation/Dicas/Util-freertos/#interrupcao","text":"Toda interrup\u00e7\u00e3o de HW deve interagir com as tarefas via um dos recursos do RTOS (sem\u00e1foro, fila, ...) Todo recurso que for usado na interrup\u00e7\u00e3o (sem\u00e1foro, fila) deve ser iniciado antes do uso! Para interagir com o freeRTOS da interrup\u00e7\u00e3o, voc\u00ea deve usar as funcoes especificas que possuem FromISR .","title":"Interrup\u00e7\u00e3o"},{"location":"navigation/Dicas/Util-freertos/#criando-uma-tarefa","text":"M\u00e9todo de como indicamos ao freertos de que uma tarefa deve ser criada (alocar mem\u00f3ria, alocar no escalonador, ...). API: https://www.freertos.org/a00019.html Para criarmos uma tarefa \u00e9 necess\u00e1rio: Criar uma fun\u00e7\u00e3o que ser\u00e1 a task Essa fun\u00e7\u00e3o n\u00e3o deve retornar while(1) Chamar a fun\u00e7\u00e3o xTaskCreate C\u00f3digo exemplo: static void task_led ( void * pvParameters ){ for (;;) { LED_Toggle ( LED0 ); vTaskDelay ( 300 ); } } void main ( void ){ // ---- hiden code block ---- // if ( xTaskCreate ( task_led , \"Led\" , 1024 , NULL , 0 , NULL ) != pdPASS ) { printf ( \"Failed to create test led task \\r\\n \" ); } } xTaskCreate BaseType_t xTaskCreate(TaskFunction_t pvTaskCode, const char * const pcName configSTACK_DEPTH_TYPE usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pxCreatedTask ); par0: ponteiro para a fun\u00e7\u00e3o que ser\u00e1 uma task par1: uma string para nomear a task par2: tamanho da stack reservado para a task par3: se desejar passar alguma informa\u00e7\u00e3o na cria\u00e7\u00e3o da task par4: prioridade par5: um handler da tarefa, normalmente NULL","title":"Criando uma tarefa"},{"location":"navigation/Dicas/Util-freertos/#vtaskdelay","text":"\u00c9 uma fun\u00e7\u00e3o de delay do pr\u00f3prio RTOS que faz a tarefa em quest\u00e3o entrar em estado bloqueada , ou seja, n\u00e3o ser\u00e1 chamada pelo escalonador do sistema operacional. API: https://www.freertos.org/a00127.html void vTaskDelay ( const TickType_t xTicksToDelay ); Esse m\u00e9todo possui avantagem de 'n\u00e3o ocupar' processamento do CORE. O tempo especificado para a fun\u00e7\u00e3o \u00e9 a quantidade em ticks na qual a task ficara bloqueada. DOC: https://freertos.org/RTOS-software-timer.html API: https://www.freertos.org/a00127.html C\u00f3digo exemplo: void vTaskFunction ( void * pvParameters ){ // inicializa LED1 init_led1 (); /* Block for 500ms. */ const TickType_t xDelay = 500 / portTICK_PERIOD_MS ; for ( ;; ){ /* Simply toggle the LED every 500ms, blocking between each toggle. */ vToggleLED (); vTaskDelay ( xDelay ); } } Tip const TickType_t xDelay = 500 / portTICK_PERIOD_MS; converte ticks para ms.","title":"vTaskDelay"},{"location":"navigation/Dicas/Util-freertos/#software-timer","text":"Rel\u00f3gios de software s\u00e3o fun\u00e7\u00f5es de callbacks que s\u00e3o executados pelo RTOS, os callbacks podem ser executados de forma recorrente ou uma \u00fanica vez (quando o tempo tiver passado). API: https://www.freertos.org/FreeRTOS-Software-Timer-API-Functions.html Para usarmos um timer de software \u00e9 necess\u00e1rio: Criar a vari\u00e1vel global que representar\u00e1 o timer TimerHandle_t xTimer Criar a fun\u00e7\u00e3o de callback : void vTimerCallback(TimerHandle_t xTimer) { ... } Na task, criar o timer: xTimer = xTimerCreate(\"Timer\", 100, pdTRUE, 0, vTimerCallback); E ent\u00e3o ativar o timer: xTimerStart(xTimer, 0); A fun\u00e7\u00e3o possui os seguintes argumentos: xTimerCreate(pcTimerName, xTimerPeriod, uxAutoReload, pvTimerID, pxCallbackFunction) . pcTimerName : \u00c9 um nome \u00fanico para o Timer (string). xTimerPeriod : \u00c9 o per\u00edodo em ticks que o timer vai executar. Ex: 100 executa a aproximadamente 100ms uxAutoReload : pdTRUE se o timer for recorrente e pdFALSE se for executar uma \u00fanica vez pvTimerID : N\u00e3o faco ideia.. =) pxCallbackFunction : Fun\u00e7\u00e3o que ser\u00e1 chamada quando o timer estourar. C\u00f3digo exemplo: TimerHandle_t xTimer ; void vTimerCallback ( TimerHandle_t xTimer ) { printf ( \"estourou \\n \" ); } static void task_foo ( void * pvParameters ) { xTimer = xTimerCreate ( \"Timer\" , 100 , pdTRUE , 0 , vTimerCallback ); while ( 1 ) { vtaskDelay ( 1000 ); } }","title":"Software Timer"},{"location":"navigation/Dicas/Util-freertos/#semaforo-binario-semaphore","text":"Sem\u00e1foros s\u00e3o utilizados para sincroniza\u00e7\u00e3o de tarefas, eles podem ser 'liberados' por outra tarefa ou de uma interrup\u00e7\u00e3o. Eles devem ser utilizados como substituto a flag. Descri\u00e7\u00e3o: https://www.freertos.org/Embedded-RTOS-Binary-Semaphores.html API: https://www.freertos.org/a00113.html Para criarmos e usarmos um sem\u00e1foro \u00e9 necess\u00e1rio: Criar a vari\u00e1vel global que representar\u00e1 o sem\u00e1foro SemaphoreHandle_t xSemaphore; Criar o sem\u00e1foro (na fun\u00e7\u00e3o main ) xSemaphoreCreateBinary(); Liberar o sem\u00e1foro xSemaphoreGiveFromISR(xSemaphore, 0); (se for liberado de uma ISR) xSemaphoreGive(xSemaphore); (se for liberado de outra task) Esperar pelo sem\u00e1foro xSemaphoreTake(xSemaphore, 500) C\u00f3digo exemplo: // vari\u00e1vel global que \u00e9 o endere\u00e7o // do sem\u00e1foro SemaphoreHandle_t xSemaphore ; void but_callback ( void ){ // libera sem\u00e1foro xSemaphoreGiveFromISR ( xSemaphore , 0 ); } static void task_led ( void * pvParameters ){ init_led1 (); // inicializa LED1 init_but1 (); // inicializa botao 1, com callback for (;;) { // aguarda por at\u00e9 500 ms pelo se for liberado entra no if if ( xSemaphoreTake ( xSemaphore , 500 / portTICK_PERIOD_MS ) == pdTRUE ){ LED_Toggle ( LED0 ); } } } void main ( void ) { // .... // // cria sem\u00e1foro bin\u00e1rio xSemaphore = xSemaphoreCreateBinary (); // verifica se sem\u00e1foro foi criado corretamente if ( xSemaphore == NULL ) printf ( \"falha em criar o semaforo \\n \" ); Tip O sem\u00e1foro deve ser sempre alocado antes do seu uso, caso alguma parte do firmware tente liberar o sem\u00e1foro antes dele ser criado ( xSemaphoreCreateBinary() ) o c\u00f3digo ir\u00e1 travar. Voc\u00ea deve usar fromISR SEMPRE que liberar um sem\u00e1foro de uma interrup\u00e7\u00e3o, caso contr\u00e1rio usar a fun\u00e7\u00e3o xSemaphoreGive()","title":"Sem\u00e1foro bin\u00e1rio - Semaphore"},{"location":"navigation/Dicas/Util-freertos/#fila-queue","text":"Fila \u00e9 um recurso do freertos que permite troca de mensagens (qualquer tipo de dado) entre tarefas e entre IRQ e tarefas. Descri\u00e7\u00e3o: https://www.freertos.org/Embedded-RTOS-Queues.html API: https://freertos.org/a00018.html Para criarmos e usarmos um sem\u00e1foro \u00e9 necess\u00e1rio: Criar a vari\u00e1vel global que representar\u00e1 a fila QueueHandle_t xQueueButId; Criar a fila (na fun\u00e7\u00e3o main ) xQueueButId = xQueueCreate(32, sizeof(char) ); Ao criar a fila voc\u00ea deve informar a quantidade de itens ( 32 ) nessa fila e o tipo dos itens ( sizeof(char) ). Colocar dados na fila: xQueueSendFromISR(xQueueButId, &id, 0); (se for de uma ISR) xQueueSend(xQueueButId, &id); (se for de uma outra task) Receber dados da fila: xQueueReceive( xQueueButId, &id, ( TickType_t ) 500 ) C\u00f3digo exemplo que: Cria uma fila de chars, e cada bot\u00e3o envia para essa fila uma informa\u00e7\u00e3o referente ao seu id. Uma task fica lendo essa fila e aciona o LED referente ao ID do bot\u00e3o. // fila QueueHandle_t xQueueButId ; void but1_callback ( void ){ // envia o char `1` na fila char id = '1' ; xQueueSendFromISR ( xQueueButId , & id , 0 ); } void but2_callback ( void ){ // envia o char `2` na fila char id = '2' ; xQueueSendFromISR ( xQueueButId , & id , 0 ); } static void task_led ( void * pvParameters ){ init_led1 (); // inicializa LED1 init_but1 (); // inicializa botao 1, com callback init_but2 (); // inicializa botao 2, com callback // vari\u00e1vel local para leitura do dado da fila char id ; for (;;) { // aguarda por at\u00e9 500 ms pelo se for liberado entra no if if ( xQueueReceive ( xQueueButId , & id , ( TickType_t ) 500 )){ if ( id == '1' ) pin_toggle ( LED1_PIO , LED1_PIO_IDX_MASK ); else if ( id == '2' ) pin_toggle ( LED2_PIO , LED2_PIO_IDX_MASK ); } } } void main ( void ) { // .... // // cria fila de 32 slots de char xQueueButId = xQueueCreate ( 32 , sizeof ( char ) ); // verifica se fila foi criada corretamente if ( xQueueButId == NULL ) printf ( \"falha em criar a fila \\n \" ); }","title":"Fila - Queue"},{"location":"navigation/Dicas/Util-lcd/","text":"LCD max Touch Dicas para usar o LCD maxTouch. Orienta\u00e7\u00e3o Podemos fazer o LCD ser orientando na vertical (portrait) ou horizontal (landscape), para isso, basta seguir o roteiro a seguir: portrait static void configure_lcd ( void ){ /* Initialize display parameter */ g_ili9488_display_opt . ul_width = ILI9488_LCD_WIDTH ; g_ili9488_display_opt . ul_height = ILI9488_LCD_HEIGHT ; g_ili9488_display_opt . foreground_color = COLOR_CONVERT ( COLOR_WHITE ); g_ili9488_display_opt . background_color = COLOR_CONVERT ( COLOR_WHITE ); /* Initialize LCD */ ili9488_init ( & g_ili9488_display_opt ); } landscape static void configure_lcd ( void ){ /* Initialize display parameter */ g_ili9488_display_opt . ul_width = ILI9488_LCD_WIDTH ; g_ili9488_display_opt . ul_height = ILI9488_LCD_HEIGHT ; g_ili9488_display_opt . foreground_color = COLOR_CONVERT ( COLOR_WHITE ); g_ili9488_display_opt . background_color = COLOR_CONVERT ( COLOR_WHITE ); /* Initialize LCD */ ili9488_init ( & g_ili9488_display_opt ); ili9488_set_display_direction ( PORTRAIT ); } Alterar o arquivo ili9488.h os defines de WIDTH e HEIGTH : /* ILI9488 screen size */ #define ILI9488_LCD_WIDTH 480 #define ILI9488_LCD_HEIGHT 320 Altere na task_mxt como o touch \u00e9 gerencido: if ( first == 0 ){ * x = ILI9488_LCD_WIDTH - ILI9488_LCD_WIDTH * touch_event . x / 4096 ; * y = ILI9488_LCD_HEIGHT - ILI9488_LCD_HEIGHT * touch_event . y / 4096 ; first = 1 ; } Note Note que na chamada da func\u00e3o estamos trocando, quando queremos landscape chamamos por PORTRAIT , isso se d\u00e1 por um erro em um enumarete fornecido pelo driver do LCD, no arquivo ili9488.h : enum ili9488_display_direction { LANDSCAPE = 0 , PORTRAIT = 1 };","title":"LCD max Touch"},{"location":"navigation/Dicas/Util-lcd/#lcd-max-touch","text":"Dicas para usar o LCD maxTouch.","title":"LCD max Touch"},{"location":"navigation/Dicas/Util-lcd/#orientacao","text":"Podemos fazer o LCD ser orientando na vertical (portrait) ou horizontal (landscape), para isso, basta seguir o roteiro a seguir: portrait static void configure_lcd ( void ){ /* Initialize display parameter */ g_ili9488_display_opt . ul_width = ILI9488_LCD_WIDTH ; g_ili9488_display_opt . ul_height = ILI9488_LCD_HEIGHT ; g_ili9488_display_opt . foreground_color = COLOR_CONVERT ( COLOR_WHITE ); g_ili9488_display_opt . background_color = COLOR_CONVERT ( COLOR_WHITE ); /* Initialize LCD */ ili9488_init ( & g_ili9488_display_opt ); } landscape static void configure_lcd ( void ){ /* Initialize display parameter */ g_ili9488_display_opt . ul_width = ILI9488_LCD_WIDTH ; g_ili9488_display_opt . ul_height = ILI9488_LCD_HEIGHT ; g_ili9488_display_opt . foreground_color = COLOR_CONVERT ( COLOR_WHITE ); g_ili9488_display_opt . background_color = COLOR_CONVERT ( COLOR_WHITE ); /* Initialize LCD */ ili9488_init ( & g_ili9488_display_opt ); ili9488_set_display_direction ( PORTRAIT ); } Alterar o arquivo ili9488.h os defines de WIDTH e HEIGTH : /* ILI9488 screen size */ #define ILI9488_LCD_WIDTH 480 #define ILI9488_LCD_HEIGHT 320 Altere na task_mxt como o touch \u00e9 gerencido: if ( first == 0 ){ * x = ILI9488_LCD_WIDTH - ILI9488_LCD_WIDTH * touch_event . x / 4096 ; * y = ILI9488_LCD_HEIGHT - ILI9488_LCD_HEIGHT * touch_event . y / 4096 ; first = 1 ; } Note Note que na chamada da func\u00e3o estamos trocando, quando queremos landscape chamamos por PORTRAIT , isso se d\u00e1 por um erro em um enumarete fornecido pelo driver do LCD, no arquivo ili9488.h : enum ili9488_display_direction { LANDSCAPE = 0 , PORTRAIT = 1 };","title":"Orienta\u00e7\u00e3o"},{"location":"navigation/Dicas/Util-lvgl/","text":"LVGL Dicas sobre o LVGL. https://docs.lvgl.io/latest/en/html/widgets/index.html Dicas gerais Dicas gerais sobre o lvgl. float Para poder usar o e exibir strings com float (exemplo: lv_label_set_text_fmt(dial, \"%f\", freq); ) voc\u00ea precisa editar o arquivo de configura\u00e7\u00e3o lv_conf.h do lvgl: -# define LV_SPRINTF_USE_FLOAT 0 +# define LV_SPRINTF_USE_FLOAT 1 Orienta\u00e7\u00e3o do LCD (landscape/ portrait) Para alteramos a orienta\u00e7\u00e3o do LCD de horizontal para vertical ser\u00e1 necess\u00e1rio fazermos as seguintes mudan\u00e7as no c\u00f3digo do main.c : defines /*************************************************/ /* LCD / LVGL */ /*************************************************/ - #define LV_HOR_RES_MAX (320) - #define LV_VER_RES_MAX (240) + #define LV_HOR_RES_MAX (240) + #define LV_VER_RES_MAX (320) Leitura do Touch void my_input_read(lv_indev_drv_t * drv, lv_indev_data_t*data) { ... ... - data->point.x = px; - data->point.y = py; + data->point.x = py; + data->point.y = 320 - px; } Driver do LCD int main(void) { .... .... /* LCd, touch and lvgl init*/ configure_lcd(); + ili9341_set_orientation(ILI9341_FLIP_Y | ILI9341_SWITCH_XY); ... } Tip Com isso o LCD passa a ter as dimens\u00f5es 240x320 e para o LVGL n\u00e3o existe diferen\u00e7a nenhuma. Desativando scroll Se por algum motivo na sua tela estiver aparecendo uma barra de scroll e voc\u00ea n\u00e3o quer isso, tente o seguinte comando: lv_obj_clear_flag ( lv_scr_act (), LV_OBJ_FLAG_SCROLLABLE ); A ideia do comando Mudando a cor do fundo Para mudarmos a cor do background basta alterarmos a cor do background da tela principal: // configura um fundo vermelho. lv_obj_t * screen = lv_scr_act (); lv_obj_set_style_bg_color ( screen , lv_palette_main ( LV_PALETTE_RED ), LV_PART_MAIN ); Cores Para criar ou usar uma cor consulte: https://docs.lvgl.io/master/overview/color.html#palette Multiplas telas No LVGL podemos criar multiplas telas e associar ao mesmo display, as telas podem ser exibidas conforme necess\u00e1rio. Os widgets s\u00e3o associados a uma tela, ent\u00e3o quando a tela em quest\u00e3o for exibida apenas os widgets associados a ela ser\u00e3o ativados. Criando as telas: // declarar a tela como global e est\u00e1tica static lv_obj_t * scr1 ; // screen 1 static lv_obj_t * scr2 ; // screen 2 static void task_lcd ( void * pvParameters ) { // Criando duas telas scr1 = lv_obj_create ( NULL ); scr2 = lv_obj_create ( NULL ); // .... } Associando widgets Para dizer em qual tela os widgets ser\u00e3o associados, basta substituir o lv_scr_act() usado na cria\u00e7\u00e3o dos widgets pela tela em quest\u00e3o: - lv_obj_t * btn1 = lv_btn_create(lv_scr_act()); + lv_obj_t * btn1 = lv_btn_create(scr1); // botao criado na primeira tela Exibindo Para exibir uma das telas use a fun\u00e7\u00e3o lv_scr_load(lv_obj_t * scr) como demonstrado a seguir: static void task_update ( void * pvParameters ) { for (;;) { lv_scr_load ( scr1 ); // exibe tela 1 vTaskDelay ( 500 ); lv_scr_load ( scr2 ); // exibe tela 2 vTaskDelay ( 500 ); } } Tip Voc\u00ea pode modificar as fun\u00e7\u00f5es que criam os widgets na tela para receber como parametro o screen associado a eles: - void lv_ex_btn_1(void) { + void create_scr(lv_obj_t * screen) { lv_obj_t * label; - lv_obj_t * btn1 = lv_btn_create(lv_scr_act()); + lv_obj_t * btn1 = lv_btn_create(screen); lv_obj_add_event_cb(btn1, event_handler, LV_EVENT_ALL, NULL); lv_obj_align(btn1, LV_ALIGN_CENTER, 0, -40); label = lv_label_create(btn1); lv_label_set_text(label, \"Corsi\"); lv_obj_center(label); - lv_obj_t * btn2 = lv_btn_create(lv_scr_act()); + lv_obj_t * btn2 = lv_btn_create(screen); lv_obj_add_event_cb(btn2, event_handler, LV_EVENT_ALL, NULL); lv_obj_align(btn2, LV_ALIGN_CENTER, 0, 40); lv_obj_add_flag(btn2, LV_OBJ_FLAG_CHECKABLE); lv_obj_set_height(btn2, LV_SIZE_CONTENT); label = lv_label_create(btn2); lv_label_set_text(label, \"Toggle\"); lv_obj_center(label); } static void task_lcd(void *pvParameters) { int px, py; + scr1 = lv_obj_create(NULL); - lv_ex_btn_1(); + create_scr(scr1); + lv_scr_load(scr1); ... } Tip Voc\u00ea pode fazer a transi\u00e7\u00e3o entre telas dado um evento de um bot\u00e3o! Tip Uma alternativa para mudar de tela utilizando efeito de scroll tente usar o widget Tile view , eu testei o exemplo do site aqui e funciona bem: https://docs.lvgl.io/master/widgets/extra/tileview.html#tileview-with-content Exibindo uma imagem Warning Esse procedimento n\u00e3o funciona com imagens no formato PNG sem fundo , a imagem precisa ter fundo, mesmo que branco. Exibindo uma imagem est\u00e1tica no LCD, sem intera\u00e7\u00e3o. Tip Se quiser usar uma imagem como bot\u00e3o utilize o widget Image button : https://docs.lvgl.io/master/widgets/extra/imgbtn.html Usar o conversor online dispon\u00edvel em https://lvgl.io/tools/imageconverter e seguir os passos: No site configurar: File names : Nome que quer dar para imagem, exemplo: img1 True Color : On Output Format : C Array Clicar em Convert e salvar o arquivo no computador (fora da pasta do projeto); Mudar a extens\u00e3o do arquivo baixo de .c para .h Abrir o arquivo e editar a primeira linha: - #include \"lvgl/lvgl.h\" + #include \"lvgl.h\" Adicionar o arquivo da imagem no projeto do MicrochipStudio (pode arrastar) No main.c incluir o .h da imagem. #include \"img1.h\" Agora basta executar as linhas de c\u00f3digo a seguir para exibir a imagem: lv_obj_t * img = lv_img_create ( lv_scr_act ()); lv_img_set_src ( img , & img1 ); lv_obj_align ( img , LV_ALIGN_CENTER , 0 , 0 ); Info Para testar, incluir as linhas na task_lcd No exemplo o nome da imagem utilizada no site foi img1 Alinhamos a imagem no centro da tela Imagem Se quiser usar um bot\u00e3o como imagem voc\u00ea pode usar o exemplo a seguir: void lv_img_button ( void ) { LV_IMG_DECLARE ( imgBtnHome ); static lv_style_t style_def ; lv_style_init ( & style_def ); /*Darken the button when pressed and make it wider*/ static lv_style_t style_pr ; lv_style_init ( & style_pr ); lv_style_set_img_recolor_opa ( & style_pr , LV_OPA_30 ); lv_style_set_img_recolor ( & style_pr , lv_color_black ()); lv_obj_t * btnPausePlay = lv_imgbtn_create ( lv_scr_act ()); lv_imgbtn_set_src ( btnPausePlay , LV_IMGBTN_STATE_RELEASED , NULL , NULL , & imgBtnHome ); lv_obj_add_style ( btnPausePlay , & style_def , 0 ); lv_obj_add_style ( btnPausePlay , & style_pr , LV_STATE_PRESSED ); lv_obj_align ( btnPausePlay , LV_ALIGN_CENTER , 0 , 0 ); } O imgBtnHome eu gerei a partir da imagem a seguir:","title":"LVGL"},{"location":"navigation/Dicas/Util-lvgl/#lvgl","text":"Dicas sobre o LVGL. https://docs.lvgl.io/latest/en/html/widgets/index.html","title":"LVGL"},{"location":"navigation/Dicas/Util-lvgl/#dicas-gerais","text":"Dicas gerais sobre o lvgl.","title":"Dicas gerais"},{"location":"navigation/Dicas/Util-lvgl/#float","text":"Para poder usar o e exibir strings com float (exemplo: lv_label_set_text_fmt(dial, \"%f\", freq); ) voc\u00ea precisa editar o arquivo de configura\u00e7\u00e3o lv_conf.h do lvgl: -# define LV_SPRINTF_USE_FLOAT 0 +# define LV_SPRINTF_USE_FLOAT 1","title":"float"},{"location":"navigation/Dicas/Util-lvgl/#orientacao-do-lcd-landscape-portrait","text":"Para alteramos a orienta\u00e7\u00e3o do LCD de horizontal para vertical ser\u00e1 necess\u00e1rio fazermos as seguintes mudan\u00e7as no c\u00f3digo do main.c : defines /*************************************************/ /* LCD / LVGL */ /*************************************************/ - #define LV_HOR_RES_MAX (320) - #define LV_VER_RES_MAX (240) + #define LV_HOR_RES_MAX (240) + #define LV_VER_RES_MAX (320) Leitura do Touch void my_input_read(lv_indev_drv_t * drv, lv_indev_data_t*data) { ... ... - data->point.x = px; - data->point.y = py; + data->point.x = py; + data->point.y = 320 - px; } Driver do LCD int main(void) { .... .... /* LCd, touch and lvgl init*/ configure_lcd(); + ili9341_set_orientation(ILI9341_FLIP_Y | ILI9341_SWITCH_XY); ... } Tip Com isso o LCD passa a ter as dimens\u00f5es 240x320 e para o LVGL n\u00e3o existe diferen\u00e7a nenhuma.","title":"Orienta\u00e7\u00e3o do LCD (landscape/ portrait)"},{"location":"navigation/Dicas/Util-lvgl/#desativando-scroll","text":"Se por algum motivo na sua tela estiver aparecendo uma barra de scroll e voc\u00ea n\u00e3o quer isso, tente o seguinte comando: lv_obj_clear_flag ( lv_scr_act (), LV_OBJ_FLAG_SCROLLABLE ); A ideia do comando","title":"Desativando scroll"},{"location":"navigation/Dicas/Util-lvgl/#mudando-a-cor-do-fundo","text":"Para mudarmos a cor do background basta alterarmos a cor do background da tela principal: // configura um fundo vermelho. lv_obj_t * screen = lv_scr_act (); lv_obj_set_style_bg_color ( screen , lv_palette_main ( LV_PALETTE_RED ), LV_PART_MAIN ); Cores Para criar ou usar uma cor consulte: https://docs.lvgl.io/master/overview/color.html#palette","title":"Mudando a cor do fundo"},{"location":"navigation/Dicas/Util-lvgl/#multiplas-telas","text":"No LVGL podemos criar multiplas telas e associar ao mesmo display, as telas podem ser exibidas conforme necess\u00e1rio. Os widgets s\u00e3o associados a uma tela, ent\u00e3o quando a tela em quest\u00e3o for exibida apenas os widgets associados a ela ser\u00e3o ativados. Criando as telas: // declarar a tela como global e est\u00e1tica static lv_obj_t * scr1 ; // screen 1 static lv_obj_t * scr2 ; // screen 2 static void task_lcd ( void * pvParameters ) { // Criando duas telas scr1 = lv_obj_create ( NULL ); scr2 = lv_obj_create ( NULL ); // .... } Associando widgets Para dizer em qual tela os widgets ser\u00e3o associados, basta substituir o lv_scr_act() usado na cria\u00e7\u00e3o dos widgets pela tela em quest\u00e3o: - lv_obj_t * btn1 = lv_btn_create(lv_scr_act()); + lv_obj_t * btn1 = lv_btn_create(scr1); // botao criado na primeira tela Exibindo Para exibir uma das telas use a fun\u00e7\u00e3o lv_scr_load(lv_obj_t * scr) como demonstrado a seguir: static void task_update ( void * pvParameters ) { for (;;) { lv_scr_load ( scr1 ); // exibe tela 1 vTaskDelay ( 500 ); lv_scr_load ( scr2 ); // exibe tela 2 vTaskDelay ( 500 ); } } Tip Voc\u00ea pode modificar as fun\u00e7\u00f5es que criam os widgets na tela para receber como parametro o screen associado a eles: - void lv_ex_btn_1(void) { + void create_scr(lv_obj_t * screen) { lv_obj_t * label; - lv_obj_t * btn1 = lv_btn_create(lv_scr_act()); + lv_obj_t * btn1 = lv_btn_create(screen); lv_obj_add_event_cb(btn1, event_handler, LV_EVENT_ALL, NULL); lv_obj_align(btn1, LV_ALIGN_CENTER, 0, -40); label = lv_label_create(btn1); lv_label_set_text(label, \"Corsi\"); lv_obj_center(label); - lv_obj_t * btn2 = lv_btn_create(lv_scr_act()); + lv_obj_t * btn2 = lv_btn_create(screen); lv_obj_add_event_cb(btn2, event_handler, LV_EVENT_ALL, NULL); lv_obj_align(btn2, LV_ALIGN_CENTER, 0, 40); lv_obj_add_flag(btn2, LV_OBJ_FLAG_CHECKABLE); lv_obj_set_height(btn2, LV_SIZE_CONTENT); label = lv_label_create(btn2); lv_label_set_text(label, \"Toggle\"); lv_obj_center(label); } static void task_lcd(void *pvParameters) { int px, py; + scr1 = lv_obj_create(NULL); - lv_ex_btn_1(); + create_scr(scr1); + lv_scr_load(scr1); ... } Tip Voc\u00ea pode fazer a transi\u00e7\u00e3o entre telas dado um evento de um bot\u00e3o! Tip Uma alternativa para mudar de tela utilizando efeito de scroll tente usar o widget Tile view , eu testei o exemplo do site aqui e funciona bem: https://docs.lvgl.io/master/widgets/extra/tileview.html#tileview-with-content","title":"Multiplas telas"},{"location":"navigation/Dicas/Util-lvgl/#exibindo-uma-imagem","text":"Warning Esse procedimento n\u00e3o funciona com imagens no formato PNG sem fundo , a imagem precisa ter fundo, mesmo que branco. Exibindo uma imagem est\u00e1tica no LCD, sem intera\u00e7\u00e3o. Tip Se quiser usar uma imagem como bot\u00e3o utilize o widget Image button : https://docs.lvgl.io/master/widgets/extra/imgbtn.html Usar o conversor online dispon\u00edvel em https://lvgl.io/tools/imageconverter e seguir os passos: No site configurar: File names : Nome que quer dar para imagem, exemplo: img1 True Color : On Output Format : C Array Clicar em Convert e salvar o arquivo no computador (fora da pasta do projeto); Mudar a extens\u00e3o do arquivo baixo de .c para .h Abrir o arquivo e editar a primeira linha: - #include \"lvgl/lvgl.h\" + #include \"lvgl.h\" Adicionar o arquivo da imagem no projeto do MicrochipStudio (pode arrastar) No main.c incluir o .h da imagem. #include \"img1.h\" Agora basta executar as linhas de c\u00f3digo a seguir para exibir a imagem: lv_obj_t * img = lv_img_create ( lv_scr_act ()); lv_img_set_src ( img , & img1 ); lv_obj_align ( img , LV_ALIGN_CENTER , 0 , 0 ); Info Para testar, incluir as linhas na task_lcd No exemplo o nome da imagem utilizada no site foi img1 Alinhamos a imagem no centro da tela","title":"Exibindo uma imagem"},{"location":"navigation/Dicas/Util-lvgl/#imagem","text":"Se quiser usar um bot\u00e3o como imagem voc\u00ea pode usar o exemplo a seguir: void lv_img_button ( void ) { LV_IMG_DECLARE ( imgBtnHome ); static lv_style_t style_def ; lv_style_init ( & style_def ); /*Darken the button when pressed and make it wider*/ static lv_style_t style_pr ; lv_style_init ( & style_pr ); lv_style_set_img_recolor_opa ( & style_pr , LV_OPA_30 ); lv_style_set_img_recolor ( & style_pr , lv_color_black ()); lv_obj_t * btnPausePlay = lv_imgbtn_create ( lv_scr_act ()); lv_imgbtn_set_src ( btnPausePlay , LV_IMGBTN_STATE_RELEASED , NULL , NULL , & imgBtnHome ); lv_obj_add_style ( btnPausePlay , & style_def , 0 ); lv_obj_add_style ( btnPausePlay , & style_pr , LV_STATE_PRESSED ); lv_obj_align ( btnPausePlay , LV_ALIGN_CENTER , 0 , 0 ); } O imgBtnHome eu gerei a partir da imagem a seguir:","title":"Imagem"},{"location":"navigation/Dicas/Util-o-que-nao-pode/","text":"\u26a1 Regras de firmware Regras de desenvolvimento de firmware para entregas de laborat\u00f3rios, aps, projetos e avalia\u00e7\u00f5es. Notem que s\u00e3o regras gerais e podem existir exce\u00e7\u00f5es, mas voc\u00ea deve pensar bem e talvez discutir com algum membro da equipe antes de querer quebrar alguma delas. Linguagem C Com grandes poderes vem grandes responsabilidades Usar vari\u00e1veis globais apenas quando estritamente necess\u00e1rias, como regra de ouro s\u00f3 \u00e9 necess\u00e1rio aquelas que s\u00e3o modificadas de dentro de uma interrup\u00e7\u00e3o. Se uma fun\u00e7\u00e3o for alterar uma vari\u00e1vel global, voc\u00ea deve passar o ponteiro da vari\u00e1vel como argumento da fun\u00e7\u00e3o. Sempre que poss\u00edvel deixe o c\u00f3digo gen\u00e9rico e sem magic numbers , utilize #define ou const . Usar inline no lugar de macros N\u00e3o implementar fun\u00e7\u00f5es dentro do .h , fazer no .c . Interrup\u00e7\u00e3o / Callback Voc\u00ea deve gastar no m\u00e1ximo algo entre 100-200 clocks dentro de uma interrup\u00e7\u00e3o. Apenas algumas linhas de c\u00f3digo em C Evitar manipular strings ( sprintf ) Evitar usar printf N\u00e3o atualizar displays (OLED/ LCD) Evite loops ( while / for ) A interrup\u00e7\u00e3o \u00e9 um evento de hardware na qual o compilador n\u00e3o tem conhecimento. Lembre de dar o ACK da interrup\u00e7\u00e3o (exe: tc_get_status ) Declare as vari\u00e1veis compartilhadas (globais) como volatile No ARM para ativar interrup\u00e7\u00e3o \u00e9 necess\u00e1rio configurar o perif\u00e9rico e o NVIC! freeRTOS Usar os recursos do sistema operacional sempre! De forma geral usar vTaskDelay no lugar de delay_ms . N\u00e3o fazer uso de flags (vari\u00e1veis globais) para indicar que um evento deve acontecer, usar um sem\u00e1foro N\u00e3o compartilhar vari\u00e1veis globais entre tasks para transmitir informa\u00e7\u00f5es, usar uma fila para isso Lembre de inicializar os recursos antes de usar ( xCreateSemaphore , xCreateQueue ). Indicamos fazer isso na fun\u00e7\u00e3o main e n\u00e3o dentro das tarefas Fontes https://betterembsw.blogspot.com/2013/03/rules-for-using-interrupts.html","title":"\u26a1 Regras de firmware"},{"location":"navigation/Dicas/Util-o-que-nao-pode/#regras-de-firmware","text":"Regras de desenvolvimento de firmware para entregas de laborat\u00f3rios, aps, projetos e avalia\u00e7\u00f5es. Notem que s\u00e3o regras gerais e podem existir exce\u00e7\u00f5es, mas voc\u00ea deve pensar bem e talvez discutir com algum membro da equipe antes de querer quebrar alguma delas.","title":"\u26a1 Regras de firmware"},{"location":"navigation/Dicas/Util-o-que-nao-pode/#linguagem-c","text":"Com grandes poderes vem grandes responsabilidades Usar vari\u00e1veis globais apenas quando estritamente necess\u00e1rias, como regra de ouro s\u00f3 \u00e9 necess\u00e1rio aquelas que s\u00e3o modificadas de dentro de uma interrup\u00e7\u00e3o. Se uma fun\u00e7\u00e3o for alterar uma vari\u00e1vel global, voc\u00ea deve passar o ponteiro da vari\u00e1vel como argumento da fun\u00e7\u00e3o. Sempre que poss\u00edvel deixe o c\u00f3digo gen\u00e9rico e sem magic numbers , utilize #define ou const . Usar inline no lugar de macros N\u00e3o implementar fun\u00e7\u00f5es dentro do .h , fazer no .c .","title":"Linguagem C"},{"location":"navigation/Dicas/Util-o-que-nao-pode/#interrupcao-callback","text":"Voc\u00ea deve gastar no m\u00e1ximo algo entre 100-200 clocks dentro de uma interrup\u00e7\u00e3o. Apenas algumas linhas de c\u00f3digo em C Evitar manipular strings ( sprintf ) Evitar usar printf N\u00e3o atualizar displays (OLED/ LCD) Evite loops ( while / for ) A interrup\u00e7\u00e3o \u00e9 um evento de hardware na qual o compilador n\u00e3o tem conhecimento. Lembre de dar o ACK da interrup\u00e7\u00e3o (exe: tc_get_status ) Declare as vari\u00e1veis compartilhadas (globais) como volatile No ARM para ativar interrup\u00e7\u00e3o \u00e9 necess\u00e1rio configurar o perif\u00e9rico e o NVIC!","title":"Interrup\u00e7\u00e3o / Callback"},{"location":"navigation/Dicas/Util-o-que-nao-pode/#freertos","text":"Usar os recursos do sistema operacional sempre! De forma geral usar vTaskDelay no lugar de delay_ms . N\u00e3o fazer uso de flags (vari\u00e1veis globais) para indicar que um evento deve acontecer, usar um sem\u00e1foro N\u00e3o compartilhar vari\u00e1veis globais entre tasks para transmitir informa\u00e7\u00f5es, usar uma fila para isso Lembre de inicializar os recursos antes de usar ( xCreateSemaphore , xCreateQueue ). Indicamos fazer isso na fun\u00e7\u00e3o main e n\u00e3o dentro das tarefas","title":"freeRTOS"},{"location":"navigation/Dicas/Util-o-que-nao-pode/#fontes","text":"https://betterembsw.blogspot.com/2013/03/rules-for-using-interrupts.html","title":"Fontes"},{"location":"navigation/Labs/Lab_ADC/Lab-ADC/","text":"Ao final do lab voc\u00ea deve ter um sistema embarcado que faz a leitura de dois valores anal\u00f3gicos: Temperatura interna do uC e Valor da resist\u00eancia de um potenci\u00f4metro, enviando esses valores para o terminal. C\u00f3digo base SAME70-Examples : SAME70-examples Perifericos-uC/ADC-Temperatura Copiar para: Pasta Labs/ADC LAB ADC: Executar c\u00f3digo exemplo ADC-Temperatura Portar exemplo para LCD Exibir temperatura no LCD Inserir timer Conectar um potenci\u00f4metro no uC Configurar um AFEC para ler o valor do potenci\u00f4metro Converter bits -> resist\u00eancia Exibir no LCD de forma gr\u00e1fica o valor da temperatura e resist\u00eancia Laborat\u00f3rio O c\u00f3digo exemplo SAME70-exemples/Perifericos-uC/ADC-Temperatura demonstra como configurar um dos ADCs (AFEC) do nosso uC para fazer uma convers\u00e3o A/D de um sensor de temperatura interno ao chip. + Copie esse exemplo para a pasta do + seu reposit\u00f3rio. Leia o README desse exemplo! + Execute o exemplo na placa! + Entenda! Programando Ao final do lab voc\u00ea deve ter um sistema embarcado que faz a leitura de dois valores anal\u00f3gicos: Temperatura interna do uC e Valor da resist\u00eancia de um potenci\u00f4metro, enviando esses valores para o terminal. A taxa de amostragem da temperatura deve ser 1Hz e do potenci\u00f4metro 10Hz. Utilize dois TC para gerar a taxa de amostragem correta. Fique o maior tempo poss\u00edvel em sleepmode . Roteiro Sugest\u00e3o de passos de implementa\u00e7\u00e3o. Leia tudo antes de sair fazendo! Vis\u00e3o do todo \u00e9 muito importante... Migre o delay_s(1) do exemplo para ser executado por um TimerCounter TC Escolha um pino que possa ser usado como anal\u00f3gico Busque no manual SAME70.pdf na sec\u00e7\u00e3o 50 referente ao AFEC Conecte um potenci\u00f4metro ao pino (pode ser um joystick) Configure o AFEC para realizar a leitura desse pino n\u00e3o esque\u00e7a do callback Insira outro TC para realizar a leitura desse ADC Escreva uma fun\u00e7\u00e3o que converta BITs -> Resist\u00eancia Formate e envie tudo pela serial Al\u00e9m? Exiba graficamente no LCD os valores anal\u00f3gicos Insira um time stamp nos dados (RTC)","title":"Lab ADC"},{"location":"navigation/Labs/Lab_ADC/Lab-ADC/#laboratorio","text":"O c\u00f3digo exemplo SAME70-exemples/Perifericos-uC/ADC-Temperatura demonstra como configurar um dos ADCs (AFEC) do nosso uC para fazer uma convers\u00e3o A/D de um sensor de temperatura interno ao chip. + Copie esse exemplo para a pasta do + seu reposit\u00f3rio. Leia o README desse exemplo! + Execute o exemplo na placa! + Entenda!","title":"Laborat\u00f3rio"},{"location":"navigation/Labs/Lab_ADC/Lab-ADC/#programando","text":"Ao final do lab voc\u00ea deve ter um sistema embarcado que faz a leitura de dois valores anal\u00f3gicos: Temperatura interna do uC e Valor da resist\u00eancia de um potenci\u00f4metro, enviando esses valores para o terminal. A taxa de amostragem da temperatura deve ser 1Hz e do potenci\u00f4metro 10Hz. Utilize dois TC para gerar a taxa de amostragem correta. Fique o maior tempo poss\u00edvel em sleepmode .","title":"Programando"},{"location":"navigation/Labs/Lab_ADC/Lab-ADC/#roteiro","text":"Sugest\u00e3o de passos de implementa\u00e7\u00e3o. Leia tudo antes de sair fazendo! Vis\u00e3o do todo \u00e9 muito importante... Migre o delay_s(1) do exemplo para ser executado por um TimerCounter TC Escolha um pino que possa ser usado como anal\u00f3gico Busque no manual SAME70.pdf na sec\u00e7\u00e3o 50 referente ao AFEC Conecte um potenci\u00f4metro ao pino (pode ser um joystick) Configure o AFEC para realizar a leitura desse pino n\u00e3o esque\u00e7a do callback Insira outro TC para realizar a leitura desse ADC Escreva uma fun\u00e7\u00e3o que converta BITs -> Resist\u00eancia Formate e envie tudo pela serial Al\u00e9m? Exiba graficamente no LCD os valores anal\u00f3gicos Insira um time stamp nos dados (RTC)","title":"Roteiro"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/","text":"Lab 8 - FIR Fonte: https://www.mathworks.com/matlabcentral/mlc-downloads/downloads/submissions/53983/versions/5/previews/html/ExampleECGBitalino.html Neste laborat\u00f3rio iremos processar o sinal de ECG que voc\u00eas precisam processar na APS2. Voc\u00eas podem e devem usar o c\u00f3digo do laborat\u00f3rio na APS. Preencher ao finalizar o lab TODO: MARCO Lab Exemplo base LAB SAME70-Examples/ TODO: CODIGO EXEMPLO Labs-8-RTOS-ADC-FIR C\u00f3digo exemplo Vamos modificar o c\u00f3digo exemplo TODO: CODIGO EXEMPLO , fa\u00e7a uma c\u00f3pia do seu lab para a nova pasta no seu reposit\u00f3rio Labs/9-RTOS-ADC-FIR Terminal Esse exemplo faz uso da comunica\u00e7\u00e3o UART para debug de c\u00f3digo (via printf), para acessar o terminal no atmel est\u00fadio clique em: View Terminal Window Configure o terminal para a porta que (COM) correta (verificar no windows) e configure para operar com um BaudRate de 115200 . Info Iremos utilizar os seguintes perif\u00e9ricos diretamente: AFEC1 (EXT1 PC31) TC1 canal 1 Indiretamente (o projeto j\u00e1 usa): DAC0 (PB13) TC0 canal 0 Conectando Vamos conectar o pino PB13 que gera o sinal o sinal anal\u00f3gico do batimento card\u00edaco ao pino PC31 do EXT1 que possui o AFEC1 conforme imagem e diagrama a baixo: Imagem TODO INSERIR IMAGEM Diagrama \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502afec \u2502\u25c4\u251c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 ecg \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 tc0 \u251c\u2500\u25ba\u2502dac \u251c\u2500x\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 PB13 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Progress Click para continuar.... ECG O sinal ECG gerado no pino PB13 possui a forma de onda a seguir: E se analisarmos o espectro do sinal via transformada de fourier, obtemos a seguinte composi\u00e7\u00e3o espectral: Question O que voc\u00ea consegue extrair de informa\u00e7\u00f5es dos gr\u00e1ficos anteriores? No primeiro (ecg no tempo) podemos ver claramente que existe uma alta frequ\u00eancia no sinal, mas que o envelope \u00e9 a informa\u00e7\u00e3o do ecg. J\u00e1 no fourier somos capazes se distinguir que existem duas regi\u00f5es com bastante informa\u00e7\u00f5es, uma de baixa frqu\u00eancia (0..25)Hz e outra de 60Hz. Progress Click para continuar.... 60 Hz Notamos claramente que existe um sinal centrada em 60Hz, isso \u00e9 muito comum quando trabalhamos com eletr\u00f4nica e reflete o 60Hz da rede el\u00e9trica que \u00e9 propagada de diversas formas para o transdutor respons\u00e1vel em amostrar o dado do pulso el\u00e9trico do corpo humano, causando um ru\u00eddo no sinal n\u00e3o desej\u00e1vel. Para trarmos o dado corretamente teremos que filtar o ru\u00eddo. Lembre que em alguns paises a frequ\u00eancia da rede el\u00e9trica \u00e9 de 50Hz e n\u00e3o de 60Hz como no Brasil. Info O som desse ru\u00eddo em 60hz \u00e9 chamado de Zumbido el\u00e9trico soa como: ref: wiki Progress Click para continuar.... Filtros digitais Filtragem de sinal pertence a uma grande \u00e1rea do conhecimento que \u00e9 processamento de sinais, nesse laborat\u00f3rio iremos tratar do tema de forma superficial. Mas exemplos de aplica\u00e7\u00e3o de filtragem digital s\u00e3o: Remo\u00e7\u00e3o de ru\u00eddo Processamento de \u00c1udio Extra\u00e7\u00e3o de par\u00e2metros ... Tip Para saber mais leia: The Scientist and Engineer's Guide to Digital Signal Processing FIR O Finite Impulse Response (FIR) \u00e9 uma t\u00e9cnica de processamento digital de sinais (DSP) que \u00e9 capaz de realizar filtragens em um sinal. Com o FIR somos capazes de aplicar um filtro do tipo: passa baixas: Elimina as altas frequ\u00eancias passa altas: Elimina as baixas frequ\u00eancias mata faixa: Elimina uma faixa de frequ\u00eancias do sinal Filtros digitais do tipo FIR possuem as seguintes vantagens: S\u00e3o est\u00e1veis por natureza (n\u00e3o importa o par\u00e2metro do filtro, o sinal de sa\u00edda vai ser est\u00e1vel) Podem ser projetados para ter fase linear Possuem flexibilidade no seu projeto S\u00e3o f\u00e1ceis de implementar O filtro possui a seguinte estrutura: $$y[n] = b_0*x[n] + b_1*x[n-1] + .... b_n*x[n-N]$$ Onde: $y[n]$: Valor filtrado $x[n-N]$: Valor do dado n\u00e3o filtrado, atrasado de N amostras $b_n$: Coeficiente do filtro $N$: Ordem do filtro Podemos representar a equa\u00e7\u00e3o graficamente: Fonte: https://en.wikipedia.org/wiki/Finite_impulse_response $Z^{-1}$: Significa um atraso na amostra Projeto do filtro Podemos realizar o projeto do filtro FIR (achar a ordem N e os coeficientes B) de diversas maneiras diferentes, cada um possui uma vantagem sobre a outra. Vamos utilizar o Equiripple Algorithm que possui ripples em torno da frequ\u00eancia de corte ( fc ). Fonte: https://www.recordingblogs.com/wiki/equiripple-filter O projeto do filtro envolve v\u00e1rios par\u00e2metros e diversas escolhas, vamos verificarmos os mais importantes: $f_s$: Frequ\u00eancia de amostragem do sinal $f_c$: Frequ\u00eancia de corte, quando a componente espectral j\u00e1 possui um ganho baixo e n\u00e3o influencia 'tanto' no sinal. Na $f_c$ o ganho do sinal \u00e9 geralmente -3dB, o que significa em volts, que o sinal possui $sqrt(\u00bd)=0.707$ do seu valor inicial. Note A filtragem n\u00e3o s\u00f3 altera o valor absoluto de um sinal, como tamb\u00e9m afeta sua frequ\u00eancia! Dependendo do que estiver analisando isso pode afetar o resultado final. Progress Click para continuar.... pyfda Para o projeto do filtro vamos utilizar uma ferramenta em python pyfda que vai nos ajudar encontrar os coeficientes b e N do filtro. Para isso siga os passos de instala\u00e7\u00e3o a seguir: git clone https://github.com/chipmuenk/pyFDA/ cd pyFDA pip3 install -r requirements.txt --user python3 -m pyfda.pyfdax Configure o filtro para: E agora clique em DESIGN FILTER . V\u00e1 na aba b,a e salve os valores de b em um txt, vamos usar mais tarde ! firmware Esse exemplo possui: task_mxt : Leitura do touch task_lcd : Para exibi\u00e7\u00e3o dos dados no LCD task_adc : Inicia um TC para fazer a convers\u00e3o do ADC, recebe o dado e envia por uma fila. TC1 : Timer configurado em 50Hz para fazer gerar o trigger da convers\u00e3o anal\u00f3gica AFEC : Para realizar a leitura do potenciometro Note Iremos usar o TC como trigger do AFEC (no lugar da task_adc fazer isso como no lab RTOS-ADC) pelos seguinte motivos: Garantir que a aquisi\u00e7\u00e3o ocorra na taxa especificada Permitir uma taxa de aquisi\u00e7\u00e3o maior que o tick do RTOS Plotando ADC no tempo Vamos modificar a task_lcd para exibir o valor da leitura do potenciometro no tempo. O resultado esperado \u00e9 o seguinte: Sorry, your browser doesn't support embedded videos. Tip Voc\u00ea deve fazer essa implementa\u00e7\u00e3o dentro do if que pega um dado da fila xQueuePlot : if ( xQueueReceive ( xQueuePlot , & ( plot ), ( TickType_t ) 100 / portTICK_PERIOD_MS )) { // aqui dentro!! } O dado que deve ser plotado \u00e9 o plot.raw Crie um contador que far\u00e1 o incremento do eixo x dica: use x = x + 5 ; Incremente esse contador at\u00e9 chegar no final do LCD ( ILI9488_LCD_WIDTH ) zere o contador quando chegar no final apague a tela quando chegar no final draw_screen() Plote um circulo no lcd para cada ponto, exemplo: ili9488_set_foreground_color ( COLOR_CONVERT ( COLOR_BLACK )); ili9488_draw_filled_circle ( x , ILI9488_LCD_HEIGHT - plot . raw / 16 , 2 ); Agora voc\u00ea deve modificar o plot, para plotar al\u00e9m do plot.raw exibir o plot.filtrado que mais para frente no lab ser\u00e1 o nosso dado do ADC filtrado com o filtro projetado anteriormente. Atualmente ele \u00e9 o valor plot.raw deslocado de 100. Tip Utilize outra cor para mostrar esse dado: ili9488_set_foreground_color ( COLOR_CONVERT ( COLOR_RED )); Resumo Tarefas Exibir o valor plot.raw graficamente no lcd Exibir o valor plot.filtrado graficamente no lcd Filtrando dado Vamos agora aplicar o filtro projetado anteriormente no dado adc , iremos utilizar uma biblioteca da ARM chamada de CMSIS DSP 4 que possui uma s\u00e9rie de fun\u00e7\u00f5es matem\u00e1ticas e de processamento de sinais. Dentro dessa biblioteca, iremos utilizar a fun\u00e7\u00e3o arm_fir_init_f32 e arm_fir_f32 que respectivamente: inicializa o filtro FIR do tipo float_32 e aplica o filtro (convolu\u00e7\u00e3o) ao sinal. Tip De uma olhada como essas fun\u00e7\u00f5es s\u00e3o implementadas, elas abusam bastante da topologia interna do ARM (bem sistema hardware software) para entregarem uma fun\u00e7\u00e3o bem otimizada: https://github.com/ARM-software/CMSIS_5/blob/9a825ef26043a0648894f5bf155edc0219b8212f/CMSIS/DSP/Source/FilteringFunctions/arm_fir_f32.c Inicializando filtro Crie os defines a seguir: #define NUM_TAPS 8 // ordem do filtro (quantos coefientes) #define BLOCK_SIZE 1 // se ser\u00e1 processado por blocos, no caso n\u00e3o. Agora vamos copiar os coeficientes do filtro que foram gerados na etapa do projeto do filtro para a vari\u00e1vel firCoeffs32 : const float32_t firCoeffs32 [ NUM_TAPS ] = { 0.12269166637219883 , 0.12466396327768503 , 0.1259892807712678 , 0.12665508957884833 , 0.12665508957884833 , 0.1259892807712678 , 0.12466396327768503 , 0.12269166637219883 }; Agora dentro da task_adc (apos o TC_ini ), vamos iniciar o filtro: /* Cria buffers para filtragem e faz a inicializacao do filtro. */ float32_t firStateF32 [ BLOCK_SIZE + NUM_TAPS - 1 ]; float32_t inputF32 [ BLOCK_SIZE + NUM_TAPS - 1 ]; float32_t outputF32 [ BLOCK_SIZE + NUM_TAPS - 1 ]; arm_fir_instance_f32 S ; arm_fir_init_f32 ( & S , NUM_TAPS , ( float32_t * ) & firCoeffs32 [ 0 ], & firStateF32 [ 0 ], BLOCK_SIZE ); Resumo Tarefas Criar define NUM_TAPS Criar define BLOCK_SIZE Criar constant com coefientes do filtro firCoeffs32 Modificar task_adc e inicializar filtro Processando Modifique o while da task adc para realizar a filtragem e enviar para o LCD exibir. int i = 0; while(1){ if (xQueueReceive( xQueueADC, &(adc), 100)) { if(i <= NUM_TAPS){ inputF32[i++] = (float) adc.value; } else{ arm_fir_f32(&S, &inputF32[0], &outputF32[0], BLOCK_SIZE); plot.raw = (int) inputF32[0]; plot.filtrado = (int) outputF32[0]; xQueueSend(xQueuePlot, &plot, 0); i = 0; } Resultado esperado: Sorry, your browser doesn't support embedded videos. B Criar um novo filtro de ordem 12 e trocar o atual A No lugar de mostrar uma linha no tempo, fazer um ponto em um circulo","title":"Lab 8 - FIR"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#lab-8-fir","text":"Fonte: https://www.mathworks.com/matlabcentral/mlc-downloads/downloads/submissions/53983/versions/5/previews/html/ExampleECGBitalino.html Neste laborat\u00f3rio iremos processar o sinal de ECG que voc\u00eas precisam processar na APS2. Voc\u00eas podem e devem usar o c\u00f3digo do laborat\u00f3rio na APS. Preencher ao finalizar o lab TODO: MARCO","title":"Lab 8 - FIR"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#lab","text":"Exemplo base LAB SAME70-Examples/ TODO: CODIGO EXEMPLO Labs-8-RTOS-ADC-FIR C\u00f3digo exemplo Vamos modificar o c\u00f3digo exemplo TODO: CODIGO EXEMPLO , fa\u00e7a uma c\u00f3pia do seu lab para a nova pasta no seu reposit\u00f3rio Labs/9-RTOS-ADC-FIR Terminal Esse exemplo faz uso da comunica\u00e7\u00e3o UART para debug de c\u00f3digo (via printf), para acessar o terminal no atmel est\u00fadio clique em: View Terminal Window Configure o terminal para a porta que (COM) correta (verificar no windows) e configure para operar com um BaudRate de 115200 . Info Iremos utilizar os seguintes perif\u00e9ricos diretamente: AFEC1 (EXT1 PC31) TC1 canal 1 Indiretamente (o projeto j\u00e1 usa): DAC0 (PB13) TC0 canal 0","title":"Lab"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#conectando","text":"Vamos conectar o pino PB13 que gera o sinal o sinal anal\u00f3gico do batimento card\u00edaco ao pino PC31 do EXT1 que possui o AFEC1 conforme imagem e diagrama a baixo: Imagem TODO INSERIR IMAGEM Diagrama \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502afec \u2502\u25c4\u251c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 ecg \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 tc0 \u251c\u2500\u25ba\u2502dac \u251c\u2500x\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 PB13 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Progress Click para continuar....","title":"Conectando"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#ecg","text":"O sinal ECG gerado no pino PB13 possui a forma de onda a seguir: E se analisarmos o espectro do sinal via transformada de fourier, obtemos a seguinte composi\u00e7\u00e3o espectral: Question O que voc\u00ea consegue extrair de informa\u00e7\u00f5es dos gr\u00e1ficos anteriores? No primeiro (ecg no tempo) podemos ver claramente que existe uma alta frequ\u00eancia no sinal, mas que o envelope \u00e9 a informa\u00e7\u00e3o do ecg. J\u00e1 no fourier somos capazes se distinguir que existem duas regi\u00f5es com bastante informa\u00e7\u00f5es, uma de baixa frqu\u00eancia (0..25)Hz e outra de 60Hz. Progress Click para continuar....","title":"ECG"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#60-hz","text":"Notamos claramente que existe um sinal centrada em 60Hz, isso \u00e9 muito comum quando trabalhamos com eletr\u00f4nica e reflete o 60Hz da rede el\u00e9trica que \u00e9 propagada de diversas formas para o transdutor respons\u00e1vel em amostrar o dado do pulso el\u00e9trico do corpo humano, causando um ru\u00eddo no sinal n\u00e3o desej\u00e1vel. Para trarmos o dado corretamente teremos que filtar o ru\u00eddo. Lembre que em alguns paises a frequ\u00eancia da rede el\u00e9trica \u00e9 de 50Hz e n\u00e3o de 60Hz como no Brasil. Info O som desse ru\u00eddo em 60hz \u00e9 chamado de Zumbido el\u00e9trico soa como: ref: wiki Progress Click para continuar....","title":"60 Hz"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#filtros-digitais","text":"Filtragem de sinal pertence a uma grande \u00e1rea do conhecimento que \u00e9 processamento de sinais, nesse laborat\u00f3rio iremos tratar do tema de forma superficial. Mas exemplos de aplica\u00e7\u00e3o de filtragem digital s\u00e3o: Remo\u00e7\u00e3o de ru\u00eddo Processamento de \u00c1udio Extra\u00e7\u00e3o de par\u00e2metros ... Tip Para saber mais leia: The Scientist and Engineer's Guide to Digital Signal Processing","title":"Filtros digitais"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#fir","text":"O Finite Impulse Response (FIR) \u00e9 uma t\u00e9cnica de processamento digital de sinais (DSP) que \u00e9 capaz de realizar filtragens em um sinal. Com o FIR somos capazes de aplicar um filtro do tipo: passa baixas: Elimina as altas frequ\u00eancias passa altas: Elimina as baixas frequ\u00eancias mata faixa: Elimina uma faixa de frequ\u00eancias do sinal Filtros digitais do tipo FIR possuem as seguintes vantagens: S\u00e3o est\u00e1veis por natureza (n\u00e3o importa o par\u00e2metro do filtro, o sinal de sa\u00edda vai ser est\u00e1vel) Podem ser projetados para ter fase linear Possuem flexibilidade no seu projeto S\u00e3o f\u00e1ceis de implementar O filtro possui a seguinte estrutura: $$y[n] = b_0*x[n] + b_1*x[n-1] + .... b_n*x[n-N]$$ Onde: $y[n]$: Valor filtrado $x[n-N]$: Valor do dado n\u00e3o filtrado, atrasado de N amostras $b_n$: Coeficiente do filtro $N$: Ordem do filtro Podemos representar a equa\u00e7\u00e3o graficamente: Fonte: https://en.wikipedia.org/wiki/Finite_impulse_response $Z^{-1}$: Significa um atraso na amostra","title":"FIR"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#projeto-do-filtro","text":"Podemos realizar o projeto do filtro FIR (achar a ordem N e os coeficientes B) de diversas maneiras diferentes, cada um possui uma vantagem sobre a outra. Vamos utilizar o Equiripple Algorithm que possui ripples em torno da frequ\u00eancia de corte ( fc ). Fonte: https://www.recordingblogs.com/wiki/equiripple-filter O projeto do filtro envolve v\u00e1rios par\u00e2metros e diversas escolhas, vamos verificarmos os mais importantes: $f_s$: Frequ\u00eancia de amostragem do sinal $f_c$: Frequ\u00eancia de corte, quando a componente espectral j\u00e1 possui um ganho baixo e n\u00e3o influencia 'tanto' no sinal. Na $f_c$ o ganho do sinal \u00e9 geralmente -3dB, o que significa em volts, que o sinal possui $sqrt(\u00bd)=0.707$ do seu valor inicial. Note A filtragem n\u00e3o s\u00f3 altera o valor absoluto de um sinal, como tamb\u00e9m afeta sua frequ\u00eancia! Dependendo do que estiver analisando isso pode afetar o resultado final. Progress Click para continuar....","title":"Projeto do filtro"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#pyfda","text":"Para o projeto do filtro vamos utilizar uma ferramenta em python pyfda que vai nos ajudar encontrar os coeficientes b e N do filtro. Para isso siga os passos de instala\u00e7\u00e3o a seguir: git clone https://github.com/chipmuenk/pyFDA/ cd pyFDA pip3 install -r requirements.txt --user python3 -m pyfda.pyfdax Configure o filtro para: E agora clique em DESIGN FILTER . V\u00e1 na aba b,a e salve os valores de b em um txt, vamos usar mais tarde !","title":"pyfda"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#firmware","text":"Esse exemplo possui: task_mxt : Leitura do touch task_lcd : Para exibi\u00e7\u00e3o dos dados no LCD task_adc : Inicia um TC para fazer a convers\u00e3o do ADC, recebe o dado e envia por uma fila. TC1 : Timer configurado em 50Hz para fazer gerar o trigger da convers\u00e3o anal\u00f3gica AFEC : Para realizar a leitura do potenciometro Note Iremos usar o TC como trigger do AFEC (no lugar da task_adc fazer isso como no lab RTOS-ADC) pelos seguinte motivos: Garantir que a aquisi\u00e7\u00e3o ocorra na taxa especificada Permitir uma taxa de aquisi\u00e7\u00e3o maior que o tick do RTOS","title":"firmware"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#plotando-adc-no-tempo","text":"Vamos modificar a task_lcd para exibir o valor da leitura do potenciometro no tempo. O resultado esperado \u00e9 o seguinte: Sorry, your browser doesn't support embedded videos. Tip Voc\u00ea deve fazer essa implementa\u00e7\u00e3o dentro do if que pega um dado da fila xQueuePlot : if ( xQueueReceive ( xQueuePlot , & ( plot ), ( TickType_t ) 100 / portTICK_PERIOD_MS )) { // aqui dentro!! } O dado que deve ser plotado \u00e9 o plot.raw Crie um contador que far\u00e1 o incremento do eixo x dica: use x = x + 5 ; Incremente esse contador at\u00e9 chegar no final do LCD ( ILI9488_LCD_WIDTH ) zere o contador quando chegar no final apague a tela quando chegar no final draw_screen() Plote um circulo no lcd para cada ponto, exemplo: ili9488_set_foreground_color ( COLOR_CONVERT ( COLOR_BLACK )); ili9488_draw_filled_circle ( x , ILI9488_LCD_HEIGHT - plot . raw / 16 , 2 ); Agora voc\u00ea deve modificar o plot, para plotar al\u00e9m do plot.raw exibir o plot.filtrado que mais para frente no lab ser\u00e1 o nosso dado do ADC filtrado com o filtro projetado anteriormente. Atualmente ele \u00e9 o valor plot.raw deslocado de 100. Tip Utilize outra cor para mostrar esse dado: ili9488_set_foreground_color ( COLOR_CONVERT ( COLOR_RED )); Resumo Tarefas Exibir o valor plot.raw graficamente no lcd Exibir o valor plot.filtrado graficamente no lcd","title":"Plotando ADC no tempo"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#filtrando-dado","text":"Vamos agora aplicar o filtro projetado anteriormente no dado adc , iremos utilizar uma biblioteca da ARM chamada de CMSIS DSP 4 que possui uma s\u00e9rie de fun\u00e7\u00f5es matem\u00e1ticas e de processamento de sinais. Dentro dessa biblioteca, iremos utilizar a fun\u00e7\u00e3o arm_fir_init_f32 e arm_fir_f32 que respectivamente: inicializa o filtro FIR do tipo float_32 e aplica o filtro (convolu\u00e7\u00e3o) ao sinal. Tip De uma olhada como essas fun\u00e7\u00f5es s\u00e3o implementadas, elas abusam bastante da topologia interna do ARM (bem sistema hardware software) para entregarem uma fun\u00e7\u00e3o bem otimizada: https://github.com/ARM-software/CMSIS_5/blob/9a825ef26043a0648894f5bf155edc0219b8212f/CMSIS/DSP/Source/FilteringFunctions/arm_fir_f32.c","title":"Filtrando dado"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#inicializando-filtro","text":"Crie os defines a seguir: #define NUM_TAPS 8 // ordem do filtro (quantos coefientes) #define BLOCK_SIZE 1 // se ser\u00e1 processado por blocos, no caso n\u00e3o. Agora vamos copiar os coeficientes do filtro que foram gerados na etapa do projeto do filtro para a vari\u00e1vel firCoeffs32 : const float32_t firCoeffs32 [ NUM_TAPS ] = { 0.12269166637219883 , 0.12466396327768503 , 0.1259892807712678 , 0.12665508957884833 , 0.12665508957884833 , 0.1259892807712678 , 0.12466396327768503 , 0.12269166637219883 }; Agora dentro da task_adc (apos o TC_ini ), vamos iniciar o filtro: /* Cria buffers para filtragem e faz a inicializacao do filtro. */ float32_t firStateF32 [ BLOCK_SIZE + NUM_TAPS - 1 ]; float32_t inputF32 [ BLOCK_SIZE + NUM_TAPS - 1 ]; float32_t outputF32 [ BLOCK_SIZE + NUM_TAPS - 1 ]; arm_fir_instance_f32 S ; arm_fir_init_f32 ( & S , NUM_TAPS , ( float32_t * ) & firCoeffs32 [ 0 ], & firStateF32 [ 0 ], BLOCK_SIZE ); Resumo Tarefas Criar define NUM_TAPS Criar define BLOCK_SIZE Criar constant com coefientes do filtro firCoeffs32 Modificar task_adc e inicializar filtro","title":"Inicializando filtro"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#processando","text":"Modifique o while da task adc para realizar a filtragem e enviar para o LCD exibir. int i = 0; while(1){ if (xQueueReceive( xQueueADC, &(adc), 100)) { if(i <= NUM_TAPS){ inputF32[i++] = (float) adc.value; } else{ arm_fir_f32(&S, &inputF32[0], &outputF32[0], BLOCK_SIZE); plot.raw = (int) inputF32[0]; plot.filtrado = (int) outputF32[0]; xQueueSend(xQueuePlot, &plot, 0); i = 0; } Resultado esperado: Sorry, your browser doesn't support embedded videos.","title":"Processando"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#b","text":"Criar um novo filtro de ordem 12 e trocar o atual","title":"B"},{"location":"navigation/Labs/Lab_ADC_FIR/Lab-ADC-FIR/#a","text":"No lugar de mostrar uma linha no tempo, fazer um ponto em um circulo","title":"A"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER-Teoria/","text":"Driver - Teoria Para que nosso firmware atue corretamente sobre o hardware ser\u00e1 necess\u00e1rio ampliarmos nossos conhecimentos sobre o mesmo. O PIO \u00e9 um dos perif\u00e9ricos mais utilizados durante um projeto, e aparentemente o mais simples desse nosso uC (s\u00f3 que n\u00e3o!) com ele temos o controle de praticamente todos os pinos digitais do uC. O entendimento de como o mesmo funciona e como ele \u00e9 configurado ir\u00e1 possibilitar que utilizemos outros perif\u00e9ricos mais para frente. N\u00e3o tem muito jeito! Ser\u00e1 necess\u00e1rio abrirmos o manual do uC de mais de 1000 p\u00e1ginas e lermos as informa\u00e7\u00f5es que o fabricante disponibiliza, l\u00e1 teremos detalhado o que deve ser feito para ativarmos uma determinada fun\u00e7\u00e3o ou realizar uma configura\u00e7\u00e3o no perif\u00e9rico (isso vale para todos os microcontroladores ). Cada chip e cada fabricante opta por implementar uma solu\u00e7\u00e3o diferente, mais o formato do documento \u00e9 mais ou menos o mesmo. As solu\u00e7\u00f5es n\u00e3o s\u00e3o t\u00e3o distintas assim, com a pr\u00e1tica conseguimos aos poucos ir pegando o linguajar e os truques, mas isso n\u00e3o diminui a necessidade de ler e reler o manual (e muitos manuais...) at\u00e9 encontrar a informa\u00e7\u00e3o que busca. Os perif\u00e9ricos s\u00e3o controlados por registradores. Registradores s\u00e3o pequenas unidades de armazenamento que se comportam como uma mem\u00f3ria quando alinhados (bem parecido com elementos, na constru\u00e7\u00e3o da mem\u00f3ria RAM). \u00c9 pelos registradores que podemos ler e/ou escrever uma informa\u00e7\u00e3o do perif\u00e9rico. Se tiver curiosidade de como esse lab seria realizado para outro uC, d\u00ea uma lida nesse post do EmbeddedFM Voc\u00ea sabia Os fabricantes de IC disponibilizam alguns tipos de documentos que s\u00e3o muito importantes: Datasheet / User manual: Manual com todas as informa\u00e7\u00f5es sobre um IC Application note: Documento que mostra como usar um recurso, cont\u00e9m as boas pr\u00e1ticas. White paper: Uma nota t\u00e9cnica, sem feedback de pares, divulgando alguma coisa. Registradores 8. Memory Map and Registers Para uma outra vis\u00e3o sobre o assunto acesse: Coursera: Embedded Software and Hardware Architecture Os registradores podem ser utilizados no hardware de diversas maneiras: Cada bit do registrador (de 32 bits) pode indicar uma a\u00e7\u00e3o diferente no perif\u00e9rico (mask); os 32 bits podem representar um n\u00famero (signed/unsigned); No caso do PIO temos ao todo 89 registradores, e cada um tem um papel diferente nesse perif\u00e9rico. Na documenta\u00e7\u00e3o do PIO temos um diagrama que mostra alguns desses registradores e seus papeis no HW: Estrutura de software Sistemas embarcados tendem a possuir softwares muito complexos: Conectividade (wifi/ethernet/bluetooth), interface com usu\u00e1rio ( LCD / teclados /...), requisitos de tempo real, bateria, seguran\u00e7a de dados e para ajudar tudo isso miniaturizado em um hardware dedicado. Como estamos trabalhando com baixo n\u00edvel, muitas vezes precisamos configurar todas essas funcionalidades na 'unha', para isso, iremos utilizar uma estrutura de softwares que possui uma s\u00e9rie de abstra\u00e7\u00f5es que facilitam a vida do desenvolvedor e diminui o tempo de desenvolvimento minimizando erros. Essa estrutura \u00e9 formada por: Drivers, HAL e Sistema Operacional, conforme detalhado a seguir: Driver Um driver (framework/ api) s\u00e3o fun\u00e7\u00f5es que possibilitam acessar o baixo n\u00edvel sem se preocupar muito de como acessar o hardware, as fun\u00e7\u00f5es fornecem uma forma direita de manipular registradores e core. No nosso caso, iremos utilizar um framework chamado de Advanced Software Framework Version 4 , ele e fornecido e mantido pelo fabricante do microcontrolador que usamos no curso (SAME70) e serve para v\u00e1rias fam\u00edlias de uC ARM (SAMD20 / SAMV71 / SAMG54 /...). Foi com o ASF que fomos capazes de realizar o LAB1, onde configuramos pinos como entrada e sa\u00edda e fomos capazes de ler e escrever nesses pinos. fonte: http://asf.atmel.com/docs/latest/architecture.html HAL Hardware Abstraction Layer (HAL) \u00e9 uma camada de abstra\u00e7\u00e3o mais alta, fica geralmente entre o sistema operacional e o driver. Ela \u00e9 criada para facilitar o desenvolvimento dos SO, que necessita acessar e configurar hardwares de tipos diferentes. Essa abstra\u00e7\u00e3o estabelece um padr\u00e3o de acesso (via chamada de fun\u00e7\u00f5es) para o sistema operacional. A ARM tem tentando criar um HAL universal para os seus microcontroladores, mas ainda n\u00e3o possui muita ades\u00e3o da industria e dos desenvolvedores. Esse movimento se deu para possibilitar que um firmware seja port\u00e1vel entre diferentes fabricantes (o que n\u00e3o \u00e9 poss\u00edvel de forma direta hoje em dia, cada fabricante disponibiliza o seu pr\u00f3prio HAL). O Cortex Microcontroller Software Interface Standard (cmsis) \u00e9 essa biblioteca que est\u00e1 sendo desenvolvido pela ARM. Fonte: https://www.keil.com/pack/doc/CMSIS/Driver/html/index.html J\u00e1 parou para pensar por que o Arduino \u00e9 t\u00e3o popular? Por que ele venceu essa batalha e n\u00e3o outro kit de desenvolvimento? (existem muitossss kits de desenvolvimento, de uma olhada nessa lista da digikey ). Na minha vis\u00e3o \u00e9 devido a ele possuir um \u00f3timo HAL, onde n\u00e3o precisamos nos preocupar com qual Arduino estamos trabalhando. UNO, DUE? ... O mesmo c\u00f3digo funciona em qualquer um. As fun\u00e7\u00f5es utilizadas para configurar os pinos com sa\u00edda/entrada/ PWM/ AD s\u00e3o as mesmas, n\u00e3o importa o Arduino que esteja usando. Como as fun\u00e7\u00f5es s\u00e3o as mesmas se o chip muda? Devido ao HAL que o Arduino fornece que abstrai o acesso ao hardware pela chamada de fun\u00e7\u00f5es. As fun\u00e7\u00f5es s\u00e3o simples e intuitivas! Elas escodem tudo que \u00e9 de complexo do hardware. Curiosidade Curiosidade: De uma olhada no c\u00f3digo fonte da popular fun\u00e7\u00e3o do arduino: pinMode() .","title":"Teoria"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER-Teoria/#driver-teoria","text":"Para que nosso firmware atue corretamente sobre o hardware ser\u00e1 necess\u00e1rio ampliarmos nossos conhecimentos sobre o mesmo. O PIO \u00e9 um dos perif\u00e9ricos mais utilizados durante um projeto, e aparentemente o mais simples desse nosso uC (s\u00f3 que n\u00e3o!) com ele temos o controle de praticamente todos os pinos digitais do uC. O entendimento de como o mesmo funciona e como ele \u00e9 configurado ir\u00e1 possibilitar que utilizemos outros perif\u00e9ricos mais para frente. N\u00e3o tem muito jeito! Ser\u00e1 necess\u00e1rio abrirmos o manual do uC de mais de 1000 p\u00e1ginas e lermos as informa\u00e7\u00f5es que o fabricante disponibiliza, l\u00e1 teremos detalhado o que deve ser feito para ativarmos uma determinada fun\u00e7\u00e3o ou realizar uma configura\u00e7\u00e3o no perif\u00e9rico (isso vale para todos os microcontroladores ). Cada chip e cada fabricante opta por implementar uma solu\u00e7\u00e3o diferente, mais o formato do documento \u00e9 mais ou menos o mesmo. As solu\u00e7\u00f5es n\u00e3o s\u00e3o t\u00e3o distintas assim, com a pr\u00e1tica conseguimos aos poucos ir pegando o linguajar e os truques, mas isso n\u00e3o diminui a necessidade de ler e reler o manual (e muitos manuais...) at\u00e9 encontrar a informa\u00e7\u00e3o que busca. Os perif\u00e9ricos s\u00e3o controlados por registradores. Registradores s\u00e3o pequenas unidades de armazenamento que se comportam como uma mem\u00f3ria quando alinhados (bem parecido com elementos, na constru\u00e7\u00e3o da mem\u00f3ria RAM). \u00c9 pelos registradores que podemos ler e/ou escrever uma informa\u00e7\u00e3o do perif\u00e9rico. Se tiver curiosidade de como esse lab seria realizado para outro uC, d\u00ea uma lida nesse post do EmbeddedFM Voc\u00ea sabia Os fabricantes de IC disponibilizam alguns tipos de documentos que s\u00e3o muito importantes: Datasheet / User manual: Manual com todas as informa\u00e7\u00f5es sobre um IC Application note: Documento que mostra como usar um recurso, cont\u00e9m as boas pr\u00e1ticas. White paper: Uma nota t\u00e9cnica, sem feedback de pares, divulgando alguma coisa.","title":"Driver - Teoria"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER-Teoria/#registradores","text":"8. Memory Map and Registers Para uma outra vis\u00e3o sobre o assunto acesse: Coursera: Embedded Software and Hardware Architecture Os registradores podem ser utilizados no hardware de diversas maneiras: Cada bit do registrador (de 32 bits) pode indicar uma a\u00e7\u00e3o diferente no perif\u00e9rico (mask); os 32 bits podem representar um n\u00famero (signed/unsigned); No caso do PIO temos ao todo 89 registradores, e cada um tem um papel diferente nesse perif\u00e9rico. Na documenta\u00e7\u00e3o do PIO temos um diagrama que mostra alguns desses registradores e seus papeis no HW:","title":"Registradores"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER-Teoria/#estrutura-de-software","text":"Sistemas embarcados tendem a possuir softwares muito complexos: Conectividade (wifi/ethernet/bluetooth), interface com usu\u00e1rio ( LCD / teclados /...), requisitos de tempo real, bateria, seguran\u00e7a de dados e para ajudar tudo isso miniaturizado em um hardware dedicado. Como estamos trabalhando com baixo n\u00edvel, muitas vezes precisamos configurar todas essas funcionalidades na 'unha', para isso, iremos utilizar uma estrutura de softwares que possui uma s\u00e9rie de abstra\u00e7\u00f5es que facilitam a vida do desenvolvedor e diminui o tempo de desenvolvimento minimizando erros. Essa estrutura \u00e9 formada por: Drivers, HAL e Sistema Operacional, conforme detalhado a seguir:","title":"Estrutura de software"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER-Teoria/#driver","text":"Um driver (framework/ api) s\u00e3o fun\u00e7\u00f5es que possibilitam acessar o baixo n\u00edvel sem se preocupar muito de como acessar o hardware, as fun\u00e7\u00f5es fornecem uma forma direita de manipular registradores e core. No nosso caso, iremos utilizar um framework chamado de Advanced Software Framework Version 4 , ele e fornecido e mantido pelo fabricante do microcontrolador que usamos no curso (SAME70) e serve para v\u00e1rias fam\u00edlias de uC ARM (SAMD20 / SAMV71 / SAMG54 /...). Foi com o ASF que fomos capazes de realizar o LAB1, onde configuramos pinos como entrada e sa\u00edda e fomos capazes de ler e escrever nesses pinos. fonte: http://asf.atmel.com/docs/latest/architecture.html","title":"Driver"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER-Teoria/#hal","text":"Hardware Abstraction Layer (HAL) \u00e9 uma camada de abstra\u00e7\u00e3o mais alta, fica geralmente entre o sistema operacional e o driver. Ela \u00e9 criada para facilitar o desenvolvimento dos SO, que necessita acessar e configurar hardwares de tipos diferentes. Essa abstra\u00e7\u00e3o estabelece um padr\u00e3o de acesso (via chamada de fun\u00e7\u00f5es) para o sistema operacional. A ARM tem tentando criar um HAL universal para os seus microcontroladores, mas ainda n\u00e3o possui muita ades\u00e3o da industria e dos desenvolvedores. Esse movimento se deu para possibilitar que um firmware seja port\u00e1vel entre diferentes fabricantes (o que n\u00e3o \u00e9 poss\u00edvel de forma direta hoje em dia, cada fabricante disponibiliza o seu pr\u00f3prio HAL). O Cortex Microcontroller Software Interface Standard (cmsis) \u00e9 essa biblioteca que est\u00e1 sendo desenvolvido pela ARM. Fonte: https://www.keil.com/pack/doc/CMSIS/Driver/html/index.html J\u00e1 parou para pensar por que o Arduino \u00e9 t\u00e3o popular? Por que ele venceu essa batalha e n\u00e3o outro kit de desenvolvimento? (existem muitossss kits de desenvolvimento, de uma olhada nessa lista da digikey ). Na minha vis\u00e3o \u00e9 devido a ele possuir um \u00f3timo HAL, onde n\u00e3o precisamos nos preocupar com qual Arduino estamos trabalhando. UNO, DUE? ... O mesmo c\u00f3digo funciona em qualquer um. As fun\u00e7\u00f5es utilizadas para configurar os pinos com sa\u00edda/entrada/ PWM/ AD s\u00e3o as mesmas, n\u00e3o importa o Arduino que esteja usando. Como as fun\u00e7\u00f5es s\u00e3o as mesmas se o chip muda? Devido ao HAL que o Arduino fornece que abstrai o acesso ao hardware pela chamada de fun\u00e7\u00f5es. As fun\u00e7\u00f5es s\u00e3o simples e intuitivas! Elas escodem tudo que \u00e9 de complexo do hardware. Curiosidade Curiosidade: De uma olhada no c\u00f3digo fonte da popular fun\u00e7\u00e3o do arduino: pinMode() .","title":"HAL"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER/","text":"LAB - PIO - DRIVER Nessa aula iremos utilizar como projeto refer\u00eancia o LAB-1. Entrega Pasta: /Lab2-PIO-Driver Data LIMITE para entrega: 28/08/22 - 23h59 Como come\u00e7ar: Voc\u00eas devem realizar uma c\u00f3pia do LAB-1 que est\u00e1 no seu reposit\u00f3rio para a pasta Lab2-PIO-Driver , iremos modificar o que fizemos no laborat\u00f3rio passado. A entrega continua sendo feita pelo reposit\u00f3rio que foi gerado no laborat\u00f3rio passado. O objetivo desse laborat\u00f3rio \u00e9 o do entendimento das fun\u00e7\u00f5es utilizadas para configurar o PIO. Como um pino \u00e9 configurado como sa\u00edda e entrada? Como o firmware manipula o perif\u00e9rico PIO? Entender o que o PIO \u00e9 capaz de fazer. Para isso iremos aqui implementar nossas pr\u00f3prias fun\u00e7\u00f5es de interface com o PIO. Ao final do lab, dever\u00e3o ter implementado as seguintes fun\u00e7\u00f5es: C: _pio_set(...) _pio_clear(...) _pio_pull_up(...) _pio_set_input(...) _pio_set_output(...) B: _pio_get(...) A: _delay_ms(...) Driver Vamos implementar uma s\u00e9rie de fun\u00e7\u00f5es que ir\u00e3o configurar o perif\u00e9rico PIO via a escrita em seu banco de registradores. Para isso ser\u00e1 necess\u00e1rio ler o manual do uC mais especificamente a sec\u00e7\u00e3o do PIO - p\u00e1g. 344 . Progress Click para continuar.... _pio_set(...) Iremos come\u00e7ar com essa fun\u00e7\u00e3o que \u00e9 uma das mais simples. Crie uma fun\u00e7\u00e3o no main.c com a seguinte estrutura: /** * \\brief Set a high output level on all the PIOs defined in ul_mask. * This has no immediate effects on PIOs that are not output, but the PIO * controller will save the value if they are changed to outputs. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. */ void _pio_set ( Pio * p_pio , const uint32_t ul_mask ) { } Tip Lembre que essa fun\u00e7\u00e3o serve para acionarmos um pino digital quando o mesmo \u00e9 configurado como output (fazer ele virar 3.3V ). Na primeira etapa iremos substituir a fun\u00e7\u00e3o que a Microchip j\u00e1 nos disponibiliza por uma criada por n\u00f3s, em todo lugar no c\u00f3digo que voc\u00ea faz o uso da fun\u00e7\u00e3o pio_set(...) substitua a chamada por essa rec\u00e9m criada _pio_set(...) . pio_set Crie a fun\u00e7\u00e3o _pio_set() Substitua no c\u00f3digo toda ocorr\u00eancia de pio_set() pela _pio_set() . Execute o c\u00f3digo, ele n\u00e3o deve funcionar . pois agora a fun\u00e7\u00e3o que aciona um pino n\u00e3o est\u00e1 implementada. Progress Pr\u00f3xima etapa .... Agora ser\u00e1 necess\u00e1rio entender como o PIO controla os pinos e o que deve ser feito para que ele atue sobre o pino como desejamos. A parte da sec\u00e7\u00e3o do manual que fala sobre o PIO e suas sa\u00eddas/entradas \u00e9 a sec\u00e7\u00e3o 32 do ( manual SAME70 ), vamos analisar: SAME70-Manual: 32.5.4 Output Control Texto extra\u00eddo do manual: The level driven on an I/O line can be determined by writing in the Set Output Data Register ( PIO_SODR ) and the Clear Output Data Register (PIO_CODR). These write operations, respectively, set and clear the Output Data Status Register (PIO_ODSR), which represents the data driven on the I/O lines**. Writing in PIO_OER and PIO_ODR manages PIO_OSR whether the pin is configured to be controlled by the PIO Controller or assigned to a peripheral function. This enables configuration of the I/O line prior to setting it to be managed by the PIO Controller. Lendo o texto, podemos descobrir que para termos 1 ( set ) no pino devemos escrever no registrador PIO_SODR , no manual tem mais detalhes sobre tudo do PIO. Vamos analisar a documenta\u00e7\u00e3o especifica deste registrador ( SODR ): Repare que esse registrador \u00e9 do tipo write-only ou seja ele n\u00e3o pode ser lido, somente escrito. Cada bit desse registrador representa um pino, se pegarmos por exemplo o bit 30 desse registrador (pensando no PIOA) estar\u00edamos nos referindo ao PA30 , qualquer altera\u00e7\u00e3o ESCRITA nesse bit influenciar\u00e1 SOMENTE esse pino. Note Todos os registradores est\u00e3o listados e explicados no datasheet, de uma olhada na p\u00e1gina 362 , a descri\u00e7\u00e3o come\u00e7a ai. Agora que j\u00e1 sabemos o que deve ser feito para colocarmos acionarmos um pino (ativar) e considerando que ele j\u00e1 foi configurado como sa\u00edda podemos escrever a implementa\u00e7\u00e3o da fun\u00e7\u00e3o: void _pio_set ( Pio * p_pio , const uint32_t ul_mask ) { p_pio -> PIO_SODR = ul_mask ; } *p_pio : \u00e9 um endere\u00e7o recebido do tipo Pio, ele indica o endere\u00e7o de mem\u00f3ria na qual o PIO (perif\u00e9rico) em quest\u00e3o est\u00e1 mapeado (vamos ver isso em detalhes). ul_mask : \u00e9 a m\u00e1scara na qual iremos aplicar ao registrador que controla os pinos para colocarmos 1 na sa\u00edda. O que isso significa? Significa que estamos acessando o perif\u00e9rico passado como refer\u00eancia a fun\u00e7\u00e3o (um dos cinco PIO dispon\u00edveis no uc: PIOA , PIOB , PIOC , ...) e estamos aplicando a m\u00e1scara ul_mask no seu registrador PIO_SODR . Pio type? O tipo Pio \u00e9 uma struct alinhada com o endere\u00e7o de mem\u00f3ria do perif\u00e9rico, onde cada 'item' dessa struct representa um endere\u00e7o da mem\u00f3ria do perif\u00e9rico, essa \u00e9 uma maneira em C de darmos nome a endere\u00e7os de mem\u00f3ria. Isso j\u00e1 est\u00e1 definido no projeto quando usamos o asf (para facilitar nossa vida): O PIOA \u00e9 um struct que aponta para o endere\u00e7o 0x400E0E00 #define PIOA ((Pio *)0x400E0E00U) /**< \\brief (PIOA ) Base Address */ O struct possui a seguinte estrutura: typedef struct { __O uint32_t PIO_PER ; /**< \\brief (Pio Offset: 0x0000) PIO Enable Register */ __O uint32_t PIO_PDR ; /**< \\brief (Pio Offset: 0x0004) PIO Disable Register */ __I uint32_t PIO_PSR ; /**< \\brief (Pio Offset: 0x0008) PIO Status Register */ __I uint32_t Reserved1 [ 1 ]; __O uint32_t PIO_OER ; /**< \\brief (Pio Offset: 0x0010) Output Enable Register */ __O uint32_t PIO_ODR ; /**< \\brief (Pio Offset: 0x0014) Output Disable Register */ __I uint32_t PIO_OSR ; /**< \\brief (Pio Offset: 0x0018) Output Status Register */ __I uint32_t Reserved2 [ 1 ]; __O uint32_t PIO_IFER ; /**< \\brief (Pio Offset: 0x0020) Glitch Input Filter Enable Register */ __O uint32_t PIO_IFDR ; /**< \\brief (Pio Offset: 0x0024) Glitch Input Filter Disable Register */ Onde: O , I s\u00e3o macros que bloqueiam os endere\u00e7os para: __O : Apenas escrita (output) __I : Apenas Leitura (input) __IO : Leitura e Escrita (input/output) #ifdef __cplusplus #define __I volatile /*!< Defines 'read only' permissions */ #else #define __I volatile const /*!< Defines 'read only' permissions */ #endif #define __O volatile /*!< Defines 'write only' permissions */ #define __IO volatile /*!< Defines 'read / write' permissions */ O diagrama a seguir ilustra o que acontece quando fazemos: p_pio->PIO_SODR = ul_mask; Teste A fun\u00e7\u00e3o est\u00e1 pronta, agora precisamos testar. Com a modifica\u00e7\u00e3o no c\u00f3digo fa\u00e7a a grava\u00e7\u00e3o do uC e ele deve voltar a piscar o LED quando voc\u00ea aperta o bot\u00e3o. Agora a fun\u00e7\u00e3o implementada possui a mesma funcionalidade daquela fornecida pelo fabricante. Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso a fun\u00e7\u00e3o implementada esteja correta. Progress Pr\u00f3xima etapa .... _pio_clear(...) Fa\u00e7a o mesmo para a fun\u00e7\u00e3o clear: /** * \\brief Set a low output level on all the PIOs defined in ul_mask. * This has no immediate effects on PIOs that are not output, but the PIO * controller will save the value if they are changed to outputs. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. */ void _pio_clear ( Pio * p_pio , const uint32_t ul_mask ) { } Exercise Consultando a sec\u00e7\u00e3o 32.5.4 do manual do microcontrolador, qual \u00e9 o registrador que deve ser acessado para colocar zero no pino? Answer pio_codr The level driven on an I/O line can be determined by writing in the Set Output Data Register (PIO_SODR) and the Clear Output Data Register (PIO_CODR) . These write operations, respectively, set and clear the Output Data Status Register (PIO_ODSR), which represents the data driven on the I/O lines. Writing in PIO_OER and PIO_ODR manages PIO_OSR whether the pin is configured to be controlled by the PIO Controller or assigned to a peripheral function. This enables configuration of the I/O line prior to setting it to be managed by the PIO Controller. Modifique e teste Crie a fun\u00e7\u00e3o _pio_clear() Substitua no c\u00f3digo toda ocorr\u00eancia de pio_clear por _pio_clear Implemente a fun\u00e7\u00e3o. Compile, programe e teste Progress Pr\u00f3xima etapa .... _pio_pull_up(...) Warning S\u00f3 continue se a implementa\u00e7\u00e3o anterior funcionou. Vamos implementar uma fun\u00e7\u00e3o que faz a configura\u00e7\u00e3o do pullup nos pinos do PIO, esse pullup \u00e9 utilizado no bot\u00e3o da placa. Para isso declare a fun\u00e7\u00e3o a seguir: /** * \\brief Configure PIO internal pull-up. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. * \\param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be * configured. */ void _pio_pull_up ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_pull_up_enable ){ } Essa fun\u00e7\u00e3o recebe o PIO que ir\u00e1 configurar, os pinos que ser\u00e3o configurados e como \u00faltimo par\u00e2metro se o pullup estar\u00e1 ativado (1) ou desativado (0). Info Leia o manual do PIO, especificamente a sec\u00e7\u00e3o 32.5.1 . Exercise Consultando a sec\u00e7\u00e3o 32.5.1 do manual do microcontrolador, qual \u00e9 o registrador que deve ser acessado para ativar o pullup? Answer pio_puer Each I/O line is designed with an embedded pull-up resistor and an embedded pull-down resistor. The pull-up resistor can be enabled or disabled by writing to the Pull-up Enable Register (PIO_PUER) or Pull-up Disable Register (PIO_PUDR), respectively. Note que a fun\u00e7\u00e3o pio_pull_up via o par\u00e2metro ul_pull_up_enable ativa e desativa o pull-up. Por conta disso voc\u00ea ter\u00e1 que usar os dois registradores: pio_puer / pio_pudr Modifique e teste Crie a fun\u00e7\u00e3o _pio_pull_up Substitua no c\u00f3digo toda ocorr\u00eancia de pio_pull_up por _pio_pull_up . Implemente Compile, programe e Teste Progress Pr\u00f3xima etapa .... _pio_set_input(...) Agora vamos criar uma nova fun\u00e7\u00e3o para configurar um pino como entrada, para isso inclua os seguintes defines que ser\u00e3o utilizados como forma de configura\u00e7\u00e3o da fun\u00e7\u00e3o: /* Default pin configuration (no attribute). */ #define _PIO_DEFAULT (0u << 0) /* The internal pin pull-up is active. */ #define _PIO_PULLUP (1u << 0) /* The internal glitch filter is active. */ #define _PIO_DEGLITCH (1u << 1) /* The internal debouncing filter is active. */ #define _PIO_DEBOUNCE (1u << 3) Esses defines ser\u00e3o passados como configura\u00e7\u00e3o da fun\u00e7\u00e3o _pio_set_input() no par\u00e2metro ul_attribute . Declare no seu c\u00f3digo a seguinte fun\u00e7\u00e3o: /** * \\brief Configure one or more pin(s) or a PIO controller as inputs. * Optionally, the corresponding internal pull-up(s) and glitch filter(s) can * be enabled. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask indicating which pin(s) to configure as input(s). * \\param ul_attribute PIO attribute(s). */ void _pio_set_input ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_attribute ) { } Para testar essa fun\u00e7\u00e3o substitua o seguinte trecho de c\u00f3digo que configura um pino como entrada + o pull-up pio_set_input ( BUT_PIO , BUT_PIO_IDX_MASK , _PIO_DEFAULT ); _pio_pull_up ( BUT_PIO , BUT_PIO_IDX_MASK , 1 ); Para: _pio_set_input ( BUT_PIO , BUT_PIO_IDX_MASK , _PIO_PULLUP | _PIO_DEBOUNCE ); Info Leia o manual do PIO, especificamente a sec\u00e7\u00e3o 32.5.9 . Tip Utilize a fun\u00e7\u00e3o j\u00e1 implementada _pio_pull_up() Modifique e teste Crie a fun\u00e7\u00e3o _pio_set_input Substitua no c\u00f3digo toda ocorr\u00eancia de pio_set_input por _pio_set_input . Implemente Compile, programe e teste Progress Pr\u00f3xima etapa .... _pio_set_output(...) Na aula passada utilizamos a fun\u00e7\u00e3o pio_set_output para configurarmos que o pino \u00e9 uma sa\u00edda. Iremos aqui definir uma nova fun\u00e7\u00e3o chamada de _pio_set_output() que implementa essa fun\u00e7\u00e3o. Defina no seu c\u00f3digo a fun\u00e7\u00e3o a seguir: /** * \\brief Configure one or more pin(s) of a PIO controller as outputs, with * the given default value. Optionally, the multi-drive feature can be enabled * on the pin(s). * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask indicating which pin(s) to configure. * \\param ul_default_level Default level on the pin(s). * \\param ul_multidrive_enable Indicates if the pin(s) shall be configured as * open-drain. * \\param ul_pull_up_enable Indicates if the pin shall have its pull-up * activated. */ void _pio_set_output ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_default_level , const uint32_t ul_multidrive_enable , const uint32_t ul_pull_up_enable ) { } Essa fun\u00e7\u00e3o \u00e9 um pouco mais complexa, e deve executar as seguintes configura\u00e7\u00f5es: Configurar o PIO para controlar o pino sec\u00e7\u00e3o 32.5.2 When a pin is multiplexed with one or two peripheral functions, the selection is controlled with the Enable Register (PIO_PER) and the Disable Register (PIO_PDR). The Status Register (PIO_PSR) is the result of the set and clear registers and indicates whether the pin is controlled by the corresponding peripheral or by the PIO Controller. Configurar o pino em modo sa\u00edda sec\u00e7\u00e3o 32.5.4 Definir a sa\u00edda inicial do pino ( 1 ou 0 ) aqui voc\u00ea pode fazer uso das duas fun\u00e7\u00f5es recentes implementadas. Ativar ou n\u00e3o o multidrive : Leia a sec\u00e7\u00e3o 32.5.6 Ativar ou n\u00e3o o pull-up : utilize a fun\u00e7\u00e3o _pio_pull_up() rec\u00e9m declarada. Uma vez implementada a fun\u00e7\u00e3o, utilize ela no seu c\u00f3digo substituindo a fun\u00e7\u00e3o pio_set_output() por essa fun\u00e7\u00e3o _pio_set_output() . Teste se o LED continua funcionando, se continuar quer dizer que sua fun\u00e7\u00e3o foi executada com sucesso. Tip Utilize as fun\u00e7\u00f5es j\u00e1 implementada _pio_set() , _pio_clear() , _pio_pull_up() Modifique e teste Crie a fun\u00e7\u00e3o _pio_set_output Substitua no c\u00f3digo toda ocorr\u00eancia de pio_set_output por _pio_set_output . Implemente Compile, programe e teste Progress At\u00e9 aqui j\u00e1 \u00e9 C!! Lembre de preencher o forms... Preencher ao finalizar o lab Carregando\u2026 Conceito B: _pio_get(...) Implemente a fun\u00e7\u00e3o _pio_get() : /** * \\brief Return 1 if one or more PIOs of the given Pin instance currently have * a high level; otherwise returns 0. This method returns the actual value that * is being read on the pin. To return the supposed output value of a pin, use * pio_get_output_data_status() instead. * * \\param p_pio Pointer to a PIO instance. * \\param ul_type PIO type. * \\param ul_mask Bitmask of one or more pin(s) to configure. * * \\retval 1 at least one PIO currently has a high level. * \\retval 0 all PIOs have a low level. */ uint32_t pio_get ( Pio * p_pio , const pio_type_t ul_type , const uint32_t ul_mask ) {} ul_type PIO_INPUT : quando for para ler uma entrada PIO_OUTPUT_0 : quando for para ler uma saida Tarefa: Modifique e teste Crie a fun\u00e7\u00e3o _pio_get() Substitua no c\u00f3digo todas as ocorr\u00eancias de pio_get por _pio_get() Implemente Compile, programe e teste Conceito A: _delay_ms(...) Crie sua Pr\u00f3pria fun\u00e7\u00e3o de delay_ms Tarefa: Modifique e teste Crie a fun\u00e7\u00e3o _delay_ms() Substitua no c\u00f3digo todas as ocorr\u00eancias de delay_ms por _delay_ms() Implemente Compile, programe e teste","title":"Lab"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER/#lab-pio-driver","text":"Nessa aula iremos utilizar como projeto refer\u00eancia o LAB-1.","title":"LAB - PIO - DRIVER"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER/#entrega","text":"Pasta: /Lab2-PIO-Driver Data LIMITE para entrega: 28/08/22 - 23h59 Como come\u00e7ar: Voc\u00eas devem realizar uma c\u00f3pia do LAB-1 que est\u00e1 no seu reposit\u00f3rio para a pasta Lab2-PIO-Driver , iremos modificar o que fizemos no laborat\u00f3rio passado. A entrega continua sendo feita pelo reposit\u00f3rio que foi gerado no laborat\u00f3rio passado. O objetivo desse laborat\u00f3rio \u00e9 o do entendimento das fun\u00e7\u00f5es utilizadas para configurar o PIO. Como um pino \u00e9 configurado como sa\u00edda e entrada? Como o firmware manipula o perif\u00e9rico PIO? Entender o que o PIO \u00e9 capaz de fazer. Para isso iremos aqui implementar nossas pr\u00f3prias fun\u00e7\u00f5es de interface com o PIO. Ao final do lab, dever\u00e3o ter implementado as seguintes fun\u00e7\u00f5es: C: _pio_set(...) _pio_clear(...) _pio_pull_up(...) _pio_set_input(...) _pio_set_output(...) B: _pio_get(...) A: _delay_ms(...)","title":"Entrega"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER/#driver","text":"Vamos implementar uma s\u00e9rie de fun\u00e7\u00f5es que ir\u00e3o configurar o perif\u00e9rico PIO via a escrita em seu banco de registradores. Para isso ser\u00e1 necess\u00e1rio ler o manual do uC mais especificamente a sec\u00e7\u00e3o do PIO - p\u00e1g. 344 . Progress Click para continuar....","title":"Driver"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER/#_pio_set","text":"Iremos come\u00e7ar com essa fun\u00e7\u00e3o que \u00e9 uma das mais simples. Crie uma fun\u00e7\u00e3o no main.c com a seguinte estrutura: /** * \\brief Set a high output level on all the PIOs defined in ul_mask. * This has no immediate effects on PIOs that are not output, but the PIO * controller will save the value if they are changed to outputs. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. */ void _pio_set ( Pio * p_pio , const uint32_t ul_mask ) { } Tip Lembre que essa fun\u00e7\u00e3o serve para acionarmos um pino digital quando o mesmo \u00e9 configurado como output (fazer ele virar 3.3V ). Na primeira etapa iremos substituir a fun\u00e7\u00e3o que a Microchip j\u00e1 nos disponibiliza por uma criada por n\u00f3s, em todo lugar no c\u00f3digo que voc\u00ea faz o uso da fun\u00e7\u00e3o pio_set(...) substitua a chamada por essa rec\u00e9m criada _pio_set(...) . pio_set Crie a fun\u00e7\u00e3o _pio_set() Substitua no c\u00f3digo toda ocorr\u00eancia de pio_set() pela _pio_set() . Execute o c\u00f3digo, ele n\u00e3o deve funcionar . pois agora a fun\u00e7\u00e3o que aciona um pino n\u00e3o est\u00e1 implementada. Progress Pr\u00f3xima etapa .... Agora ser\u00e1 necess\u00e1rio entender como o PIO controla os pinos e o que deve ser feito para que ele atue sobre o pino como desejamos. A parte da sec\u00e7\u00e3o do manual que fala sobre o PIO e suas sa\u00eddas/entradas \u00e9 a sec\u00e7\u00e3o 32 do ( manual SAME70 ), vamos analisar: SAME70-Manual: 32.5.4 Output Control Texto extra\u00eddo do manual: The level driven on an I/O line can be determined by writing in the Set Output Data Register ( PIO_SODR ) and the Clear Output Data Register (PIO_CODR). These write operations, respectively, set and clear the Output Data Status Register (PIO_ODSR), which represents the data driven on the I/O lines**. Writing in PIO_OER and PIO_ODR manages PIO_OSR whether the pin is configured to be controlled by the PIO Controller or assigned to a peripheral function. This enables configuration of the I/O line prior to setting it to be managed by the PIO Controller. Lendo o texto, podemos descobrir que para termos 1 ( set ) no pino devemos escrever no registrador PIO_SODR , no manual tem mais detalhes sobre tudo do PIO. Vamos analisar a documenta\u00e7\u00e3o especifica deste registrador ( SODR ): Repare que esse registrador \u00e9 do tipo write-only ou seja ele n\u00e3o pode ser lido, somente escrito. Cada bit desse registrador representa um pino, se pegarmos por exemplo o bit 30 desse registrador (pensando no PIOA) estar\u00edamos nos referindo ao PA30 , qualquer altera\u00e7\u00e3o ESCRITA nesse bit influenciar\u00e1 SOMENTE esse pino. Note Todos os registradores est\u00e3o listados e explicados no datasheet, de uma olhada na p\u00e1gina 362 , a descri\u00e7\u00e3o come\u00e7a ai. Agora que j\u00e1 sabemos o que deve ser feito para colocarmos acionarmos um pino (ativar) e considerando que ele j\u00e1 foi configurado como sa\u00edda podemos escrever a implementa\u00e7\u00e3o da fun\u00e7\u00e3o: void _pio_set ( Pio * p_pio , const uint32_t ul_mask ) { p_pio -> PIO_SODR = ul_mask ; } *p_pio : \u00e9 um endere\u00e7o recebido do tipo Pio, ele indica o endere\u00e7o de mem\u00f3ria na qual o PIO (perif\u00e9rico) em quest\u00e3o est\u00e1 mapeado (vamos ver isso em detalhes). ul_mask : \u00e9 a m\u00e1scara na qual iremos aplicar ao registrador que controla os pinos para colocarmos 1 na sa\u00edda. O que isso significa? Significa que estamos acessando o perif\u00e9rico passado como refer\u00eancia a fun\u00e7\u00e3o (um dos cinco PIO dispon\u00edveis no uc: PIOA , PIOB , PIOC , ...) e estamos aplicando a m\u00e1scara ul_mask no seu registrador PIO_SODR . Pio type? O tipo Pio \u00e9 uma struct alinhada com o endere\u00e7o de mem\u00f3ria do perif\u00e9rico, onde cada 'item' dessa struct representa um endere\u00e7o da mem\u00f3ria do perif\u00e9rico, essa \u00e9 uma maneira em C de darmos nome a endere\u00e7os de mem\u00f3ria. Isso j\u00e1 est\u00e1 definido no projeto quando usamos o asf (para facilitar nossa vida): O PIOA \u00e9 um struct que aponta para o endere\u00e7o 0x400E0E00 #define PIOA ((Pio *)0x400E0E00U) /**< \\brief (PIOA ) Base Address */ O struct possui a seguinte estrutura: typedef struct { __O uint32_t PIO_PER ; /**< \\brief (Pio Offset: 0x0000) PIO Enable Register */ __O uint32_t PIO_PDR ; /**< \\brief (Pio Offset: 0x0004) PIO Disable Register */ __I uint32_t PIO_PSR ; /**< \\brief (Pio Offset: 0x0008) PIO Status Register */ __I uint32_t Reserved1 [ 1 ]; __O uint32_t PIO_OER ; /**< \\brief (Pio Offset: 0x0010) Output Enable Register */ __O uint32_t PIO_ODR ; /**< \\brief (Pio Offset: 0x0014) Output Disable Register */ __I uint32_t PIO_OSR ; /**< \\brief (Pio Offset: 0x0018) Output Status Register */ __I uint32_t Reserved2 [ 1 ]; __O uint32_t PIO_IFER ; /**< \\brief (Pio Offset: 0x0020) Glitch Input Filter Enable Register */ __O uint32_t PIO_IFDR ; /**< \\brief (Pio Offset: 0x0024) Glitch Input Filter Disable Register */ Onde: O , I s\u00e3o macros que bloqueiam os endere\u00e7os para: __O : Apenas escrita (output) __I : Apenas Leitura (input) __IO : Leitura e Escrita (input/output) #ifdef __cplusplus #define __I volatile /*!< Defines 'read only' permissions */ #else #define __I volatile const /*!< Defines 'read only' permissions */ #endif #define __O volatile /*!< Defines 'write only' permissions */ #define __IO volatile /*!< Defines 'read / write' permissions */ O diagrama a seguir ilustra o que acontece quando fazemos: p_pio->PIO_SODR = ul_mask; Teste A fun\u00e7\u00e3o est\u00e1 pronta, agora precisamos testar. Com a modifica\u00e7\u00e3o no c\u00f3digo fa\u00e7a a grava\u00e7\u00e3o do uC e ele deve voltar a piscar o LED quando voc\u00ea aperta o bot\u00e3o. Agora a fun\u00e7\u00e3o implementada possui a mesma funcionalidade daquela fornecida pelo fabricante. Embarque o c\u00f3digo e o mesmo deve funcionar normalmente caso a fun\u00e7\u00e3o implementada esteja correta. Progress Pr\u00f3xima etapa ....","title":"_pio_set(...)"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER/#_pio_clear","text":"Fa\u00e7a o mesmo para a fun\u00e7\u00e3o clear: /** * \\brief Set a low output level on all the PIOs defined in ul_mask. * This has no immediate effects on PIOs that are not output, but the PIO * controller will save the value if they are changed to outputs. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. */ void _pio_clear ( Pio * p_pio , const uint32_t ul_mask ) { } Exercise Consultando a sec\u00e7\u00e3o 32.5.4 do manual do microcontrolador, qual \u00e9 o registrador que deve ser acessado para colocar zero no pino? Answer pio_codr The level driven on an I/O line can be determined by writing in the Set Output Data Register (PIO_SODR) and the Clear Output Data Register (PIO_CODR) . These write operations, respectively, set and clear the Output Data Status Register (PIO_ODSR), which represents the data driven on the I/O lines. Writing in PIO_OER and PIO_ODR manages PIO_OSR whether the pin is configured to be controlled by the PIO Controller or assigned to a peripheral function. This enables configuration of the I/O line prior to setting it to be managed by the PIO Controller. Modifique e teste Crie a fun\u00e7\u00e3o _pio_clear() Substitua no c\u00f3digo toda ocorr\u00eancia de pio_clear por _pio_clear Implemente a fun\u00e7\u00e3o. Compile, programe e teste Progress Pr\u00f3xima etapa ....","title":"_pio_clear(...)"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER/#_pio_pull_up","text":"Warning S\u00f3 continue se a implementa\u00e7\u00e3o anterior funcionou. Vamos implementar uma fun\u00e7\u00e3o que faz a configura\u00e7\u00e3o do pullup nos pinos do PIO, esse pullup \u00e9 utilizado no bot\u00e3o da placa. Para isso declare a fun\u00e7\u00e3o a seguir: /** * \\brief Configure PIO internal pull-up. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask of one or more pin(s) to configure. * \\param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be * configured. */ void _pio_pull_up ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_pull_up_enable ){ } Essa fun\u00e7\u00e3o recebe o PIO que ir\u00e1 configurar, os pinos que ser\u00e3o configurados e como \u00faltimo par\u00e2metro se o pullup estar\u00e1 ativado (1) ou desativado (0). Info Leia o manual do PIO, especificamente a sec\u00e7\u00e3o 32.5.1 . Exercise Consultando a sec\u00e7\u00e3o 32.5.1 do manual do microcontrolador, qual \u00e9 o registrador que deve ser acessado para ativar o pullup? Answer pio_puer Each I/O line is designed with an embedded pull-up resistor and an embedded pull-down resistor. The pull-up resistor can be enabled or disabled by writing to the Pull-up Enable Register (PIO_PUER) or Pull-up Disable Register (PIO_PUDR), respectively. Note que a fun\u00e7\u00e3o pio_pull_up via o par\u00e2metro ul_pull_up_enable ativa e desativa o pull-up. Por conta disso voc\u00ea ter\u00e1 que usar os dois registradores: pio_puer / pio_pudr Modifique e teste Crie a fun\u00e7\u00e3o _pio_pull_up Substitua no c\u00f3digo toda ocorr\u00eancia de pio_pull_up por _pio_pull_up . Implemente Compile, programe e Teste Progress Pr\u00f3xima etapa ....","title":"_pio_pull_up(...)"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER/#_pio_set_input","text":"Agora vamos criar uma nova fun\u00e7\u00e3o para configurar um pino como entrada, para isso inclua os seguintes defines que ser\u00e3o utilizados como forma de configura\u00e7\u00e3o da fun\u00e7\u00e3o: /* Default pin configuration (no attribute). */ #define _PIO_DEFAULT (0u << 0) /* The internal pin pull-up is active. */ #define _PIO_PULLUP (1u << 0) /* The internal glitch filter is active. */ #define _PIO_DEGLITCH (1u << 1) /* The internal debouncing filter is active. */ #define _PIO_DEBOUNCE (1u << 3) Esses defines ser\u00e3o passados como configura\u00e7\u00e3o da fun\u00e7\u00e3o _pio_set_input() no par\u00e2metro ul_attribute . Declare no seu c\u00f3digo a seguinte fun\u00e7\u00e3o: /** * \\brief Configure one or more pin(s) or a PIO controller as inputs. * Optionally, the corresponding internal pull-up(s) and glitch filter(s) can * be enabled. * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask indicating which pin(s) to configure as input(s). * \\param ul_attribute PIO attribute(s). */ void _pio_set_input ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_attribute ) { } Para testar essa fun\u00e7\u00e3o substitua o seguinte trecho de c\u00f3digo que configura um pino como entrada + o pull-up pio_set_input ( BUT_PIO , BUT_PIO_IDX_MASK , _PIO_DEFAULT ); _pio_pull_up ( BUT_PIO , BUT_PIO_IDX_MASK , 1 ); Para: _pio_set_input ( BUT_PIO , BUT_PIO_IDX_MASK , _PIO_PULLUP | _PIO_DEBOUNCE ); Info Leia o manual do PIO, especificamente a sec\u00e7\u00e3o 32.5.9 . Tip Utilize a fun\u00e7\u00e3o j\u00e1 implementada _pio_pull_up() Modifique e teste Crie a fun\u00e7\u00e3o _pio_set_input Substitua no c\u00f3digo toda ocorr\u00eancia de pio_set_input por _pio_set_input . Implemente Compile, programe e teste Progress Pr\u00f3xima etapa ....","title":"_pio_set_input(...)"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER/#_pio_set_output","text":"Na aula passada utilizamos a fun\u00e7\u00e3o pio_set_output para configurarmos que o pino \u00e9 uma sa\u00edda. Iremos aqui definir uma nova fun\u00e7\u00e3o chamada de _pio_set_output() que implementa essa fun\u00e7\u00e3o. Defina no seu c\u00f3digo a fun\u00e7\u00e3o a seguir: /** * \\brief Configure one or more pin(s) of a PIO controller as outputs, with * the given default value. Optionally, the multi-drive feature can be enabled * on the pin(s). * * \\param p_pio Pointer to a PIO instance. * \\param ul_mask Bitmask indicating which pin(s) to configure. * \\param ul_default_level Default level on the pin(s). * \\param ul_multidrive_enable Indicates if the pin(s) shall be configured as * open-drain. * \\param ul_pull_up_enable Indicates if the pin shall have its pull-up * activated. */ void _pio_set_output ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_default_level , const uint32_t ul_multidrive_enable , const uint32_t ul_pull_up_enable ) { } Essa fun\u00e7\u00e3o \u00e9 um pouco mais complexa, e deve executar as seguintes configura\u00e7\u00f5es: Configurar o PIO para controlar o pino sec\u00e7\u00e3o 32.5.2 When a pin is multiplexed with one or two peripheral functions, the selection is controlled with the Enable Register (PIO_PER) and the Disable Register (PIO_PDR). The Status Register (PIO_PSR) is the result of the set and clear registers and indicates whether the pin is controlled by the corresponding peripheral or by the PIO Controller. Configurar o pino em modo sa\u00edda sec\u00e7\u00e3o 32.5.4 Definir a sa\u00edda inicial do pino ( 1 ou 0 ) aqui voc\u00ea pode fazer uso das duas fun\u00e7\u00f5es recentes implementadas. Ativar ou n\u00e3o o multidrive : Leia a sec\u00e7\u00e3o 32.5.6 Ativar ou n\u00e3o o pull-up : utilize a fun\u00e7\u00e3o _pio_pull_up() rec\u00e9m declarada. Uma vez implementada a fun\u00e7\u00e3o, utilize ela no seu c\u00f3digo substituindo a fun\u00e7\u00e3o pio_set_output() por essa fun\u00e7\u00e3o _pio_set_output() . Teste se o LED continua funcionando, se continuar quer dizer que sua fun\u00e7\u00e3o foi executada com sucesso. Tip Utilize as fun\u00e7\u00f5es j\u00e1 implementada _pio_set() , _pio_clear() , _pio_pull_up() Modifique e teste Crie a fun\u00e7\u00e3o _pio_set_output Substitua no c\u00f3digo toda ocorr\u00eancia de pio_set_output por _pio_set_output . Implemente Compile, programe e teste Progress At\u00e9 aqui j\u00e1 \u00e9 C!! Lembre de preencher o forms... Preencher ao finalizar o lab Carregando\u2026","title":"_pio_set_output(...)"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER/#conceito-b-_pio_get","text":"Implemente a fun\u00e7\u00e3o _pio_get() : /** * \\brief Return 1 if one or more PIOs of the given Pin instance currently have * a high level; otherwise returns 0. This method returns the actual value that * is being read on the pin. To return the supposed output value of a pin, use * pio_get_output_data_status() instead. * * \\param p_pio Pointer to a PIO instance. * \\param ul_type PIO type. * \\param ul_mask Bitmask of one or more pin(s) to configure. * * \\retval 1 at least one PIO currently has a high level. * \\retval 0 all PIOs have a low level. */ uint32_t pio_get ( Pio * p_pio , const pio_type_t ul_type , const uint32_t ul_mask ) {} ul_type PIO_INPUT : quando for para ler uma entrada PIO_OUTPUT_0 : quando for para ler uma saida Tarefa: Modifique e teste Crie a fun\u00e7\u00e3o _pio_get() Substitua no c\u00f3digo todas as ocorr\u00eancias de pio_get por _pio_get() Implemente Compile, programe e teste","title":"Conceito B: _pio_get(...)"},{"location":"navigation/Labs/Lab_DRIVER/Lab-PIO-DRIVER/#conceito-a-_delay_ms","text":"Crie sua Pr\u00f3pria fun\u00e7\u00e3o de delay_ms Tarefa: Modifique e teste Crie a fun\u00e7\u00e3o _delay_ms() Substitua no c\u00f3digo todas as ocorr\u00eancias de delay_ms por _delay_ms() Implemente Compile, programe e teste","title":"Conceito A: _delay_ms(...)"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/","text":"LAB - ECG Neste laborat\u00f3rio iremos processar e exibir o sinal de um electrocardiograma (ECG). Lab Exemplo base LAB SAME70-Examples/Demos/ECG Lab8-RTOS-ECG C\u00f3digo exemplo Vamos modificar o c\u00f3digo exemplo SAME70-examples/Demos/ECG/ , fa\u00e7a uma c\u00f3pia para o seu reposit\u00f3rio de laborat\u00f3rios renomeando para Labs8-RTOS-ECG . Perif\u00e9ricos utilizados no lab Por voc\u00eas: AFEC1 (EXT1 PC31), canal 6 TC1 canal 1 RTT Indiretamente (o projeto j\u00e1 usa para gerar o ECG): DAC0 (PB13) TC0 canal 0 Conectando Info Voc\u00ea deve ter o LCD conectado na placa. Vamos conectar o pino PB13 que gera o sinal o sinal anal\u00f3gico do batimento card\u00edaco ao pino PC31 do EXT1 que possui o AFEC1 conforme imagem e diagrama a baixo: Imagem Manual Diagrama \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502afec \u2502\u25c4\u251c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 ecg \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 tc0 \u251c\u2500\u25ba\u2502dac \u251c\u2500x\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 PB13 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Progress Click para continuar.... ECG O sinal ECG gerado no pino PB13 possui a forma de onda a seguir: E se analisarmos o espectro do sinal via transformada de fourier, obtemos a seguinte composi\u00e7\u00e3o espectral: Question O que voc\u00ea consegue extrair de informa\u00e7\u00f5es dos gr\u00e1ficos anteriores? No primeiro (ecg no tempo) podemos ver claramente que existe uma alta frequ\u00eancia no sinal, mas que o envelope \u00e9 a informa\u00e7\u00e3o do ecg. J\u00e1 no fourier somos capazes se distinguir que existem duas regi\u00f5es com bastante informa\u00e7\u00f5es, uma de baixa frqu\u00eancia (0..25)Hz e outra de 60Hz. Progress Click para continuar.... 60 Hz Notamos claramente que existe um sinal centrada em 60Hz, isso \u00e9 muito comum quando trabalhamos com eletr\u00f4nica e reflete o 60Hz da rede el\u00e9trica que \u00e9 propagada de diversas formas para o transdutor respons\u00e1vel em amostrar o dado do pulso el\u00e9trico do corpo humano, causando um ru\u00eddo no sinal n\u00e3o desej\u00e1vel. Para tararmos o dado corretamente teremos que filtra o ru\u00eddo. Lembre que em alguns pa\u00edses a frequ\u00eancia da rede el\u00e9trica \u00e9 de 50Hz e n\u00e3o de 60Hz como no Brasil. Info O som desse ru\u00eddo em 60hz \u00e9 chamado de Zumbido el\u00e9trico soa como: Progress Click para continuar.... Task process Vamos criar uma tarefa no RTOS que ser\u00e1 respons\u00e1vel por processar os dados do ECG, iremos chamar a tarefa de task_process . Essa tarefa ir\u00e1 receber os dados da convers\u00e3o anal\u00f3gica, processar e extrair informa\u00e7\u00f5es e retornar enviar os dados para a task_main . Tarefa: task_process Crie uma tarefa chamada de task_process , ela pode estar vazia por hora. N\u00e3o esque\u00e7a do while(1) e de criar ela na fun\u00e7\u00e3o main ( xTaskCreate ). Progress Click para continuar.... Leitura anal\u00f3gica Para come\u00e7armos precisamos ler o valor do ECG que est\u00e1 sendo gerado no pino PB13, para isso iremos configurar a leitura anal\u00f3gica no AFEC1 canal 6. A leitura anl\u00f3gica deve ser executada a 250 Hz, para garantirmos que estaremos lendo a uma taxa de amostragem fixa, vamos configurar um TC para fazer a convers\u00e3o do sinal. O valor convertido deve ser colocado em uma fila para processamento futuro, como indicado a seguir: Info Taxa de amostragem fixa simplifica muito o processamento de sinais digitais, muitas t\u00e9cnicas assumem que o valor \u00e9 constante. A forma como fizemos no laborat\u00f3rio do AFEC n\u00e3o \u00e9 boa aqui, porque l\u00e1 us\u00e1vamos uma tarefa do RTOS para gerar a taxa de amostragem ( vtaskDelay ) e isso n\u00e3o garante que tenhamos uma taxa fixa, pois n\u00e3o \u00e9 garantido que a taref\u00e1 v\u00e1 executar exatamente no delay proposto (outras tar\u00e9fas de prioridade superior podem estar executando). Al\u00e9m disso, o uso de uma task para gerar a taxa de amostragem limita a taxa que podemos usar, o RTOS executa no m\u00e1ximo a 1000Hz. Question Qual handler \u00e9 referente ao TC1 canal 0? TC6_Handler TC1_Handler TC3_Handler Tarefa: Lendo dados No come\u00e7o da task_process : Criar uma fila de inteiros xQueueECG de tamanho 250 Configurar TC1 canal 0 para gerar uma interrup\u00e7\u00e3o a cada 250Hz Configurar leitura no AFEC 1 canal 6 Handlers/Callbacks: No TC3_Handler inicializar a convers\u00e3o do AFEC1 canal 6 Isso vai fazer que com que tenhamos 250 amostras por segundo do ECG. No callback do AFEC ler o dado e colocar na fila xQueueECG Dentro do while da task_process : Ler o dado da fila xQueueECG e imprimir no terminal. Validar: Executar o programar, abrir o terminal e obter dados que variam no tempo (entre 0 e 3000). Progress Click para continuar.... Retransmitindo o dado Uma boa pr\u00e1tica \u00e9 atualizar o LCD apenas em uma tarefa, o LVGL n\u00e3o \u00e9 thread-safe by default , como o site indica na p\u00e1gina p\u00e1gina: https://docs.lvgl.io/latest/en/html/porting/os.html Isso significa que n\u00e3o podemos chamar uma fun\u00e7\u00e3o do LVGL enquanto a anterior n\u00e3o tenha terminado de executar, e caso implementemos o acesso ao LCD em v\u00e1rias partes do nosso programa corremos grande risco disso acontecer (lembrem que o RTOS interrompe uma tarefa para permitir que outra execute, e isso pode ser no meio da fun\u00e7\u00e3o por exemplo de mudar o valor do label). Info O site indica o uso de mutex para solucionar este problema, voc\u00eas ter\u00e3o isso em Sistemas Hw Sw. Para n\u00e3o termos que usar mutex, vamos atualizar o LCD apenas em uma das tasks, eu sugiro fazermos isso na task_main . Por conta disso iremos retransmitir o dado da fila do ECG para a task_main por outra fila: xQueueEcgInfo que ser\u00e1 do uma struct contendo dois inteiros: ecg e bpm . A ideia aqui \u00e9 que a task_process ir\u00e1 pegar os dados do ECG, processar e extrair o valor da frequ\u00eancia cardiaca (em batimentos por minuto) e retransmitir para a task_main exibir no LCD. Tarefa: Retransmitindo Vamos restransmitir o dado do ecg da task_process para a task_main . task_process : Cirei uma struct ecgInfo com dois par\u00e2metros inteiros: ecg, bpm. Crie uma fila xQueueEcgInfo capaz de armazenar at\u00e9 32 valores do ecgInfo Dica: Sugerirmos criar na fun\u00e7\u00e3o main, antes de iniciarem as tasks. Fa\u00e7a o envio do dado do Ecg da task_process para a task_main , coloque qualquer valor no bpm. task_main : Fa\u00e7a a leitura da fila xQueueEcgInfo Altere o printf da task_process para task_main para validar a transmiss\u00e3o dos dados. Warning Cuidado para n\u00e3o usar fun\u00e7\u00f5es que terminam com FromISR quando estiver interagindo com o RTOS de dentro de tarefas. Progress Click para continuar.... Exibindo gr\u00e1fico Agora que j\u00e1 temos o caminho do dado pronto vamos exibir no LCD usando o widget lv_chart . O site explica v\u00e1rios modos de fazer isso, eu irei sugerir um que fiz e funcionou bem. Primeiro teremos que criar um vetor global ( int ser1_data[250] ) que ir\u00e1 armazenar os pontos do gr\u00e1fico, o vetor precisa ter o tamanho da quantidade de pontos que queremos exibir. Vamos come\u00e7ar com 250, depois voc\u00eas podem ajustar at\u00e9 encontrarem um valor adequado. Depois precisamos criar o ponteiro para o gr\u00e1fico ( lv_obj_t * chart; ) e para a s\u00e9rie do ( ser1 ) tamb\u00e9m global (assim como fazermos para os labels e bot\u00f5es). E ent\u00e3o inicializar o gr\u00e1fico. Aqui eu irei fazer na fun\u00e7\u00e3o lv_screen_chart que deve ser chamada no come\u00e7o da task_LCD , como demonstrado a seguir: Tarefa: chart Insira o c\u00f3digo a seguir (vari\u00e1veis globais e fun\u00e7\u00e3o): // globais #define CHAR_DATA_LEN 250 int ser1_data [ CHAR_DATA_LEN ]; lv_obj_t * chart ; lv_chart_series_t * ser1 ; // Desenha gr\u00e1fico no LCD void lv_screen_chart ( void ) { chart = lv_chart_create ( lv_scr_act (), NULL ); lv_obj_set_size ( chart , 300 , 250 ); lv_obj_align ( chart , NULL , LV_ALIGN_IN_BOTTOM_MID , 0 , 0 ); lv_chart_set_type ( chart , LV_CHART_TYPE_LINE ); lv_chart_set_range ( chart , 0 , 4095 ); lv_chart_set_point_count ( chart , CHAR_DATA_LEN ); lv_chart_set_div_line_count ( chart , 0 , 0 ); lv_chart_set_update_mode ( chart , LV_CHART_UPDATE_MODE_SHIFT ); ser1 = lv_chart_add_series ( chart , LV_COLOR_BLUE ); lv_chart_set_ext_array ( chart , ser1 , ser1_data , CHAR_DATA_LEN ); lv_obj_set_style_local_line_width ( chart , LV_CHART_PART_SERIES , LV_STATE_DEFAULT , 1 ); } Fa\u00e7a as modifica\u00e7\u00f5es como indicado a seguir: static void task_lcd(void *pvParameters) { + lv_screen_chart(); for (;;) { lv_tick_inc(50); lv_task_handler(); vTaskDelay(50); } } Progress Click para continuar.... Agora temos que modificar a fun\u00e7\u00e3o task_main para toda hora que receber um novo valor na fila xQueueEcgInfo ela atualizar o gr\u00e1fico. Para isso iremos usar a fun\u00e7\u00e3o lv_chart_set_next(chart, ser1, value) , ap\u00f3s termos atualizado a s\u00e9rie precisamos indicar ao LVGL que \u00e9 para atualizar o gr\u00e1fico, isso \u00e9 feito pela fun\u00e7\u00e3o lv_chart_refresh(chart) . Mais inform\u00e7\u00f5es na p\u00e1gina do widget: https://docs.lvgl.io/latest/en/html/widgets/chart.html#overview Com isso voc\u00eas devem obter algo como: Tarefa: Exibindo Agora modifique o firmware para atualizar o dado da s\u00e9rie e exibir o dado toda vez que receber um dado novo na fila xQueueEcgInfo . Para isso v\u00e3o precisar usar as duas fun\u00e7\u00f5es a seguir: // novo valor | // v lv_chart_set_next ( chart , ser1 , value ); lv_chart_refresh ( chart ); Programe e teste na placa Tip Dica do Carlos Dip. Para tirar os pontos do gr\u00e1fico execute: lv_obj_set_style_local_size(chart, LV_CHART_PART_SERIES, LV_STATE_DEFAULT, LV_DPI/150); Progress Click para continuar.... Frequ\u00eancia cardiaca Agora vamos modificar a task_process para detectar a frequ\u00eancia cardiaca, na literatura existem v\u00e1rias maneiras (bem mais correta da qual eu irei propor) o artigo a seguir explora algumas das maneiras: Par\u00e1k, Jakub, and Jan Havl\u00edk. \"ECG signal processing and heart rate frequency detection methods.\" Proceedings of Technical Computing Prague 8 (2011): 2011. A ideia principal \u00e9 detectar o intervalo de tempo entre cada pico: A implementa\u00e7\u00e3o que iremos fazer aqui envolve aplicar um threshold no valor e esperar at\u00e9 o pr\u00f3ximo pico, calculando o tempo entre os dois sinais. Question No exemplo anterior qual o valor da frequ\u00eancia cardiaca em batimento por minuto? 80 0.75 75 A conta a ser feita \u00e9 Econtra dT = 0.75s Do dT calcula a frequ\u00eancia em Hz -> 1/dT: 1.33 Hz = 1/s, multiplica por 60 para encontrar a frequ\u00eancia em minuto: 1.33*60 = 80 bpm Progress Click para continuar.... RTT Para calcularmos o dT iremos usar o perif\u00e9rico RTT, que ficar\u00e1 gerando pulsos e depois iremos verificar quantos pulsos aconteceram no intervalo entre um pico e outro e ent\u00e3o estimar o valor do dT . O RTT ser\u00e1 configurado para operar a uma taxa de 1000Hz, ou seja, 1000 pulsos por segundo, isso nos dar\u00e1 uma boa resolu\u00e7\u00e3o. Neste caso n\u00e3o iremos usar a interrup\u00e7\u00e3o do RTT de alarme, mas sim a de tempo (que vai ocorrer 1000x por segundo). Sempre que ela ocorrer, iremos incrementar um contador global que ser\u00e1 nosso dT. Esse contador ser\u00e1 zerado a cada pulso. Tarefa: Inicialize o RTT O RTT deve ser inicializado na task_process . Crie uma vari\u00e1vel global g_dT Inicialize o RTT para operar a 1000Hz n\u00e3o vamos usar o alarme, coloque qualquer valor. A cada interrup\u00e7\u00e3o de tick do RTT, incremente a vari\u00e1vel g_dT Progress Click para continuar.... Threshold Iremos aplicar o threshold e procurar por valores que nos ajudem a encontra o pico, isso ser\u00e1 feito sempre que um novo dado chegar na fila xQueueEcg . Tarefa: threshold Para cada dado recebido na fila do ecg aplique o threshold e imprima o valor encontrado e seu dT, lembre de zerar o dT. Sugerimos aplicar 3280 como threshold. Exemplo if ( xQueueReceive ( xQueueAdc , & adc , 50 )) { // ... // ... if ( adc > 3280 ){ printf ( \"%d: %d ms \\n \" , adc , g_dT ); // come\u00e7amos a contar novamente g_dT = 0 ; } } Progress Click para continuar.... Melhorando A implementa\u00e7\u00e3o anterior n\u00e3o funciona muito bem, as vezes encontramos mais de um valor no mesmo pico dentro do range estipulado: Melhorando Fa\u00e7a alguma m\u00e1gica para desconsiderar mais de um ponto no mesmo pico. Lembre de validar com os dados no terminal, seus dT devem ser no m\u00ednimo maior que 20 ms. Tip Para valorizar os picos do sinal voc\u00eas poderiam usar a energia dele (E(t) = ecg(t)^2), a energia de um sinal valoriza seus picos. Se for usar energia lembre de ajustar o valor do threshold. Progress Click para continuar.... Calculando bpm Agora com o dT correto conseguimos converter a informa\u00e7\u00e3o para bpm. Tarefa: bpm Calcule o bpm do ecg e imprima no terminal. Verifique se est\u00e1 dentro do range v\u00e1lido. O valor deve variar ligeramente no tempo e ficar entre 60 bpm e 80. Progress Click para continuar.... Exibindo Agora que temos o valor do bpm, vamos enviar essa informa\u00e7\u00e3o junto com o ecg para a task_main via a fila xQueueEcgInfo (lembra que criamos uma struct?). Com a informa\u00e7\u00e3o na tarefa que atualiza o LCD, conseguimos criar um label e exibir o valor na tela junto com o gr\u00e1fico. O resultado esperado \u00e9 algo como: Tarefa: Exibindo Execute: Envie o dado do bpm para a task_main via a fila Crie um label novo para exibir a informa\u00e7\u00e3o A cada novo dado na fila atualize o valor do label. Tip Caso queira que o valor da frequ\u00eancia mude com maior periodicidade, altera o define ECG_CHANGE_TIME que est\u00e1 no arquivo aps2/aps2.h , este define especifica (em ms) a cada quanto tempo o valor do delay entre um pulso e outro ser\u00e1 atualizado. Sugest\u00e3o de valor: 1000 (1 segundo) Info At\u00e9 aqui \u00e9 C. Preencher ao finalizar o lab Carregando\u2026 Progress Click para continuar.... B/A Adicionar beep com o buzzer, conforme frequ\u00eancia. Procurar pico usando a energia do sinal do sinal no lugar do valor no tempo. Info O que mais poderiamos fazer? Filtrar o sinal Fazer o threshold ser din\u00e2mico (o valor que detecta pico) Deixar gr\u00e1fico mais bonito","title":"LAB - ECG"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#lab-ecg","text":"Neste laborat\u00f3rio iremos processar e exibir o sinal de um electrocardiograma (ECG).","title":"LAB - ECG"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#lab","text":"Exemplo base LAB SAME70-Examples/Demos/ECG Lab8-RTOS-ECG C\u00f3digo exemplo Vamos modificar o c\u00f3digo exemplo SAME70-examples/Demos/ECG/ , fa\u00e7a uma c\u00f3pia para o seu reposit\u00f3rio de laborat\u00f3rios renomeando para Labs8-RTOS-ECG . Perif\u00e9ricos utilizados no lab Por voc\u00eas: AFEC1 (EXT1 PC31), canal 6 TC1 canal 1 RTT Indiretamente (o projeto j\u00e1 usa para gerar o ECG): DAC0 (PB13) TC0 canal 0","title":"Lab"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#conectando","text":"Info Voc\u00ea deve ter o LCD conectado na placa. Vamos conectar o pino PB13 que gera o sinal o sinal anal\u00f3gico do batimento card\u00edaco ao pino PC31 do EXT1 que possui o AFEC1 conforme imagem e diagrama a baixo: Imagem Manual Diagrama \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502afec \u2502\u25c4\u251c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 ecg \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 tc0 \u251c\u2500\u25ba\u2502dac \u251c\u2500x\u2500\u2500\u2500\u2500\u2518 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 PB13 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Progress Click para continuar....","title":"Conectando"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#ecg","text":"O sinal ECG gerado no pino PB13 possui a forma de onda a seguir: E se analisarmos o espectro do sinal via transformada de fourier, obtemos a seguinte composi\u00e7\u00e3o espectral: Question O que voc\u00ea consegue extrair de informa\u00e7\u00f5es dos gr\u00e1ficos anteriores? No primeiro (ecg no tempo) podemos ver claramente que existe uma alta frequ\u00eancia no sinal, mas que o envelope \u00e9 a informa\u00e7\u00e3o do ecg. J\u00e1 no fourier somos capazes se distinguir que existem duas regi\u00f5es com bastante informa\u00e7\u00f5es, uma de baixa frqu\u00eancia (0..25)Hz e outra de 60Hz. Progress Click para continuar....","title":"ECG"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#60-hz","text":"Notamos claramente que existe um sinal centrada em 60Hz, isso \u00e9 muito comum quando trabalhamos com eletr\u00f4nica e reflete o 60Hz da rede el\u00e9trica que \u00e9 propagada de diversas formas para o transdutor respons\u00e1vel em amostrar o dado do pulso el\u00e9trico do corpo humano, causando um ru\u00eddo no sinal n\u00e3o desej\u00e1vel. Para tararmos o dado corretamente teremos que filtra o ru\u00eddo. Lembre que em alguns pa\u00edses a frequ\u00eancia da rede el\u00e9trica \u00e9 de 50Hz e n\u00e3o de 60Hz como no Brasil. Info O som desse ru\u00eddo em 60hz \u00e9 chamado de Zumbido el\u00e9trico soa como: Progress Click para continuar....","title":"60 Hz"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#task-process","text":"Vamos criar uma tarefa no RTOS que ser\u00e1 respons\u00e1vel por processar os dados do ECG, iremos chamar a tarefa de task_process . Essa tarefa ir\u00e1 receber os dados da convers\u00e3o anal\u00f3gica, processar e extrair informa\u00e7\u00f5es e retornar enviar os dados para a task_main . Tarefa: task_process Crie uma tarefa chamada de task_process , ela pode estar vazia por hora. N\u00e3o esque\u00e7a do while(1) e de criar ela na fun\u00e7\u00e3o main ( xTaskCreate ). Progress Click para continuar....","title":"Task process"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#leitura-analogica","text":"Para come\u00e7armos precisamos ler o valor do ECG que est\u00e1 sendo gerado no pino PB13, para isso iremos configurar a leitura anal\u00f3gica no AFEC1 canal 6. A leitura anl\u00f3gica deve ser executada a 250 Hz, para garantirmos que estaremos lendo a uma taxa de amostragem fixa, vamos configurar um TC para fazer a convers\u00e3o do sinal. O valor convertido deve ser colocado em uma fila para processamento futuro, como indicado a seguir: Info Taxa de amostragem fixa simplifica muito o processamento de sinais digitais, muitas t\u00e9cnicas assumem que o valor \u00e9 constante. A forma como fizemos no laborat\u00f3rio do AFEC n\u00e3o \u00e9 boa aqui, porque l\u00e1 us\u00e1vamos uma tarefa do RTOS para gerar a taxa de amostragem ( vtaskDelay ) e isso n\u00e3o garante que tenhamos uma taxa fixa, pois n\u00e3o \u00e9 garantido que a taref\u00e1 v\u00e1 executar exatamente no delay proposto (outras tar\u00e9fas de prioridade superior podem estar executando). Al\u00e9m disso, o uso de uma task para gerar a taxa de amostragem limita a taxa que podemos usar, o RTOS executa no m\u00e1ximo a 1000Hz. Question Qual handler \u00e9 referente ao TC1 canal 0? TC6_Handler TC1_Handler TC3_Handler Tarefa: Lendo dados No come\u00e7o da task_process : Criar uma fila de inteiros xQueueECG de tamanho 250 Configurar TC1 canal 0 para gerar uma interrup\u00e7\u00e3o a cada 250Hz Configurar leitura no AFEC 1 canal 6 Handlers/Callbacks: No TC3_Handler inicializar a convers\u00e3o do AFEC1 canal 6 Isso vai fazer que com que tenhamos 250 amostras por segundo do ECG. No callback do AFEC ler o dado e colocar na fila xQueueECG Dentro do while da task_process : Ler o dado da fila xQueueECG e imprimir no terminal. Validar: Executar o programar, abrir o terminal e obter dados que variam no tempo (entre 0 e 3000). Progress Click para continuar....","title":"Leitura anal\u00f3gica"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#retransmitindo-o-dado","text":"Uma boa pr\u00e1tica \u00e9 atualizar o LCD apenas em uma tarefa, o LVGL n\u00e3o \u00e9 thread-safe by default , como o site indica na p\u00e1gina p\u00e1gina: https://docs.lvgl.io/latest/en/html/porting/os.html Isso significa que n\u00e3o podemos chamar uma fun\u00e7\u00e3o do LVGL enquanto a anterior n\u00e3o tenha terminado de executar, e caso implementemos o acesso ao LCD em v\u00e1rias partes do nosso programa corremos grande risco disso acontecer (lembrem que o RTOS interrompe uma tarefa para permitir que outra execute, e isso pode ser no meio da fun\u00e7\u00e3o por exemplo de mudar o valor do label). Info O site indica o uso de mutex para solucionar este problema, voc\u00eas ter\u00e3o isso em Sistemas Hw Sw. Para n\u00e3o termos que usar mutex, vamos atualizar o LCD apenas em uma das tasks, eu sugiro fazermos isso na task_main . Por conta disso iremos retransmitir o dado da fila do ECG para a task_main por outra fila: xQueueEcgInfo que ser\u00e1 do uma struct contendo dois inteiros: ecg e bpm . A ideia aqui \u00e9 que a task_process ir\u00e1 pegar os dados do ECG, processar e extrair o valor da frequ\u00eancia cardiaca (em batimentos por minuto) e retransmitir para a task_main exibir no LCD. Tarefa: Retransmitindo Vamos restransmitir o dado do ecg da task_process para a task_main . task_process : Cirei uma struct ecgInfo com dois par\u00e2metros inteiros: ecg, bpm. Crie uma fila xQueueEcgInfo capaz de armazenar at\u00e9 32 valores do ecgInfo Dica: Sugerirmos criar na fun\u00e7\u00e3o main, antes de iniciarem as tasks. Fa\u00e7a o envio do dado do Ecg da task_process para a task_main , coloque qualquer valor no bpm. task_main : Fa\u00e7a a leitura da fila xQueueEcgInfo Altere o printf da task_process para task_main para validar a transmiss\u00e3o dos dados. Warning Cuidado para n\u00e3o usar fun\u00e7\u00f5es que terminam com FromISR quando estiver interagindo com o RTOS de dentro de tarefas. Progress Click para continuar....","title":"Retransmitindo o dado"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#exibindo-grafico","text":"Agora que j\u00e1 temos o caminho do dado pronto vamos exibir no LCD usando o widget lv_chart . O site explica v\u00e1rios modos de fazer isso, eu irei sugerir um que fiz e funcionou bem. Primeiro teremos que criar um vetor global ( int ser1_data[250] ) que ir\u00e1 armazenar os pontos do gr\u00e1fico, o vetor precisa ter o tamanho da quantidade de pontos que queremos exibir. Vamos come\u00e7ar com 250, depois voc\u00eas podem ajustar at\u00e9 encontrarem um valor adequado. Depois precisamos criar o ponteiro para o gr\u00e1fico ( lv_obj_t * chart; ) e para a s\u00e9rie do ( ser1 ) tamb\u00e9m global (assim como fazermos para os labels e bot\u00f5es). E ent\u00e3o inicializar o gr\u00e1fico. Aqui eu irei fazer na fun\u00e7\u00e3o lv_screen_chart que deve ser chamada no come\u00e7o da task_LCD , como demonstrado a seguir: Tarefa: chart Insira o c\u00f3digo a seguir (vari\u00e1veis globais e fun\u00e7\u00e3o): // globais #define CHAR_DATA_LEN 250 int ser1_data [ CHAR_DATA_LEN ]; lv_obj_t * chart ; lv_chart_series_t * ser1 ; // Desenha gr\u00e1fico no LCD void lv_screen_chart ( void ) { chart = lv_chart_create ( lv_scr_act (), NULL ); lv_obj_set_size ( chart , 300 , 250 ); lv_obj_align ( chart , NULL , LV_ALIGN_IN_BOTTOM_MID , 0 , 0 ); lv_chart_set_type ( chart , LV_CHART_TYPE_LINE ); lv_chart_set_range ( chart , 0 , 4095 ); lv_chart_set_point_count ( chart , CHAR_DATA_LEN ); lv_chart_set_div_line_count ( chart , 0 , 0 ); lv_chart_set_update_mode ( chart , LV_CHART_UPDATE_MODE_SHIFT ); ser1 = lv_chart_add_series ( chart , LV_COLOR_BLUE ); lv_chart_set_ext_array ( chart , ser1 , ser1_data , CHAR_DATA_LEN ); lv_obj_set_style_local_line_width ( chart , LV_CHART_PART_SERIES , LV_STATE_DEFAULT , 1 ); } Fa\u00e7a as modifica\u00e7\u00f5es como indicado a seguir: static void task_lcd(void *pvParameters) { + lv_screen_chart(); for (;;) { lv_tick_inc(50); lv_task_handler(); vTaskDelay(50); } } Progress Click para continuar.... Agora temos que modificar a fun\u00e7\u00e3o task_main para toda hora que receber um novo valor na fila xQueueEcgInfo ela atualizar o gr\u00e1fico. Para isso iremos usar a fun\u00e7\u00e3o lv_chart_set_next(chart, ser1, value) , ap\u00f3s termos atualizado a s\u00e9rie precisamos indicar ao LVGL que \u00e9 para atualizar o gr\u00e1fico, isso \u00e9 feito pela fun\u00e7\u00e3o lv_chart_refresh(chart) . Mais inform\u00e7\u00f5es na p\u00e1gina do widget: https://docs.lvgl.io/latest/en/html/widgets/chart.html#overview Com isso voc\u00eas devem obter algo como: Tarefa: Exibindo Agora modifique o firmware para atualizar o dado da s\u00e9rie e exibir o dado toda vez que receber um dado novo na fila xQueueEcgInfo . Para isso v\u00e3o precisar usar as duas fun\u00e7\u00f5es a seguir: // novo valor | // v lv_chart_set_next ( chart , ser1 , value ); lv_chart_refresh ( chart ); Programe e teste na placa Tip Dica do Carlos Dip. Para tirar os pontos do gr\u00e1fico execute: lv_obj_set_style_local_size(chart, LV_CHART_PART_SERIES, LV_STATE_DEFAULT, LV_DPI/150); Progress Click para continuar....","title":"Exibindo gr\u00e1fico"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#frequencia-cardiaca","text":"Agora vamos modificar a task_process para detectar a frequ\u00eancia cardiaca, na literatura existem v\u00e1rias maneiras (bem mais correta da qual eu irei propor) o artigo a seguir explora algumas das maneiras: Par\u00e1k, Jakub, and Jan Havl\u00edk. \"ECG signal processing and heart rate frequency detection methods.\" Proceedings of Technical Computing Prague 8 (2011): 2011. A ideia principal \u00e9 detectar o intervalo de tempo entre cada pico: A implementa\u00e7\u00e3o que iremos fazer aqui envolve aplicar um threshold no valor e esperar at\u00e9 o pr\u00f3ximo pico, calculando o tempo entre os dois sinais. Question No exemplo anterior qual o valor da frequ\u00eancia cardiaca em batimento por minuto? 80 0.75 75 A conta a ser feita \u00e9 Econtra dT = 0.75s Do dT calcula a frequ\u00eancia em Hz -> 1/dT: 1.33 Hz = 1/s, multiplica por 60 para encontrar a frequ\u00eancia em minuto: 1.33*60 = 80 bpm Progress Click para continuar....","title":"Frequ\u00eancia cardiaca"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#rtt","text":"Para calcularmos o dT iremos usar o perif\u00e9rico RTT, que ficar\u00e1 gerando pulsos e depois iremos verificar quantos pulsos aconteceram no intervalo entre um pico e outro e ent\u00e3o estimar o valor do dT . O RTT ser\u00e1 configurado para operar a uma taxa de 1000Hz, ou seja, 1000 pulsos por segundo, isso nos dar\u00e1 uma boa resolu\u00e7\u00e3o. Neste caso n\u00e3o iremos usar a interrup\u00e7\u00e3o do RTT de alarme, mas sim a de tempo (que vai ocorrer 1000x por segundo). Sempre que ela ocorrer, iremos incrementar um contador global que ser\u00e1 nosso dT. Esse contador ser\u00e1 zerado a cada pulso. Tarefa: Inicialize o RTT O RTT deve ser inicializado na task_process . Crie uma vari\u00e1vel global g_dT Inicialize o RTT para operar a 1000Hz n\u00e3o vamos usar o alarme, coloque qualquer valor. A cada interrup\u00e7\u00e3o de tick do RTT, incremente a vari\u00e1vel g_dT Progress Click para continuar....","title":"RTT"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#threshold","text":"Iremos aplicar o threshold e procurar por valores que nos ajudem a encontra o pico, isso ser\u00e1 feito sempre que um novo dado chegar na fila xQueueEcg . Tarefa: threshold Para cada dado recebido na fila do ecg aplique o threshold e imprima o valor encontrado e seu dT, lembre de zerar o dT. Sugerimos aplicar 3280 como threshold. Exemplo if ( xQueueReceive ( xQueueAdc , & adc , 50 )) { // ... // ... if ( adc > 3280 ){ printf ( \"%d: %d ms \\n \" , adc , g_dT ); // come\u00e7amos a contar novamente g_dT = 0 ; } } Progress Click para continuar....","title":"Threshold"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#melhorando","text":"A implementa\u00e7\u00e3o anterior n\u00e3o funciona muito bem, as vezes encontramos mais de um valor no mesmo pico dentro do range estipulado: Melhorando Fa\u00e7a alguma m\u00e1gica para desconsiderar mais de um ponto no mesmo pico. Lembre de validar com os dados no terminal, seus dT devem ser no m\u00ednimo maior que 20 ms. Tip Para valorizar os picos do sinal voc\u00eas poderiam usar a energia dele (E(t) = ecg(t)^2), a energia de um sinal valoriza seus picos. Se for usar energia lembre de ajustar o valor do threshold. Progress Click para continuar....","title":"Melhorando"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#calculando-bpm","text":"Agora com o dT correto conseguimos converter a informa\u00e7\u00e3o para bpm. Tarefa: bpm Calcule o bpm do ecg e imprima no terminal. Verifique se est\u00e1 dentro do range v\u00e1lido. O valor deve variar ligeramente no tempo e ficar entre 60 bpm e 80. Progress Click para continuar....","title":"Calculando bpm"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#exibindo","text":"Agora que temos o valor do bpm, vamos enviar essa informa\u00e7\u00e3o junto com o ecg para a task_main via a fila xQueueEcgInfo (lembra que criamos uma struct?). Com a informa\u00e7\u00e3o na tarefa que atualiza o LCD, conseguimos criar um label e exibir o valor na tela junto com o gr\u00e1fico. O resultado esperado \u00e9 algo como: Tarefa: Exibindo Execute: Envie o dado do bpm para a task_main via a fila Crie um label novo para exibir a informa\u00e7\u00e3o A cada novo dado na fila atualize o valor do label. Tip Caso queira que o valor da frequ\u00eancia mude com maior periodicidade, altera o define ECG_CHANGE_TIME que est\u00e1 no arquivo aps2/aps2.h , este define especifica (em ms) a cada quanto tempo o valor do delay entre um pulso e outro ser\u00e1 atualizado. Sugest\u00e3o de valor: 1000 (1 segundo) Info At\u00e9 aqui \u00e9 C. Preencher ao finalizar o lab Carregando\u2026 Progress Click para continuar....","title":"Exibindo"},{"location":"navigation/Labs/Lab_ECG/Lab-ECG/#ba","text":"Adicionar beep com o buzzer, conforme frequ\u00eancia. Procurar pico usando a energia do sinal do sinal no lugar do valor no tempo. Info O que mais poderiamos fazer? Filtrar o sinal Fazer o threshold ser din\u00e2mico (o valor que detecta pico) Deixar gr\u00e1fico mais bonito","title":"B/A"},{"location":"navigation/Labs/Lab_HCSR04/lab/","text":"LAB - HC-SR04 Pasta Lab5-HC-SR04 Data da entrega: 29/03 Neste laborat\u00f3rio iremos trabalhar com o sensor de dist\u00e2ncia HC-SR04, que \u00e9 muito utilizado em projetos de rob\u00f3tica e similares. O sensor \u00e9 um m\u00f3dulo ultrass\u00f4nico e que possibilita medirmos a dist\u00e2ncia entre o sensor e um objeto. Para realizarmos a leitura correta do sensor, iremos utilizar os seguintes perif\u00e9ricos (com interrup\u00e7\u00e3o): PIO: Acionamento do sensor (pino TRIG) e leitura do pulso de echo (pino ECHO) TC: Contarmos o tempo do pulso de echo TC/ RTT: Determinar a cad\u00eancia de coleta de dados RTC: Fornecendo o data log HC-SR04 Refs: http://wiki.sunfounder.cc/index.php?title=Ultrasonic_Module https://www.filipeflop.com/produto/sensor-de-distancia-ultrassonico-hc-sr04/ O Sensor de Dist\u00e2ncia Ultrass\u00f4nico HC-SR04 \u00e9 capaz de medir dist\u00e2ncias de 2cm a 4m com \u00f3tima precis\u00e3o e baixo custo. Este m\u00f3dulo possui um circuito pronto com emissor e receptor acoplados e 4 pinos (VCC, Trigger, ECHO, GND) para medi\u00e7\u00e3o. Para come\u00e7ar a medi\u00e7\u00e3o \u00e9 necess\u00e1rio alimentar o m\u00f3dulo e colocar o pino Trigger em n\u00edvel alto por mais de 10us. Assim, o sensor emitir\u00e1 uma onda sonora que, ao encontrar um obst\u00e1culo, rebater\u00e1 de volta em dire\u00e7\u00e3o ao m\u00f3dulo. Durante o tempo de emiss\u00e3o e recebimento do sinal, o pino ECHO ficar\u00e1 em n\u00edvel alto. Logo, o c\u00e1lculo da dist\u00e2ncia pode ser feito de acordo com o tempo em que o pino ECHO permaneceu em n\u00edvel alto ap\u00f3s o pino Trigger ter sido colocado em n\u00edvel alto. Dist\u00e2ncia = [Tempo ECHO em n\u00edvel alto * Velocidade do Som] / 2 A velocidade do som pode ser considerada idealmente igual a 340 m/s, logo o resultado \u00e9 obtido em metros se considerado o tempo em segundos. Na f\u00f3rmula, a divis\u00e3o por 2 deve-se ao fato de que a onda \u00e9 enviada e rebatida, ou seja, ela percorre 2 vezes a dist\u00e2ncia procurada. Especifica\u00e7\u00f5es: Alimenta\u00e7\u00e3o: 5V DC Corrente de Opera\u00e7\u00e3o: 2mA \u00c2ngulo de efeito: 15\u00b0 Alcance.: 2cm ~ 4m Precis\u00e3o.: 3mm Descric\u00e3o extra\u00edda do site do filipflop: https://www.filipeflop.com/produto/sensor-de-distancia-ultrassonico-hc-sr04/ Info No Brasil o sensor custa em torno de R$14 ( https://www.filipeflop.com/produto/sensor-de-distancia-ultrassonico-hc-sr04/ ) Montagem O sensor possui dois pinos (TRIG e ECHO) que devem ser ligados no uC os outros s\u00e3o para alimentac\u00e3o (GND e VCC), como o m\u00f3dulo opera com 5V teremos que fazer um divisor de tens\u00e3o no pino do ECHO para n\u00e3o danificar o nosso uC que possui tens\u00e3o m\u00e1xima nos pinos de 3v3. Voc\u00ea deve seguir a montagem a seguir, sugerimos utilizar uma protoboard para isso. Os pinos X e Y podem ser qualquer um do EXT-2. Esquem\u00e1tico Protoboard Warning Voc\u00ea deve escolher os pinos X e Y que ir\u00e3o ligar no uC. Interagindo Ap\u00f3s feita a montagem voc\u00ea dever\u00e1 escrever um programa que faz o controle do sensor ultrass\u00f4nico, para iniciar uma nova leitura voc\u00ea deve gerar um pulso de 10us no pino de Trig ( Pin Y ) e ent\u00e3o aguardar pela subida do sinal do Echo ( Pin X ) e ent\u00e3o contar o tempo ( dT ) que ele fica em alto. O valor de dT \u00e9 proporcional ao tempo que o som levou para chegar at\u00e9 o obst\u00e1culo e voltar. A figura a seguir demonstra como funciona a leitura do sensor. Exercise Calcule o tempo m\u00ednimo e m\u00e1ximo que o sinal de Echo pode ficar em '1'? Lembre de verificar o range do sensor (voc\u00ea vai precisar saber a velocidade do som). Answer Das informa\u00e7\u00f5es fornecidas do sensor: Dist\u00e2ncia m\u00ednima: 0.02 m Dist\u00e2ncia m\u00e1xima: 4.00 m Sabendo que a velocidade do som \u00e9 aproximadamente 340 m/s, portanto $x [s] = dist / 340$. Lembre que o sensor fornece a dist\u00e2ncia dobrado (tempo de ir e voltar)! Ou seja: Tempo m\u00ednimo: $2 \\times 0,000058$s Tempo m\u00e1ximo: $2 \\times 0,011764$s Exercise Com as informa\u00e7\u00f5es coletadas at\u00e9 aqui voc\u00ea consegue imaginar como deve ser o firmware para fazer a leitura do sensor? N\u00e3o existe uma \u00fanica maneira de fazer, mas algumas solu\u00e7\u00f5es podem n\u00e3o ser muito boas! Descreva aqui como voc\u00ea geraria o sinal do Trig e como voc\u00ea faria a leitura do sinal do Echo e quais perif\u00e9ricos usaria para isso? Answer Uma das solu\u00e7\u00f5es poss\u00edveis (e indicadas) \u00e9: Sinal do Trigger gerar via pio_set(), delay_us(10), pio_clear() . Como o sinal do pino de Trigger pode ser aproximadamente 10 us, n\u00e3o tem muito problema em usar a fun\u00e7\u00e3o de delay para isso! J\u00e1 o sinal do Echo carrega informa\u00e7\u00f5es importantes e devemos contar corretamente o tempo. Para isso sugerimos configurar uma interrup\u00e7\u00e3o de borda no pino do ECHO e inciar o RTT quando ocorrer uma borda de descida e parar a contagem do tempo quando ocorrer uma borda de subida, informando a fun\u00e7\u00e3o main via flag que uma nova leitura aconteceu. Um ponto importante \u00e9 a configura\u00e7\u00e3o da frequ\u00eancia na qual o RTT ir\u00e1 operar. Pense um pouco a respeito.... Lab Nesse laborat\u00f3rio voc\u00eas devem usar o exemplo do OLED e realizando a leitura peri\u00f3dica do HCSR04 exibir a dist\u00e2ncia entre o sensor e um objeto no display. Sempre que voc\u00ea apertar o bot\u00e3o da placa, uma nova leitura come\u00e7a. Comecem copiando o exemplo do OLED para o seu reposit\u00f3rio e renomem para: Lab5-HC-SR04 , ou se preferir, podem usar um dos labs passados que possui OLED e j\u00e1 tem os bot\u00f5es configurados, s\u00f3 lembrem de fazer uma c\u00f3pia e renomear. Dicas ________ ________ TRIG ______|////////|_____________________________________|////////|_____ ^ 10us | | _____________ | 6.inicia nova leitura ECHO _________________|/////////////|_________ | | | | V V | 1.callback_echo 3.callback_echo | | | | V V | 2.RTT_init 4.rtt_read_timer_value | | | V | 5.valor para main + c\u00e1lculo da dist\u00e2ncia Setup: Fazer a montagem na protoboard Escolher dois pinos para Echo e Trig Configurar Trig como output e Echo como input Configurar irq de boarda no pino Echo Lembre de criar a fun\u00e7\u00e3o de callback. Warning N\u00e3o ative PULL_UP no pino do ECHO! Trig: Gerar o pulso no pino de Trig com delay_us . Echo: Iniciar o RTT na borda de subida do pino Echo Qual prescale usar? Ler valor do RTT em borda de descida do pino Echo Consulte a documenta\u0107\u00e3o do ASF-RTT para saber como ler o valor atual do contador. Dicas RTT Nessa primeira etapa n\u00e3o precisamos de nenhuma interrup\u00e7\u00e3o do RTT, ele vai funcionar apenas como um rel\u00f3gio. Passe 0 no \u00faltimo par\u00e2metro da fun\u00e7\u00e3o RTT_Init() . Para consultarmos o valor atual do RTT, utilize a func\u00e3o rtt_read_timer_value uint32_t rtt_read_timer_value ( Rtt * p_rtt ) Read the current value of the RTT timer value. Parameters p_rtt Pointer to an RTT instance. Returns The current Real-time Timer value. Referenced by configure_rtt(), gpbr_test_configure_rtt(), main(), and refresh_display(). Conta: Realizar o c\u00e1lculo da dist\u00e2ncia usando o valor do RTT Lembre de usar como base de tempo o valor que configurou no RTT. Exiba nos no OLED a dist\u00e2ncia atual em cm. Ao terminar o lab preencha: Carregando\u2026 Progress At\u00e9 aqui \u00e9 C B Estamos lidando com um sensor que pode ter falhas, o que acontece se o sensor n\u00e3o estiver operando direito, ou se der mal contato na liga\u00e7\u00e3o? ou se o som n\u00e3o voltar (espa\u00e7o aberto). Identifique esse tipo de erro e exiba no OLED. A Exibir gr\u00e1fico com \u00faltimos valores da dist\u00e2ncia.","title":"LAB - HC-SR04"},{"location":"navigation/Labs/Lab_HCSR04/lab/#lab-hc-sr04","text":"Pasta Lab5-HC-SR04 Data da entrega: 29/03 Neste laborat\u00f3rio iremos trabalhar com o sensor de dist\u00e2ncia HC-SR04, que \u00e9 muito utilizado em projetos de rob\u00f3tica e similares. O sensor \u00e9 um m\u00f3dulo ultrass\u00f4nico e que possibilita medirmos a dist\u00e2ncia entre o sensor e um objeto. Para realizarmos a leitura correta do sensor, iremos utilizar os seguintes perif\u00e9ricos (com interrup\u00e7\u00e3o): PIO: Acionamento do sensor (pino TRIG) e leitura do pulso de echo (pino ECHO) TC: Contarmos o tempo do pulso de echo TC/ RTT: Determinar a cad\u00eancia de coleta de dados RTC: Fornecendo o data log","title":"LAB - HC-SR04"},{"location":"navigation/Labs/Lab_HCSR04/lab/#hc-sr04","text":"Refs: http://wiki.sunfounder.cc/index.php?title=Ultrasonic_Module https://www.filipeflop.com/produto/sensor-de-distancia-ultrassonico-hc-sr04/ O Sensor de Dist\u00e2ncia Ultrass\u00f4nico HC-SR04 \u00e9 capaz de medir dist\u00e2ncias de 2cm a 4m com \u00f3tima precis\u00e3o e baixo custo. Este m\u00f3dulo possui um circuito pronto com emissor e receptor acoplados e 4 pinos (VCC, Trigger, ECHO, GND) para medi\u00e7\u00e3o. Para come\u00e7ar a medi\u00e7\u00e3o \u00e9 necess\u00e1rio alimentar o m\u00f3dulo e colocar o pino Trigger em n\u00edvel alto por mais de 10us. Assim, o sensor emitir\u00e1 uma onda sonora que, ao encontrar um obst\u00e1culo, rebater\u00e1 de volta em dire\u00e7\u00e3o ao m\u00f3dulo. Durante o tempo de emiss\u00e3o e recebimento do sinal, o pino ECHO ficar\u00e1 em n\u00edvel alto. Logo, o c\u00e1lculo da dist\u00e2ncia pode ser feito de acordo com o tempo em que o pino ECHO permaneceu em n\u00edvel alto ap\u00f3s o pino Trigger ter sido colocado em n\u00edvel alto. Dist\u00e2ncia = [Tempo ECHO em n\u00edvel alto * Velocidade do Som] / 2 A velocidade do som pode ser considerada idealmente igual a 340 m/s, logo o resultado \u00e9 obtido em metros se considerado o tempo em segundos. Na f\u00f3rmula, a divis\u00e3o por 2 deve-se ao fato de que a onda \u00e9 enviada e rebatida, ou seja, ela percorre 2 vezes a dist\u00e2ncia procurada. Especifica\u00e7\u00f5es: Alimenta\u00e7\u00e3o: 5V DC Corrente de Opera\u00e7\u00e3o: 2mA \u00c2ngulo de efeito: 15\u00b0 Alcance.: 2cm ~ 4m Precis\u00e3o.: 3mm Descric\u00e3o extra\u00edda do site do filipflop: https://www.filipeflop.com/produto/sensor-de-distancia-ultrassonico-hc-sr04/ Info No Brasil o sensor custa em torno de R$14 ( https://www.filipeflop.com/produto/sensor-de-distancia-ultrassonico-hc-sr04/ )","title":"HC-SR04"},{"location":"navigation/Labs/Lab_HCSR04/lab/#montagem","text":"O sensor possui dois pinos (TRIG e ECHO) que devem ser ligados no uC os outros s\u00e3o para alimentac\u00e3o (GND e VCC), como o m\u00f3dulo opera com 5V teremos que fazer um divisor de tens\u00e3o no pino do ECHO para n\u00e3o danificar o nosso uC que possui tens\u00e3o m\u00e1xima nos pinos de 3v3. Voc\u00ea deve seguir a montagem a seguir, sugerimos utilizar uma protoboard para isso. Os pinos X e Y podem ser qualquer um do EXT-2. Esquem\u00e1tico Protoboard Warning Voc\u00ea deve escolher os pinos X e Y que ir\u00e3o ligar no uC.","title":"Montagem"},{"location":"navigation/Labs/Lab_HCSR04/lab/#interagindo","text":"Ap\u00f3s feita a montagem voc\u00ea dever\u00e1 escrever um programa que faz o controle do sensor ultrass\u00f4nico, para iniciar uma nova leitura voc\u00ea deve gerar um pulso de 10us no pino de Trig ( Pin Y ) e ent\u00e3o aguardar pela subida do sinal do Echo ( Pin X ) e ent\u00e3o contar o tempo ( dT ) que ele fica em alto. O valor de dT \u00e9 proporcional ao tempo que o som levou para chegar at\u00e9 o obst\u00e1culo e voltar. A figura a seguir demonstra como funciona a leitura do sensor. Exercise Calcule o tempo m\u00ednimo e m\u00e1ximo que o sinal de Echo pode ficar em '1'? Lembre de verificar o range do sensor (voc\u00ea vai precisar saber a velocidade do som). Answer Das informa\u00e7\u00f5es fornecidas do sensor: Dist\u00e2ncia m\u00ednima: 0.02 m Dist\u00e2ncia m\u00e1xima: 4.00 m Sabendo que a velocidade do som \u00e9 aproximadamente 340 m/s, portanto $x [s] = dist / 340$. Lembre que o sensor fornece a dist\u00e2ncia dobrado (tempo de ir e voltar)! Ou seja: Tempo m\u00ednimo: $2 \\times 0,000058$s Tempo m\u00e1ximo: $2 \\times 0,011764$s Exercise Com as informa\u00e7\u00f5es coletadas at\u00e9 aqui voc\u00ea consegue imaginar como deve ser o firmware para fazer a leitura do sensor? N\u00e3o existe uma \u00fanica maneira de fazer, mas algumas solu\u00e7\u00f5es podem n\u00e3o ser muito boas! Descreva aqui como voc\u00ea geraria o sinal do Trig e como voc\u00ea faria a leitura do sinal do Echo e quais perif\u00e9ricos usaria para isso? Answer Uma das solu\u00e7\u00f5es poss\u00edveis (e indicadas) \u00e9: Sinal do Trigger gerar via pio_set(), delay_us(10), pio_clear() . Como o sinal do pino de Trigger pode ser aproximadamente 10 us, n\u00e3o tem muito problema em usar a fun\u00e7\u00e3o de delay para isso! J\u00e1 o sinal do Echo carrega informa\u00e7\u00f5es importantes e devemos contar corretamente o tempo. Para isso sugerimos configurar uma interrup\u00e7\u00e3o de borda no pino do ECHO e inciar o RTT quando ocorrer uma borda de descida e parar a contagem do tempo quando ocorrer uma borda de subida, informando a fun\u00e7\u00e3o main via flag que uma nova leitura aconteceu. Um ponto importante \u00e9 a configura\u00e7\u00e3o da frequ\u00eancia na qual o RTT ir\u00e1 operar. Pense um pouco a respeito....","title":"Interagindo"},{"location":"navigation/Labs/Lab_HCSR04/lab/#lab","text":"Nesse laborat\u00f3rio voc\u00eas devem usar o exemplo do OLED e realizando a leitura peri\u00f3dica do HCSR04 exibir a dist\u00e2ncia entre o sensor e um objeto no display. Sempre que voc\u00ea apertar o bot\u00e3o da placa, uma nova leitura come\u00e7a. Comecem copiando o exemplo do OLED para o seu reposit\u00f3rio e renomem para: Lab5-HC-SR04 , ou se preferir, podem usar um dos labs passados que possui OLED e j\u00e1 tem os bot\u00f5es configurados, s\u00f3 lembrem de fazer uma c\u00f3pia e renomear.","title":"Lab"},{"location":"navigation/Labs/Lab_HCSR04/lab/#dicas","text":"________ ________ TRIG ______|////////|_____________________________________|////////|_____ ^ 10us | | _____________ | 6.inicia nova leitura ECHO _________________|/////////////|_________ | | | | V V | 1.callback_echo 3.callback_echo | | | | V V | 2.RTT_init 4.rtt_read_timer_value | | | V | 5.valor para main + c\u00e1lculo da dist\u00e2ncia Setup: Fazer a montagem na protoboard Escolher dois pinos para Echo e Trig Configurar Trig como output e Echo como input Configurar irq de boarda no pino Echo Lembre de criar a fun\u00e7\u00e3o de callback. Warning N\u00e3o ative PULL_UP no pino do ECHO! Trig: Gerar o pulso no pino de Trig com delay_us . Echo: Iniciar o RTT na borda de subida do pino Echo Qual prescale usar? Ler valor do RTT em borda de descida do pino Echo Consulte a documenta\u0107\u00e3o do ASF-RTT para saber como ler o valor atual do contador. Dicas RTT Nessa primeira etapa n\u00e3o precisamos de nenhuma interrup\u00e7\u00e3o do RTT, ele vai funcionar apenas como um rel\u00f3gio. Passe 0 no \u00faltimo par\u00e2metro da fun\u00e7\u00e3o RTT_Init() . Para consultarmos o valor atual do RTT, utilize a func\u00e3o rtt_read_timer_value uint32_t rtt_read_timer_value ( Rtt * p_rtt ) Read the current value of the RTT timer value. Parameters p_rtt Pointer to an RTT instance. Returns The current Real-time Timer value. Referenced by configure_rtt(), gpbr_test_configure_rtt(), main(), and refresh_display(). Conta: Realizar o c\u00e1lculo da dist\u00e2ncia usando o valor do RTT Lembre de usar como base de tempo o valor que configurou no RTT. Exiba nos no OLED a dist\u00e2ncia atual em cm. Ao terminar o lab preencha: Carregando\u2026 Progress At\u00e9 aqui \u00e9 C","title":"Dicas"},{"location":"navigation/Labs/Lab_HCSR04/lab/#b","text":"Estamos lidando com um sensor que pode ter falhas, o que acontece se o sensor n\u00e3o estiver operando direito, ou se der mal contato na liga\u00e7\u00e3o? ou se o som n\u00e3o voltar (espa\u00e7o aberto). Identifique esse tipo de erro e exiba no OLED.","title":"B"},{"location":"navigation/Labs/Lab_HCSR04/lab/#a","text":"Exibir gr\u00e1fico com \u00faltimos valores da dist\u00e2ncia.","title":"A"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Perguntas/","text":"1. Liste as principais funcionalidade dos perif\u00e9ricos: RTC - Real time clock TC - Timer/Counter ISI - Image Sensor Interface 2. Qual endere\u00e7o de mem\u00f3ria reservado para os perif\u00e9ricos ? qual o tamanho (em decimal) dessa sec\u00e7\u00e3o ? O diagrama completo do mapeamento de mem\u00f3ria pode ser encontrado na p\u00e1gina 41. 3. Encontre os endere\u00e7os de mem\u00f3ria referentes aos seguintes perif\u00e9ricos: PIOA PIOB ACC UART1 UART2 4. Qual ID do TC0 ? 5. Verifique quais perif\u00e9ricos podem ser configur\u00e1veis nos I/Os: PC1 PB6 6. O que \u00e9 boucing ? Porque deve ser utilizado o deboucing ? Descreva um algor\u00edtimo que implemente o deboucing.","title":"Lab PIO Perguntas"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Perguntas/#1","text":"Liste as principais funcionalidade dos perif\u00e9ricos: RTC - Real time clock TC - Timer/Counter ISI - Image Sensor Interface","title":"1."},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Perguntas/#2","text":"Qual endere\u00e7o de mem\u00f3ria reservado para os perif\u00e9ricos ? qual o tamanho (em decimal) dessa sec\u00e7\u00e3o ? O diagrama completo do mapeamento de mem\u00f3ria pode ser encontrado na p\u00e1gina 41.","title":"2."},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Perguntas/#3","text":"Encontre os endere\u00e7os de mem\u00f3ria referentes aos seguintes perif\u00e9ricos: PIOA PIOB ACC UART1 UART2","title":"3."},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Perguntas/#4","text":"Qual ID do TC0 ?","title":"4."},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Perguntas/#5","text":"Verifique quais perif\u00e9ricos podem ser configur\u00e1veis nos I/Os: PC1 PB6","title":"5."},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Perguntas/#6","text":"O que \u00e9 boucing ? Porque deve ser utilizado o deboucing ? Descreva um algor\u00edtimo que implemente o deboucing.","title":"6."},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Teoria/","text":"Lab 1 - Digital IO Leitura extra ecomendada Renesas - GPIO ARM Perif\u00e9ricos Leitura Manual Utilize o manual encontrado em: Manuais/SAME70 para mais informa\u00e7\u00f5es nesse assunto. Perif\u00e9ricos s\u00e3o hardwares auxiliares encontrados no microcontrolador (uC) que fornecem funcionalidades extras tais como: gerenciador de energia (SUPC), comunica\u00e7\u00e3o serial UART (UART), comunica\u00e7\u00e3o USB/ Ethernet/ Bluetooth ..., controlador de sa\u00edda e entrada paralela (PIO), dentre muitos outros. Os perif\u00e9ricos s\u00e3o configur\u00e1veis via escrita/leitura nos registradores do microcontrolador, cada perif\u00e9rico possui um endere\u00e7o \u00fanico mapeado em mem\u00f3ria. Controlando um pino Vamos imaginar uma aplica\u00e7\u00e3o comum de um microcontrolador: controlar um pino digital (Ligado/ Desligado). Esse pino pode estar conectado a um LED, por exemplo. Nosso objetivo \u00e9 conseguirmos escrever um software que seja capaz de colocar energia (VCC/ ligado) no pino, ou desligar o pino (GND/ desligar). Como ilustrado no diagrama a seguir: Dois perif\u00e9ricos ser\u00e3o utilizados para que possamos controlar os pinos do uC de forma digital (liga/ desliga), s\u00e3o eles o Power Manager Contoller ( PMC ) e o Parallel Input Output ( PIO ). O PMC \u00e9 o perif\u00e9rico respons\u00e1vel por \"gerenciar\" a energia dos demais perif\u00e9ricos do uC SAME70 e o PIO \u00e9 o perif\u00e9rico respons\u00e1vel por controlar um pino digital desse uC. Como demonstrado a seguir: Note Pense nos perif\u00e9ricos como pequenos hardwares auxiliares ao microprocessador, esses perif\u00e9ricos fazem parte do chip. Info Os termos t\u00e9cnicos podem variar entre fabricantes, por\u00e9m o conceito \u00e9 o mesmo. Por exemplo, \u00e9 comum o uso de General Propose I/O (GPIO) no lugar de PIO. Note Nesse exemplo, a mem\u00f3ria do uC \u00e9 omitida. Nesse caso seriam adicionados mais dois perif\u00e9ricos, um para a mem\u00f3ria de programa (flash) e outra para a mem\u00f3ria de dados (SRAM) Power Manager Contoller - PMC Leitura datasheet Se\u00e7\u00e3o 31 do datasheet SAME70 O Power Management Controller (PMC) \u00e9 um perif\u00e9rico respons\u00e1vel por gerenciar a energia e clock dos demais perif\u00e9ricos. Para utilizarmos um perif\u00e9rico \u00e9 necess\u00e1rio primeiramente ativarmos o mesmo no PMC. Cada perif\u00e9rico \u00e9 referenciado no PMC via um n\u00famero \u00fanico (ID), esse ID tamb\u00e9m ser\u00e1 utilizado para o gerenciamento de interrup\u00e7\u00f5es. Os IDs est\u00e3o listados na Tabela: 13.1 do datasheet SAM-E70 . Parallel Input Output (PIO) Leitura datasheet Sec\u00e7\u00e3o 32 do datasheet. Leitura necess\u00e1ria No ARM-Atmel os pinos s\u00e3o gerenciados por um hardware chamado de Parallel Input/Output Controller (PIO) , esse dispositivo pode gerenciar at\u00e9 32 diferentes pinos (I/Os). Al\u00e9m do controle direito do pino pelo PIO, cada I/O no ARM-Atmel pode ser associado a uma fun\u00e7\u00e3o diferente (perif\u00e9rico), por exemplo: o I/O PA20 pode ser controlador pelo perif\u00e9rico do PWM enquanto o PA18 e pela UART. Isso fornece flexibilidade ao desenvolvimento de uma aplica\u00e7\u00e3o, j\u00e1 que os I/Os n\u00e3o possuem uma funcionalidade fixa. Existe uma tabela que informa quais I/Os cada perif\u00e9ricos podem controlar. Podemos interpretar a tabela como: o pino 102 do microcontrolador identificado como PA0 (PIOA_0) pode ser utilizado como WKUP0 (wakeup) ou mapeado para um dos tr\u00eas perif\u00e9ricos: Perif\u00e9rico A: PWM (Pulse width modulation) Perif\u00e9rico B: TIOA0 (Timer 0) Perif\u00e9rico C: I2C_MCL (I2C master clear) A tabela na p\u00e1gina 16 do datasheet (Table 5-1) ilustra quais perif\u00e9ricos podem ser associados aos respectivos pinos, a Fig. Mux PIOA mostra as op\u00e7\u00f5es para o PIOA0 at\u00e9 PIOA9. O SAME70 possui internamente 5 PIOs: PIO A , PIO B , PIO C , PIO D e PIO E . Cada um \u00e9 respons\u00e1vel por gerenciar at\u00e9 32 pinos. Os I/Os s\u00e3o classificados por sua vez em grandes grupos: A, B,C \u2026. (exe: PA01, PB22, PC12) e cada grupo \u00e9 controlado por um PIO (PIOA, PIOB, PIOC, \u2026). Cada PIO possui controle independente de energia via o PMC, sendo necess\u00e1rio ativar o clock de cada PIO para que o perif\u00e9rico passe a funcionar. Configura\u00e7\u00f5es O PIO suporta as seguintes configura\u00e7\u00f5es: Interrup\u00e7\u00e3o ao n\u00edvel ou borda em qualquer I/O Filtragem de \"glitch\" Deboucing Open-Drain Pull-up/Pull-down Capacidade de trabalhar de forma paralela Iremos ver para que serve algumas dessas configura\u00e7\u00f5es ao longo do curso. Funcionalidade O diagrama de blocos do PIO \u00e9 ilustrado no diagrama de blocos (Block Diagram) onde: Peripheral DMA (direct memmory access) controller (PDC): O P/IO pode receber dados via DMA. DMA \u00e9 uma forma autom\u00e1tica de transfer\u00eancia de dados. Interrupt Controller: J\u00e1 que o PIO suporta interrup\u00e7\u00f5es nos I/Os o mesmo deve se comunicar com o controlador de interrup\u00e7\u00f5es para informar a CPU (NVIC) que uma interrup\u00e7\u00e3o \u00e9 requisitada. PMC: A energia e clock desse perif\u00e9rico \u00e9 controlado pelo PMC (Power management controller). Embedded peripheral: O acesso aos pinos pelos perif\u00e9ricos do uC \u00e9 realizado via PIO. Um diagrama l\u00f3gico mais detalhado pode ser encontrado no datasheet (I/O Line Control Logic), esse diagrama mostra as fun\u00e7\u00f5es dos registradores e seu impacto no PIO.","title":"Teoria"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Teoria/#lab-1-digital-io","text":"Leitura extra ecomendada Renesas - GPIO ARM","title":"Lab 1 - Digital IO"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Teoria/#perifericos","text":"Leitura Manual Utilize o manual encontrado em: Manuais/SAME70 para mais informa\u00e7\u00f5es nesse assunto. Perif\u00e9ricos s\u00e3o hardwares auxiliares encontrados no microcontrolador (uC) que fornecem funcionalidades extras tais como: gerenciador de energia (SUPC), comunica\u00e7\u00e3o serial UART (UART), comunica\u00e7\u00e3o USB/ Ethernet/ Bluetooth ..., controlador de sa\u00edda e entrada paralela (PIO), dentre muitos outros. Os perif\u00e9ricos s\u00e3o configur\u00e1veis via escrita/leitura nos registradores do microcontrolador, cada perif\u00e9rico possui um endere\u00e7o \u00fanico mapeado em mem\u00f3ria.","title":"Perif\u00e9ricos"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Teoria/#controlando-um-pino","text":"Vamos imaginar uma aplica\u00e7\u00e3o comum de um microcontrolador: controlar um pino digital (Ligado/ Desligado). Esse pino pode estar conectado a um LED, por exemplo. Nosso objetivo \u00e9 conseguirmos escrever um software que seja capaz de colocar energia (VCC/ ligado) no pino, ou desligar o pino (GND/ desligar). Como ilustrado no diagrama a seguir: Dois perif\u00e9ricos ser\u00e3o utilizados para que possamos controlar os pinos do uC de forma digital (liga/ desliga), s\u00e3o eles o Power Manager Contoller ( PMC ) e o Parallel Input Output ( PIO ). O PMC \u00e9 o perif\u00e9rico respons\u00e1vel por \"gerenciar\" a energia dos demais perif\u00e9ricos do uC SAME70 e o PIO \u00e9 o perif\u00e9rico respons\u00e1vel por controlar um pino digital desse uC. Como demonstrado a seguir: Note Pense nos perif\u00e9ricos como pequenos hardwares auxiliares ao microprocessador, esses perif\u00e9ricos fazem parte do chip. Info Os termos t\u00e9cnicos podem variar entre fabricantes, por\u00e9m o conceito \u00e9 o mesmo. Por exemplo, \u00e9 comum o uso de General Propose I/O (GPIO) no lugar de PIO. Note Nesse exemplo, a mem\u00f3ria do uC \u00e9 omitida. Nesse caso seriam adicionados mais dois perif\u00e9ricos, um para a mem\u00f3ria de programa (flash) e outra para a mem\u00f3ria de dados (SRAM)","title":"Controlando um pino"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Teoria/#power-manager-contoller-pmc","text":"Leitura datasheet Se\u00e7\u00e3o 31 do datasheet SAME70 O Power Management Controller (PMC) \u00e9 um perif\u00e9rico respons\u00e1vel por gerenciar a energia e clock dos demais perif\u00e9ricos. Para utilizarmos um perif\u00e9rico \u00e9 necess\u00e1rio primeiramente ativarmos o mesmo no PMC. Cada perif\u00e9rico \u00e9 referenciado no PMC via um n\u00famero \u00fanico (ID), esse ID tamb\u00e9m ser\u00e1 utilizado para o gerenciamento de interrup\u00e7\u00f5es. Os IDs est\u00e3o listados na Tabela: 13.1 do datasheet SAM-E70 .","title":"Power Manager Contoller - PMC"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Teoria/#parallel-input-output-pio","text":"Leitura datasheet Sec\u00e7\u00e3o 32 do datasheet. Leitura necess\u00e1ria No ARM-Atmel os pinos s\u00e3o gerenciados por um hardware chamado de Parallel Input/Output Controller (PIO) , esse dispositivo pode gerenciar at\u00e9 32 diferentes pinos (I/Os). Al\u00e9m do controle direito do pino pelo PIO, cada I/O no ARM-Atmel pode ser associado a uma fun\u00e7\u00e3o diferente (perif\u00e9rico), por exemplo: o I/O PA20 pode ser controlador pelo perif\u00e9rico do PWM enquanto o PA18 e pela UART. Isso fornece flexibilidade ao desenvolvimento de uma aplica\u00e7\u00e3o, j\u00e1 que os I/Os n\u00e3o possuem uma funcionalidade fixa. Existe uma tabela que informa quais I/Os cada perif\u00e9ricos podem controlar. Podemos interpretar a tabela como: o pino 102 do microcontrolador identificado como PA0 (PIOA_0) pode ser utilizado como WKUP0 (wakeup) ou mapeado para um dos tr\u00eas perif\u00e9ricos: Perif\u00e9rico A: PWM (Pulse width modulation) Perif\u00e9rico B: TIOA0 (Timer 0) Perif\u00e9rico C: I2C_MCL (I2C master clear) A tabela na p\u00e1gina 16 do datasheet (Table 5-1) ilustra quais perif\u00e9ricos podem ser associados aos respectivos pinos, a Fig. Mux PIOA mostra as op\u00e7\u00f5es para o PIOA0 at\u00e9 PIOA9. O SAME70 possui internamente 5 PIOs: PIO A , PIO B , PIO C , PIO D e PIO E . Cada um \u00e9 respons\u00e1vel por gerenciar at\u00e9 32 pinos. Os I/Os s\u00e3o classificados por sua vez em grandes grupos: A, B,C \u2026. (exe: PA01, PB22, PC12) e cada grupo \u00e9 controlado por um PIO (PIOA, PIOB, PIOC, \u2026). Cada PIO possui controle independente de energia via o PMC, sendo necess\u00e1rio ativar o clock de cada PIO para que o perif\u00e9rico passe a funcionar.","title":"Parallel Input Output (PIO)"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Teoria/#configuracoes","text":"O PIO suporta as seguintes configura\u00e7\u00f5es: Interrup\u00e7\u00e3o ao n\u00edvel ou borda em qualquer I/O Filtragem de \"glitch\" Deboucing Open-Drain Pull-up/Pull-down Capacidade de trabalhar de forma paralela Iremos ver para que serve algumas dessas configura\u00e7\u00f5es ao longo do curso.","title":"Configura\u00e7\u00f5es"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO-Teoria/#funcionalidade","text":"O diagrama de blocos do PIO \u00e9 ilustrado no diagrama de blocos (Block Diagram) onde: Peripheral DMA (direct memmory access) controller (PDC): O P/IO pode receber dados via DMA. DMA \u00e9 uma forma autom\u00e1tica de transfer\u00eancia de dados. Interrupt Controller: J\u00e1 que o PIO suporta interrup\u00e7\u00f5es nos I/Os o mesmo deve se comunicar com o controlador de interrup\u00e7\u00f5es para informar a CPU (NVIC) que uma interrup\u00e7\u00e3o \u00e9 requisitada. PMC: A energia e clock desse perif\u00e9rico \u00e9 controlado pelo PMC (Power management controller). Embedded peripheral: O acesso aos pinos pelos perif\u00e9ricos do uC \u00e9 realizado via PIO. Um diagrama l\u00f3gico mais detalhado pode ser encontrado no datasheet (I/O Line Control Logic), esse diagrama mostra as fun\u00e7\u00f5es dos registradores e seu impacto no PIO.","title":"Funcionalidade"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/","text":"LAB - PIO Pasta: /1-PIO-IO Data LIMITE para entrega: 23/08/22 - 23h59 Info Os laborat\u00f3rios s\u00e3o individuais e cada aluno deve ter um reposit\u00f3rio com todas as enteegas, o reposit\u00f3rio deve ser criado pelo classroom usando o link a seguir: https://classroom.github.com/a/xjegYr_C Progress Click para continuar.... Entrega Ao final desse laborat\u00f3rio voc\u00ea deve ser capaz de controlar e ler pinos digitais do microcontrolador a fim de podermos acionar sa\u00eddas (LEDs/ Buzzers/ motores) e lermos entradas (bot\u00f5es/ sensores/ ...). Ao final do laborat\u00f3rio voc\u00eas ter\u00e3o: Um LED piscando a cada segundo A leitura de um bot\u00e3o (entrada) LED acionado pelo bot\u00e3o Feito esse lab j\u00e1 da para come\u00e7ar a APS 1 onde voc\u00eas ter\u00e3o que desenvolver um sistema embarcado que reproduz uma m\u00fasica monofonia. Laborat\u00f3rio O c\u00f3digo exemplo que ser\u00e1 utilizado nesse laborat\u00f3rio j\u00e1 se encontra no reposit\u00f3rio criado pelo classroom ( 1-PIO-IO ) e foi criado para ser o mais \u201climpo\u201d poss\u00edvel, inclusive, faltando algumas bibliotecas b\u00e1sicas para a compila\u00e7\u00e3o. O Laborat\u00f3rio ser\u00e1 feito em duas partes: Parte 1: Inserir drivers no projeto (ASF) Configura\u00e7\u00f5es b\u00e1sicas do microcontrolador (uC): clock e watchdog timer Configurar PIO para ACIONAR o pino conectado ao LED Controlar pino para fazer o LED piscar Parte 2: Configurar o PIO para LER o pino do bot\u00e3o em modo entrada Ler o bot\u00e3o e agir sobre o LED Task: Comen\u00e7ando Clone o reposit\u00f3rio criado pelo classroom Conecte a placa ao computador Abra o projeto 1-PIO-IO no microchip studio Progress Click para continuar.... Inicializando e configurando ASF J\u00e1 com o Microchip Studio aberto verifique o conte\u00fado do arquivo main.c o mesmo deve estar praticamente vazio salvo coment\u00e1rios, inclus\u00e3o do arquivo asf.h e duas fun\u00e7\u00e3o init e main . main.c #include \"asf.h\" // C\u00d3DIGO OMITIDO // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ) { } /************************************************************************/ /* Main */ /************************************************************************/ // Funcao principal chamada na inicalizacao do uC. int main ( void ) { init (); // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { } return 0 ; } O arquivo header asf.h \u00e9 criado e atualizado automaticamente pelo Microchip Studio e cont\u00e9m os frameworks/drivers inseridos no projeto. O Advanced Software Framework (ASF) que \u00e9 uma camada de abstra\u00e7\u00e3o do acesso ao hardware, possibilitando que configuremos partes espec\u00edficas do uC em um n\u00edvel de abstra\u00e7\u00e3o intermedi\u00e1rio. Note Pense no ASF como uma biblioteca de c\u00f3digos, nela podemos encontrar drivers para os diversos perif\u00e9ricos do microcontrolador e outras coisas que v\u00e3o nos ajudar a desenvolver diferentes projetos. A fun\u00e7\u00e3o init ser\u00e1 utilizada para inserirmos c\u00f3digos que far\u00e3o a inicializa\u00e7\u00e3o do uC e configura\u00e7\u00e3o correta dos perif\u00e9ricos e pinos. J\u00e1 a fun\u00e7\u00e3o main \u00e9 a primeira fun\u00e7\u00e3o a ser executada no uC (devido a linguagem C) e ser\u00e1 a orquestradora de todo o sistema, como ilustrado a seguir: main.c main (){ // inicializa\u00e7\u00e3o CLK // inicializa\u00e7\u00e3o PMC // inicializa\u00e7\u00e3o PIO init (); while ( 1 ){ // L\u00f3gica } } Modificando o ASF No Microchip Studio abra o ASF Wizard clicando na barra superior em: ASF ASF Wizard . Ap\u00f3s um tempo (sim demora para abrir) uma janela deve abrir contendo: a esquerda uma lista dos poss\u00edveis drivers que podem ser utilizados para o microcontrolador e na coluna da direita os drivers/bibliotecas j\u00e1 inseridas na solu\u00e7\u00e3o. Info No Microchip Studio um projeto cont\u00e9m uma c\u00f3pia dos c\u00f3digos das bibliotecas utilizadas, se voc\u00ea editar essa c\u00f3pia novos projetos n\u00e3o ser\u00e3o impactados. As seguintes bibliotecas j\u00e1 est\u00e3o selecionadas e inclu\u00eddas no projeto: Generic board support (driver) drivers de compila\u00e7\u00e3o para o uC da placa System Clock Control (service) fun\u00e7\u00f5es para controle do clock do uC Ser\u00e1 necess\u00e1rio adicionar as seguintes bibliotecas (APIs/ drivers) a esse projeto: Task: Incluir bibliotecas no projeto Voc\u00ea deve inserir as bibliotecas a seguir no projeto! GPIO - General purpose Input/OutPut (service) fun\u00e7\u00f5es para configura\u00e7\u00e3o do PIO IOPORT - General purpose I/O service (service) fun\u00e7\u00f5es para controle dos pinos MPU - Memory Protect Unit (driver) fun\u00e7\u00f5es para gerenciamento de mem\u00f3ria PMC - Power Management Controller (driver) fun\u00e7\u00f5es para configura\u00e7\u00e3o do perif\u00e9rico PMC e controle de clock dos perif\u00e9ricos PIO - Parallel Input/Output Controller (driver) fun\u00e7\u00f5es para controle do perif\u00e9rico PIO e controle dos pinos Delay routines fun\u00e7\u00f5es de delay (por software) Dica extra Para adicionar ou remover bibliotecas da solu\u00e7\u00e3o utilize a barra inferior: Ao final clique em APPLY para salvar as altera\u00e7\u00f5es. Progress Click para continuar.... Inicializa\u00e7\u00e3o do uC Antes da execu\u00e7\u00e3o do nosso c\u00f3digo \u00e9 necess\u00e1rio realizarmos configura\u00e7\u00f5es no uC que ir\u00e3o preparar o core. Essas configura\u00e7\u00f5es variam de uC para uC e podem incluir a configura\u00e7\u00e3o de: clock mem\u00f3ria de execu\u00e7\u00e3o / cache Desativar funcionalidades espec\u00edficas terminal para debug (printf) No nosso caso iremos come\u00e7ar configurando o clock do uC e desativando o WatchDog Timer . Task: Fun\u00e7\u00e3o init() Modifique a fun\u00e7\u00e3o init() para ficar como a seguir: // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ){ // Initialize the board clock sysclk_init (); // Desativa WatchDog Timer WDT -> WDT_MR = WDT_MR_WDDIS ; } Progress Click para continuar.... A fun\u00e7\u00e3o sysclk_init() \u00e9 respons\u00e1vel por aplicar as configura\u00e7\u00f5es do arquivo config/conf_clock.h no gerenciador de clock do microcontrolador, que est\u00e1 configurado para operar em 300 MHz . J\u00e1 a linha WDT->WDT_MR = WDT_MR_MDDIS faz com que o watchdog do microcontrolador seja desligado. Info WatchDog Timer como o pr\u00f3prio nome diz \u00e9 um c\u00e3o de guarda do microcontrolador. Ele \u00e9 respons\u00e1vel por verificar se o c\u00f3digo est\u00e1 'travado' em alguma parte, causando o reset for\u00e7ado do uC. O whatchdog timer deve ser ativado s\u00f3 nos est\u00e1gios finais de desenvolvimento de um produto. Progress Click para continuar.... Pino como sa\u00edda (output) Para configurarmos um pino como sa\u00edda ser\u00e1 necess\u00e1rio seguirmos os passos a seguir: Identificar o pino a ser controlado (extrair dados do manual/ placa/ projeto) Exportar para o c\u00f3digo informa\u00e7\u00f5es do pino Ativar/Energizar o perif\u00e9rico (PIO) respons\u00e1vel pelo pino Configurar o PIO para controlar o pino como sa\u00edda Controlar o pino (high/low). Dados do pino Antes de configurarmos um pino como entrada (bot\u00e3o) ou sa\u00edda (LED) \u00e9 necess\u00e1rio descobrimos qual pino iremos controlar, para isso devemos verificar o manual da placa ( manuais/SAME70-XPLD.pdf ) para saber quais pinos possu\u00edmos dispon\u00edveis para uso. No caso da nossa placa, possu\u00edmos um pino conectado a um bot\u00e3o e outro pino conectado ao LED (j\u00e1 vieram montados na placa). Todos os pinos digitais desse microcontrolador (em outros uC pode ser diferente) s\u00e3o conectados ao um perif\u00e9rico chamado de Parallel Input/Output Controller (PIO) , esse perif\u00e9rico \u00e9 respons\u00e1vel por configurar diversas propriedades desses pino, inclusive se ser\u00e1 entrada ou sa\u00edda (configurado individualmente). Cada PIO pode controlar at\u00e9 32 pinos (depois veremos o porque disso), e cada pino est\u00e1 conectado a um \u00fanico PIO. Cada PIO possui um nome referenciado por uma letra: PIO A ; PIO B ; PIO C ;.... E cada pino possui um n\u00famero \u00fanico dentro desse PIO, por exemplo PIOA11 referencia o \"pino 11\" do \"PIOA\". Outra nota\u00e7\u00e3o utilizada no manual \u00e9 PA11 , que representa a mesma coisa. SAME70-XPLD.pdf A sec\u00e7\u00e3o 4.4.3 LED do SAME70-XPLD descreve como o LED do kit de desenvolvimento foi utilizado na placa. Exercise Usando a informa\u00e7\u00e3o anterior responda (de um zoom na imagem): Qual pino e qual PIO \u00e9 respons\u00e1vel por controlar o LED? PIO D pino 0 PIO C pino 8 PIO VCC pino 3v3 Answer A tabela Table 4-16 LED Connection descreve qual o pino e qual PIO o LED do kit foi conectado, podemos a partir dos dados do manual extrair que o LED foi conectado ao pino PC8 do microcontrolador; \"O perif\u00e9rico PIO C, 'bit' 8 \u00e9 respons\u00e1vel por controlar o Liga/Desliga do LED verde da placa.\" Exercise Se colocarmos energia no pino ( 1 / High / vcc/ ligado) no pino conectado ao LED, ele ir\u00e1 acender ou apagar? Apagar Acender Answer O LED apaga quando o pino \u00e9 acionado (pino ligado/ um no pino/ high) e acende quando aterrado (pino desligado/ zero no pino/ low) Progress S\u00f3 continue se tiver realmente entendido. Podemos sintetizar as informa\u00e7\u00f5es do PIO que controla o pino na tabela a seguir: SAME70-XPLD PIO Index ID_PIO LED PIOC 8 12 Agora ser\u00e1 necess\u00e1rio transcrever essas informa\u00e7\u00f5es para o nosso c\u00f3digo em C, para isso iremos usar um recurso de C chamado define Task: Modifique main.c Iremos incorporar essa informa\u00e7\u00e3o no nosso c\u00f3digo via os #defines no come\u00e7o do main.c : #include \"asf.h\" #define LED_PIO PIOC // periferico que controla o LED // # (1) #define LED_PIO_ID ??? // ID do perif\u00e9rico PIOC (controla LED) #define LED_PIO_IDX 8 // ID do LED no PIO #define LED_PIO_IDX_MASK (1 << LED_PIO_IDX) // Mascara para CONTROLARMOS o LED :man_raising_hand: Notem que o LED_PIO_ID est\u00e1 incompleto (???), n\u00e3o se preocupe vamos preencher na sequ\u00eancia. #define #define em C \u00e9 uma macro, ou seja, \u00e9 um recurso de C que s\u00f3 existe em tempo de compila\u00e7\u00e3o, o define \u00e9 diferente de uma costante pois o compilador n\u00e3o ir\u00e1 alocar um endere\u00e7o de mem\u00f3ria para ela. Antes de compilar o programa, o compilador ir\u00e1 varrer o seu c\u00f3digo fonte e substituir todos os defines pelos valores definidos. Pense nisso como um recurso que facilita a vida do programador. Progress Click para continuar.... Fun\u00e7\u00e3o init() Vamos implementar os c\u00f3digos necess\u00e1rios para configurarmos o pino como sa\u00edda na fun\u00e7\u00e3o init PMC Antes de podemos configurar um PIO para controlar um pino \u00e9 necess\u00e1rio ativarmos esse perif\u00e9rico. A maioria dos perif\u00e9ricos do SAME70 inicializam desligados, isso \u00e9 feito para: diminuir o gasto energ\u00e9tico; e impedir a execuc\u00e3o de um perif\u00e9rico que n\u00e3o foi configurado. Info O Power Managament Controller (PMC) \u00e9 o perif\u00e9rico respons\u00e1vel por gerenciar energia de outros perif\u00e9ricos, isso \u00e9 feito via a libera\u00e7\u00e3o ou n\u00e3o do clock para os perif\u00e9ricos. O PMC possui tamb\u00e9m diversas outras funcionalidades, como descrito no manual do microcontrolador ( SAME70 Datasheet ): Cada perif\u00e9rico do uC possui um ID de identifica\u00e7\u00e3o ( sec 13 SAME70 Datasheet ) que \u00e9 utilizado para indicar ao PMC e ao NVIC (veremos futuramente) qual perif\u00e9rico estamos nos referindo. A seguir uma parte dessa tabela extra\u00edda do datasheet. Exercise Qual o ID que representa o PIOC? 10 11 12 Answer Pela tabela verificamos que o PIOC (aquele que ir\u00e1 controlar o LED) possui ID 12, agora precisamos transpor isso para o nosso c\u00f3digo! Vamos editar a linha do nosso main.c que possuia o ??? : Progress Click para continuar.... Task: Modifique main.c Insira o valor 12 no lugar do ??? no define LED_PIO_ID #define LED_PIO_ID 12 // ID do perif\u00e9rico PIOC (controla LED) Para evitar esse processo de ficar verifincando no manual o ID do perif\u00e9rico, podemos usar ID_PIOC no c\u00f3digo: #define LED_PIO_ID ID_PIOC // ID do perif\u00e9rico PIOC (controla LED) O ASF possui esses defines que facilitam muito o desenvolvimento e minimizam erros. Tarefa: Modifique main.c Troque o n\u00famero 12 do define por ID_PIOC Progress Click para continuar.... O PMC possui diversas fun\u00e7\u00f5es, estamos agora interessados naquela que ativa um perif\u00e9rico. Essa fun\u00e7\u00e3o \u00e9 a pmc_enable_periph_clk(uint32_t ul_id) que recebe como par\u00e2metro o ID do perif\u00e9rico que queremos ativar. Task: Modifique init() Insira o seguinte trecho de c\u00f3digo na nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o ( init() ) logo ap\u00f3s desativarmos o WDT : // Ativa o PIO na qual o LED foi conectado // para que possamos controlar o LED. pmc_enable_periph_clk ( LED_PIO_ID ); Tip Notem que estamos usando o define LED_PIO_ID e n\u00e3o o valor 12 (id do perif\u00e9rico), a quest\u00e3o \u00e9 que no fim \u00e9 a mesma coisa, mas o uso de LED_PIO_ID deixa o c\u00f3digo mais claro. Progress Click para continuar.... Configurando o pino do LED Todo pino no PIO \u00e9 inicializado em modo entrada, para usarmos como sa\u00edda ser\u00e1 necess\u00e1rio indicarmos ao PIO. Para isso, usaremos a seguinte fun\u00e7\u00e3o pio_set_output(...) , definida no ASF do SAME70 . Task: Modifique init() Inseria a seguinte chamada de fun\u00e7\u00e3o na inicializa\u00e7\u00e3o. Isso configura o PIOC para tratar o bit 8 (index 8) como sa\u00edda. //Inicializa PC8 como sa\u00edda pio_set_output ( LED_PIO , LED_PIO_IDX_MASK , 0 , 0 , 0 ); Podemos ler essa fun\u00e7\u00e3o da seguinte forma: Configura o index 8 (LED_PIO_IDX) do PIOC como sendo sa\u00edda inicializada com o valor '0', sem multidrive e sem resistor de pull-up . Notem que a fun\u00e7\u00e3o recebe como par\u00e2metro o PIO e a m\u00e1scara LED_PIO_IDX_MASK (que representa qual pino do PIO ser\u00e1 configurado). Veremos mais detalhes disso no pr\u00f3ximo laborat\u00f3rio. Progress Click para continuar.... A fun\u00e7\u00e3o pio_set_output() possui os seguintes par\u00e2metros: void pio_set_output ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_default_level , const uint32_t ul_multidrive_enable , const uint32_t ul_pull_up_enable ); Sendo: p_pio Pointer to a PIO instance. ul_mask Bitmask indicating which pin(s) to configure. ul_default_level Default level on the pin(s). ul_multidrive_enable Indicates if the pin(s) shall be configured as open-drain. ul_pull_up_enable Indicates if the pin shall have its pull-up activated. Tip Ap\u00f3s todas as etapas anteriores sua fun\u00e7\u00e3o init() deve ter ficado como a seguir: // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ){ // Initialize the board clock sysclk_init (); // Disativa WatchDog Timer WDT -> WDT_MR = WDT_MR_WDDIS ; // Ativa o PIO na qual o LED foi conectado // para que possamos controlar o LED. pmc_enable_periph_clk ( LED_PIO_ID ); //Inicializa PC8 como sa\u00edda pio_set_output ( LED_PIO , LED_PIO_IDX_MASK , 0 , 0 , 0 ); } Progress Click para continuar.... Controlando o LED Uma vez que as configura\u00e7\u00f5es gerais do uC j\u00e1 foram realizadas (clock e WDT) e que o perif\u00e9rico PIOC8 j\u00e1 est\u00e1 pronto para acionar o LED (ou o que estiver conectado nele) podemos come\u00e7ar a fazer nossa implementa\u00e7\u00e3o na fun\u00e7\u00e3o main . Duas s\u00e3o as fun\u00e7\u00f5es que iremos usar para acionar ou limpar um determinado pino: // coloca 1 no pino do LED. pio_set ( LED_PIO , LED_PIO_IDX_MASK ); // coloca 0 no pino do LED pio_clear ( LED_PIO , LED_PIO_IDX_MASK ); Documenta\u00e7\u00e3o das fun\u00e7\u00f5es pio_set pio_clear Selecione a func\u00e3o correta que faz o LED acender . pio_set(LED_PIO, LED_PIO_IDX_MASK); pio_clear(LED_PIO, LED_PIO_IDX_MASK); Answer Lembre que para acender o LED devemos colocar n\u00edvel 0 no pino, para isso usamos a func\u00e3o pio_clear() . J\u00e1 para apagar o LED devemos colocar valor 1 , usando a func\u00e3o pio_set() Task: Modifique main() Modifique a fun\u00e7\u00e3o main para fazermos o LED piscar interruptamente (1 -> delay 200 ms -> 0 -> delay 200 ms -> ....): Lembre de: Compilar o c\u00f3digo e programar o uC Verifique o resultado esperado Brinque com os valores da fun\u00e7\u00e3o delay_ms // Funcao principal chamada na inicalizacao do uC. int main ( void ) { // inicializa sistema e IOs init (); // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { pio_set ( LED_PIO , LED_PIO_IDX_MASK ); // Coloca 1 no pino LED delay_ms ( 200 ); // Delay por software de 200 ms pio_clear ( LED_PIO , LED_PIO_IDX_MASK ); // Coloca 0 no pino do LED delay_ms ( 200 ); // Delay por software de 200 ms } return 0 ; } Task: Praticando Agora fa\u00e7a o LED ficar aceso por 3 segundos e ficar apagado por 1 segundo. Programe o uC Verifique o resultado esperado Progress Click para continuar.... Analogia com o Arduino No arduino esse mesmo c\u00f3digo seria escrito da seguinte forma: // the setup function runs once when you press reset or power the board void setup () { // initialize digital pin LED_BUILTIN as an output. pinMode ( LED_BUILTIN , OUTPUT ); } // the loop function runs over and over again forever void loop () { digitalWrite ( LED_BUILTIN , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( LED_BUILTIN , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } O Arduino esconde a fun\u00e7\u00e3o main(), que seria: void main ( void ){ init (); setup (); while ( 1 ){ loop (); } } Note que a fun\u00e7\u00e3o setup() do arduino precede de uma oura fun\u00e7\u00e3o init() que possui funcionalidade parecidas com a nossa de inicializar o clock do sistema e desabilitar o WDT. Progress Click para continuar.... Pino como entrada (input) Para configurarmos um pino como entrada ser\u00e1 necess\u00e1rio: Identificar o pino a ser controlado (extrair dados do manual) Exportar para o c\u00f3digo informa\u00e7\u00f5es do pino Ativar o perif\u00e9rico (PIO) respons\u00e1vel pelo pino Configurar o PIO para controlar o pino como entrada Ler o valor do pino. Extraindo dados do manual O kit de desenvolvimento SAME7-XPLD possui dois bot\u00f5es, um deles reservado para o reset do microcontrolador e outro de uso geral. Exercise Utilizando o manual do kit de desenvolvimento ( SAME70-XPLD.pdf ) preencha a tabela a seguir: Perif. SAME70-XPLD PIO(A,B,C,D,...) INDEX ID_PIO Bot\u00e3o SW300 DICA: Ver novamente como foi feito com o LED. Answer Solu\u00e7\u00e3o: Perif. SAME70-XPLD PIO(A,B,C,D,...) INDEX ID_PIO Bot\u00e3o SW300 PIO A 11 10 Progress Click para continuar.... Exportando informa\u00e7\u00f5es para o c\u00f3digo Agora precisamos fazer a ponte entre o mundo externo e o firmware que ser\u00e1 executado no microcontrolador, pela tabela anterior insira e complete os defines a seguir no main.c (perto dos defines do LED). Task Com a tabela preenchida agora conseguimos passar a informacao para o c\u00f3digo com novos defines, da mesma maneira que foi feito o LED: Criei os defines no main.c e coloque os valores extra\u00eddos da tabela: // Configuracoes do botao #define BUT_PIO #define BUT_PIO_ID #define BUT_PIO_IDX #define BUT_PIO_IDX_MASK (1u << BUT_PIO_IDX) // esse j\u00e1 est\u00e1 pronto. Progress Click para continuar.... Fun\u00e7\u00e3o init() Agora \u00e9 necess\u00e1rio: Ativarmos o PIO no PMC Configurarmos o novo pino como entrada Ativamos PULL-UP no pino PMC PIO Com os defines \"definidos\" podemos ativar o clock do PIO que gerencia o pino, para isso insira na fun\u00e7\u00e3o de inicializa\u00e7\u00e3o init() ap\u00f3s a inicializa\u00e7\u00e3o do LED. Task Modifique a fun\u00e7\u00e3o init() inserindo a inicializa\u00e7\u00e3o do novo PIO: // Inicializa PIO do botao pmc_enable_periph_clk ( BUT_PIO_ID ); Configurando o pino como Input Agora \u00e9 necess\u00e1rio configurarmos o BUT_PIO para gerenciar o BUT_PIO_IDX como uma entrada, para isso usaremos a fun\u00e7\u00e3o pio_set_input() definida na biblioteca da ASF: // configura pino ligado ao bot\u00e3o como entrada com um pull-up. pio_set_input ( ARG0 , ARG1 , ARG2 ); Task Voc\u00ea deve fazer a chamada da fun\u00e7\u00e3o pio_set_input na func\u00e3o init , substituindo os argumentos pelos valores corretos. Para isso voc\u00ea deve ler a descri\u00e7\u00e3o da fun\u00e7\u00e3o: pio_set_input() pio_set_input ( ARG0 , ARG1 , PIO_DEFAULT ); No ul_attribute utilize: PIO_DEFAULT . Progress Click para continuar.... PULL-UP Para esse pino funcionar \u00e9 necess\u00e1rio que ativemos o pull-up nele. Pull-up \u00e9 um resistor alimentando para VCC , ele faz com que o valor padr\u00e3o do pino seja o energizado. Para ativarmos o pull-up basta chamar a fun\u00e7\u00e3o: pio_pull_up() com os par\u00e2metros correto. A fun\u00e7\u00e3o est\u00e1 detalhada na documenta\u00e7\u00e3o do ASF. Task: Modifique: init() Voc\u00ea deve fazer uso da fun\u00e7\u00e3o pio_pull_up() na fun\u00e7\u00e3o init() Progress Click para continuar.... Lendo o bot\u00e3o Para lermos um valor de um pino, que j\u00e1 foi configurado como entrada, devemos utilizar alguma das fun\u00e7\u00f5es fornecidas no ASF de interface com o PIO, procure por ela na documenta\u00e7\u00e3o do PIO. Exercise Qual fun\u00e7\u00e3o pode ser utilizada para ler o valor digital do pino PA11? Consulte as fun\u00e7\u00f5es dispon\u00edveis na documenta\u00e7\u00e3o do ASF PIO Answer A fun\u00e7\u00e3o a ser utilizada \u00e9 a pio_get() Progress Click para continuar.... Implementando a l\u00f3gica Vamos usar o bot\u00e3o para fazer alguma coisa? Agora conseguimos acionar um pino (LED) e ler um pino (bot\u00e3o). Task Faca um c\u00f3digo que o LED pisca 5 vezes na sequ\u00eancia somente quando o bot\u00e3o da placa for pressionado. Lembre de usar a fun\u00e7\u00e3o pio_get() , voc\u00ea vai precisar realizar uma condi\u00e7\u00e3o com o valor que ela retorna. Utilize PIO_INPUT no par\u00e2metro ul_type da fun\u00e7\u00e3o. N\u00e3o funcionou? De uma olhada como eu implementei: https://github.com/Insper/SAME70-examples/blob/96fb17e758e7eef9273ca2ddfb8dcd33ebcb4eb7/Perifericos-uC/PIO-IO/PIO-IO/src/main.c#L66 Progress Click para continuar.... Praticando (entrega obrigat\u00f3ria) Task Muito bom! Agora vamos pegar a placa OLED1 (que voc\u00ea recebeu no kit) e usar os LEDs e Boto\u1ebds dela? Para isso voc\u00ea vai ter que entender quais pinos configurar como entrada e sa\u00edda. A placa possui tr\u00eas bot\u00f5es e tr\u00eas LEDs que podem ser lidos e controlados pelo microcontrolador. A ideia da atividade \u00e9 que cada bot\u00e3o controle o LED associado a ele (Bot\u00e3o 1 - Led 1/ Bot\u00e3o 2 - Led 2/ ...) fazendo piscar da mesma maneira como feito com o bot\u00e3o da placa (cada botao controla um LED). Para isso, voc\u00eas devem conectar a placa OLED na entrada EXT-1 do seu kit e ent\u00e3o consultar os manuais no link a seguir para saber qual pino devem configurar como sa\u00edda (LEDs) e quais devem configurar como entrada (Bot\u00f5es) Dica: Comece pelos LEDs (fazendo piscar) e depois v\u00e1 implementando os bot\u00f5es um a um. Link para os documentos: https://insper.github.io/ComputacaoEmbarcada/navigation/Util/Util-Documentos/ OLED1 Xplained Pro User Guide: Explica a placa OLED SAME70-XPLD.pdf: Explica a placa de desenvolviment Preencher ao finalizar o lab Carregando\u2026","title":"Lab"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#lab-pio","text":"Pasta: /1-PIO-IO Data LIMITE para entrega: 23/08/22 - 23h59 Info Os laborat\u00f3rios s\u00e3o individuais e cada aluno deve ter um reposit\u00f3rio com todas as enteegas, o reposit\u00f3rio deve ser criado pelo classroom usando o link a seguir: https://classroom.github.com/a/xjegYr_C Progress Click para continuar....","title":"LAB - PIO"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#entrega","text":"Ao final desse laborat\u00f3rio voc\u00ea deve ser capaz de controlar e ler pinos digitais do microcontrolador a fim de podermos acionar sa\u00eddas (LEDs/ Buzzers/ motores) e lermos entradas (bot\u00f5es/ sensores/ ...). Ao final do laborat\u00f3rio voc\u00eas ter\u00e3o: Um LED piscando a cada segundo A leitura de um bot\u00e3o (entrada) LED acionado pelo bot\u00e3o Feito esse lab j\u00e1 da para come\u00e7ar a APS 1 onde voc\u00eas ter\u00e3o que desenvolver um sistema embarcado que reproduz uma m\u00fasica monofonia.","title":"Entrega"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#laboratorio","text":"O c\u00f3digo exemplo que ser\u00e1 utilizado nesse laborat\u00f3rio j\u00e1 se encontra no reposit\u00f3rio criado pelo classroom ( 1-PIO-IO ) e foi criado para ser o mais \u201climpo\u201d poss\u00edvel, inclusive, faltando algumas bibliotecas b\u00e1sicas para a compila\u00e7\u00e3o. O Laborat\u00f3rio ser\u00e1 feito em duas partes: Parte 1: Inserir drivers no projeto (ASF) Configura\u00e7\u00f5es b\u00e1sicas do microcontrolador (uC): clock e watchdog timer Configurar PIO para ACIONAR o pino conectado ao LED Controlar pino para fazer o LED piscar Parte 2: Configurar o PIO para LER o pino do bot\u00e3o em modo entrada Ler o bot\u00e3o e agir sobre o LED Task: Comen\u00e7ando Clone o reposit\u00f3rio criado pelo classroom Conecte a placa ao computador Abra o projeto 1-PIO-IO no microchip studio Progress Click para continuar....","title":"Laborat\u00f3rio"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#inicializando-e-configurando-asf","text":"J\u00e1 com o Microchip Studio aberto verifique o conte\u00fado do arquivo main.c o mesmo deve estar praticamente vazio salvo coment\u00e1rios, inclus\u00e3o do arquivo asf.h e duas fun\u00e7\u00e3o init e main . main.c #include \"asf.h\" // C\u00d3DIGO OMITIDO // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ) { } /************************************************************************/ /* Main */ /************************************************************************/ // Funcao principal chamada na inicalizacao do uC. int main ( void ) { init (); // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { } return 0 ; } O arquivo header asf.h \u00e9 criado e atualizado automaticamente pelo Microchip Studio e cont\u00e9m os frameworks/drivers inseridos no projeto. O Advanced Software Framework (ASF) que \u00e9 uma camada de abstra\u00e7\u00e3o do acesso ao hardware, possibilitando que configuremos partes espec\u00edficas do uC em um n\u00edvel de abstra\u00e7\u00e3o intermedi\u00e1rio. Note Pense no ASF como uma biblioteca de c\u00f3digos, nela podemos encontrar drivers para os diversos perif\u00e9ricos do microcontrolador e outras coisas que v\u00e3o nos ajudar a desenvolver diferentes projetos. A fun\u00e7\u00e3o init ser\u00e1 utilizada para inserirmos c\u00f3digos que far\u00e3o a inicializa\u00e7\u00e3o do uC e configura\u00e7\u00e3o correta dos perif\u00e9ricos e pinos. J\u00e1 a fun\u00e7\u00e3o main \u00e9 a primeira fun\u00e7\u00e3o a ser executada no uC (devido a linguagem C) e ser\u00e1 a orquestradora de todo o sistema, como ilustrado a seguir: main.c main (){ // inicializa\u00e7\u00e3o CLK // inicializa\u00e7\u00e3o PMC // inicializa\u00e7\u00e3o PIO init (); while ( 1 ){ // L\u00f3gica } }","title":"Inicializando e configurando ASF"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#modificando-o-asf","text":"No Microchip Studio abra o ASF Wizard clicando na barra superior em: ASF ASF Wizard . Ap\u00f3s um tempo (sim demora para abrir) uma janela deve abrir contendo: a esquerda uma lista dos poss\u00edveis drivers que podem ser utilizados para o microcontrolador e na coluna da direita os drivers/bibliotecas j\u00e1 inseridas na solu\u00e7\u00e3o. Info No Microchip Studio um projeto cont\u00e9m uma c\u00f3pia dos c\u00f3digos das bibliotecas utilizadas, se voc\u00ea editar essa c\u00f3pia novos projetos n\u00e3o ser\u00e3o impactados. As seguintes bibliotecas j\u00e1 est\u00e3o selecionadas e inclu\u00eddas no projeto: Generic board support (driver) drivers de compila\u00e7\u00e3o para o uC da placa System Clock Control (service) fun\u00e7\u00f5es para controle do clock do uC Ser\u00e1 necess\u00e1rio adicionar as seguintes bibliotecas (APIs/ drivers) a esse projeto: Task: Incluir bibliotecas no projeto Voc\u00ea deve inserir as bibliotecas a seguir no projeto! GPIO - General purpose Input/OutPut (service) fun\u00e7\u00f5es para configura\u00e7\u00e3o do PIO IOPORT - General purpose I/O service (service) fun\u00e7\u00f5es para controle dos pinos MPU - Memory Protect Unit (driver) fun\u00e7\u00f5es para gerenciamento de mem\u00f3ria PMC - Power Management Controller (driver) fun\u00e7\u00f5es para configura\u00e7\u00e3o do perif\u00e9rico PMC e controle de clock dos perif\u00e9ricos PIO - Parallel Input/Output Controller (driver) fun\u00e7\u00f5es para controle do perif\u00e9rico PIO e controle dos pinos Delay routines fun\u00e7\u00f5es de delay (por software) Dica extra Para adicionar ou remover bibliotecas da solu\u00e7\u00e3o utilize a barra inferior: Ao final clique em APPLY para salvar as altera\u00e7\u00f5es. Progress Click para continuar....","title":"Modificando o ASF"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#inicializacao-do-uc","text":"Antes da execu\u00e7\u00e3o do nosso c\u00f3digo \u00e9 necess\u00e1rio realizarmos configura\u00e7\u00f5es no uC que ir\u00e3o preparar o core. Essas configura\u00e7\u00f5es variam de uC para uC e podem incluir a configura\u00e7\u00e3o de: clock mem\u00f3ria de execu\u00e7\u00e3o / cache Desativar funcionalidades espec\u00edficas terminal para debug (printf) No nosso caso iremos come\u00e7ar configurando o clock do uC e desativando o WatchDog Timer . Task: Fun\u00e7\u00e3o init() Modifique a fun\u00e7\u00e3o init() para ficar como a seguir: // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ){ // Initialize the board clock sysclk_init (); // Desativa WatchDog Timer WDT -> WDT_MR = WDT_MR_WDDIS ; } Progress Click para continuar.... A fun\u00e7\u00e3o sysclk_init() \u00e9 respons\u00e1vel por aplicar as configura\u00e7\u00f5es do arquivo config/conf_clock.h no gerenciador de clock do microcontrolador, que est\u00e1 configurado para operar em 300 MHz . J\u00e1 a linha WDT->WDT_MR = WDT_MR_MDDIS faz com que o watchdog do microcontrolador seja desligado. Info WatchDog Timer como o pr\u00f3prio nome diz \u00e9 um c\u00e3o de guarda do microcontrolador. Ele \u00e9 respons\u00e1vel por verificar se o c\u00f3digo est\u00e1 'travado' em alguma parte, causando o reset for\u00e7ado do uC. O whatchdog timer deve ser ativado s\u00f3 nos est\u00e1gios finais de desenvolvimento de um produto. Progress Click para continuar....","title":"Inicializa\u00e7\u00e3o do uC"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#pino-como-saida-output","text":"Para configurarmos um pino como sa\u00edda ser\u00e1 necess\u00e1rio seguirmos os passos a seguir: Identificar o pino a ser controlado (extrair dados do manual/ placa/ projeto) Exportar para o c\u00f3digo informa\u00e7\u00f5es do pino Ativar/Energizar o perif\u00e9rico (PIO) respons\u00e1vel pelo pino Configurar o PIO para controlar o pino como sa\u00edda Controlar o pino (high/low).","title":"Pino como sa\u00edda (output)"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#dados-do-pino","text":"Antes de configurarmos um pino como entrada (bot\u00e3o) ou sa\u00edda (LED) \u00e9 necess\u00e1rio descobrimos qual pino iremos controlar, para isso devemos verificar o manual da placa ( manuais/SAME70-XPLD.pdf ) para saber quais pinos possu\u00edmos dispon\u00edveis para uso. No caso da nossa placa, possu\u00edmos um pino conectado a um bot\u00e3o e outro pino conectado ao LED (j\u00e1 vieram montados na placa). Todos os pinos digitais desse microcontrolador (em outros uC pode ser diferente) s\u00e3o conectados ao um perif\u00e9rico chamado de Parallel Input/Output Controller (PIO) , esse perif\u00e9rico \u00e9 respons\u00e1vel por configurar diversas propriedades desses pino, inclusive se ser\u00e1 entrada ou sa\u00edda (configurado individualmente). Cada PIO pode controlar at\u00e9 32 pinos (depois veremos o porque disso), e cada pino est\u00e1 conectado a um \u00fanico PIO. Cada PIO possui um nome referenciado por uma letra: PIO A ; PIO B ; PIO C ;.... E cada pino possui um n\u00famero \u00fanico dentro desse PIO, por exemplo PIOA11 referencia o \"pino 11\" do \"PIOA\". Outra nota\u00e7\u00e3o utilizada no manual \u00e9 PA11 , que representa a mesma coisa. SAME70-XPLD.pdf A sec\u00e7\u00e3o 4.4.3 LED do SAME70-XPLD descreve como o LED do kit de desenvolvimento foi utilizado na placa. Exercise Usando a informa\u00e7\u00e3o anterior responda (de um zoom na imagem): Qual pino e qual PIO \u00e9 respons\u00e1vel por controlar o LED? PIO D pino 0 PIO C pino 8 PIO VCC pino 3v3 Answer A tabela Table 4-16 LED Connection descreve qual o pino e qual PIO o LED do kit foi conectado, podemos a partir dos dados do manual extrair que o LED foi conectado ao pino PC8 do microcontrolador; \"O perif\u00e9rico PIO C, 'bit' 8 \u00e9 respons\u00e1vel por controlar o Liga/Desliga do LED verde da placa.\" Exercise Se colocarmos energia no pino ( 1 / High / vcc/ ligado) no pino conectado ao LED, ele ir\u00e1 acender ou apagar? Apagar Acender Answer O LED apaga quando o pino \u00e9 acionado (pino ligado/ um no pino/ high) e acende quando aterrado (pino desligado/ zero no pino/ low) Progress S\u00f3 continue se tiver realmente entendido. Podemos sintetizar as informa\u00e7\u00f5es do PIO que controla o pino na tabela a seguir: SAME70-XPLD PIO Index ID_PIO LED PIOC 8 12 Agora ser\u00e1 necess\u00e1rio transcrever essas informa\u00e7\u00f5es para o nosso c\u00f3digo em C, para isso iremos usar um recurso de C chamado define Task: Modifique main.c Iremos incorporar essa informa\u00e7\u00e3o no nosso c\u00f3digo via os #defines no come\u00e7o do main.c : #include \"asf.h\" #define LED_PIO PIOC // periferico que controla o LED // # (1) #define LED_PIO_ID ??? // ID do perif\u00e9rico PIOC (controla LED) #define LED_PIO_IDX 8 // ID do LED no PIO #define LED_PIO_IDX_MASK (1 << LED_PIO_IDX) // Mascara para CONTROLARMOS o LED :man_raising_hand: Notem que o LED_PIO_ID est\u00e1 incompleto (???), n\u00e3o se preocupe vamos preencher na sequ\u00eancia. #define #define em C \u00e9 uma macro, ou seja, \u00e9 um recurso de C que s\u00f3 existe em tempo de compila\u00e7\u00e3o, o define \u00e9 diferente de uma costante pois o compilador n\u00e3o ir\u00e1 alocar um endere\u00e7o de mem\u00f3ria para ela. Antes de compilar o programa, o compilador ir\u00e1 varrer o seu c\u00f3digo fonte e substituir todos os defines pelos valores definidos. Pense nisso como um recurso que facilita a vida do programador. Progress Click para continuar....","title":"Dados do pino"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#funcao-init","text":"Vamos implementar os c\u00f3digos necess\u00e1rios para configurarmos o pino como sa\u00edda na fun\u00e7\u00e3o init","title":"Fun\u00e7\u00e3o init()"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#pmc","text":"Antes de podemos configurar um PIO para controlar um pino \u00e9 necess\u00e1rio ativarmos esse perif\u00e9rico. A maioria dos perif\u00e9ricos do SAME70 inicializam desligados, isso \u00e9 feito para: diminuir o gasto energ\u00e9tico; e impedir a execuc\u00e3o de um perif\u00e9rico que n\u00e3o foi configurado. Info O Power Managament Controller (PMC) \u00e9 o perif\u00e9rico respons\u00e1vel por gerenciar energia de outros perif\u00e9ricos, isso \u00e9 feito via a libera\u00e7\u00e3o ou n\u00e3o do clock para os perif\u00e9ricos. O PMC possui tamb\u00e9m diversas outras funcionalidades, como descrito no manual do microcontrolador ( SAME70 Datasheet ): Cada perif\u00e9rico do uC possui um ID de identifica\u00e7\u00e3o ( sec 13 SAME70 Datasheet ) que \u00e9 utilizado para indicar ao PMC e ao NVIC (veremos futuramente) qual perif\u00e9rico estamos nos referindo. A seguir uma parte dessa tabela extra\u00edda do datasheet. Exercise Qual o ID que representa o PIOC? 10 11 12 Answer Pela tabela verificamos que o PIOC (aquele que ir\u00e1 controlar o LED) possui ID 12, agora precisamos transpor isso para o nosso c\u00f3digo! Vamos editar a linha do nosso main.c que possuia o ??? : Progress Click para continuar.... Task: Modifique main.c Insira o valor 12 no lugar do ??? no define LED_PIO_ID #define LED_PIO_ID 12 // ID do perif\u00e9rico PIOC (controla LED) Para evitar esse processo de ficar verifincando no manual o ID do perif\u00e9rico, podemos usar ID_PIOC no c\u00f3digo: #define LED_PIO_ID ID_PIOC // ID do perif\u00e9rico PIOC (controla LED) O ASF possui esses defines que facilitam muito o desenvolvimento e minimizam erros. Tarefa: Modifique main.c Troque o n\u00famero 12 do define por ID_PIOC Progress Click para continuar.... O PMC possui diversas fun\u00e7\u00f5es, estamos agora interessados naquela que ativa um perif\u00e9rico. Essa fun\u00e7\u00e3o \u00e9 a pmc_enable_periph_clk(uint32_t ul_id) que recebe como par\u00e2metro o ID do perif\u00e9rico que queremos ativar. Task: Modifique init() Insira o seguinte trecho de c\u00f3digo na nossa fun\u00e7\u00e3o de inicializa\u00e7\u00e3o ( init() ) logo ap\u00f3s desativarmos o WDT : // Ativa o PIO na qual o LED foi conectado // para que possamos controlar o LED. pmc_enable_periph_clk ( LED_PIO_ID ); Tip Notem que estamos usando o define LED_PIO_ID e n\u00e3o o valor 12 (id do perif\u00e9rico), a quest\u00e3o \u00e9 que no fim \u00e9 a mesma coisa, mas o uso de LED_PIO_ID deixa o c\u00f3digo mais claro. Progress Click para continuar....","title":"PMC"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#configurando-o-pino-do-led","text":"Todo pino no PIO \u00e9 inicializado em modo entrada, para usarmos como sa\u00edda ser\u00e1 necess\u00e1rio indicarmos ao PIO. Para isso, usaremos a seguinte fun\u00e7\u00e3o pio_set_output(...) , definida no ASF do SAME70 . Task: Modifique init() Inseria a seguinte chamada de fun\u00e7\u00e3o na inicializa\u00e7\u00e3o. Isso configura o PIOC para tratar o bit 8 (index 8) como sa\u00edda. //Inicializa PC8 como sa\u00edda pio_set_output ( LED_PIO , LED_PIO_IDX_MASK , 0 , 0 , 0 ); Podemos ler essa fun\u00e7\u00e3o da seguinte forma: Configura o index 8 (LED_PIO_IDX) do PIOC como sendo sa\u00edda inicializada com o valor '0', sem multidrive e sem resistor de pull-up . Notem que a fun\u00e7\u00e3o recebe como par\u00e2metro o PIO e a m\u00e1scara LED_PIO_IDX_MASK (que representa qual pino do PIO ser\u00e1 configurado). Veremos mais detalhes disso no pr\u00f3ximo laborat\u00f3rio. Progress Click para continuar.... A fun\u00e7\u00e3o pio_set_output() possui os seguintes par\u00e2metros: void pio_set_output ( Pio * p_pio , const uint32_t ul_mask , const uint32_t ul_default_level , const uint32_t ul_multidrive_enable , const uint32_t ul_pull_up_enable ); Sendo: p_pio Pointer to a PIO instance. ul_mask Bitmask indicating which pin(s) to configure. ul_default_level Default level on the pin(s). ul_multidrive_enable Indicates if the pin(s) shall be configured as open-drain. ul_pull_up_enable Indicates if the pin shall have its pull-up activated. Tip Ap\u00f3s todas as etapas anteriores sua fun\u00e7\u00e3o init() deve ter ficado como a seguir: // Fun\u00e7\u00e3o de inicializa\u00e7\u00e3o do uC void init ( void ){ // Initialize the board clock sysclk_init (); // Disativa WatchDog Timer WDT -> WDT_MR = WDT_MR_WDDIS ; // Ativa o PIO na qual o LED foi conectado // para que possamos controlar o LED. pmc_enable_periph_clk ( LED_PIO_ID ); //Inicializa PC8 como sa\u00edda pio_set_output ( LED_PIO , LED_PIO_IDX_MASK , 0 , 0 , 0 ); } Progress Click para continuar....","title":"Configurando o pino do LED"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#controlando-o-led","text":"Uma vez que as configura\u00e7\u00f5es gerais do uC j\u00e1 foram realizadas (clock e WDT) e que o perif\u00e9rico PIOC8 j\u00e1 est\u00e1 pronto para acionar o LED (ou o que estiver conectado nele) podemos come\u00e7ar a fazer nossa implementa\u00e7\u00e3o na fun\u00e7\u00e3o main . Duas s\u00e3o as fun\u00e7\u00f5es que iremos usar para acionar ou limpar um determinado pino: // coloca 1 no pino do LED. pio_set ( LED_PIO , LED_PIO_IDX_MASK ); // coloca 0 no pino do LED pio_clear ( LED_PIO , LED_PIO_IDX_MASK ); Documenta\u00e7\u00e3o das fun\u00e7\u00f5es pio_set pio_clear Selecione a func\u00e3o correta que faz o LED acender . pio_set(LED_PIO, LED_PIO_IDX_MASK); pio_clear(LED_PIO, LED_PIO_IDX_MASK); Answer Lembre que para acender o LED devemos colocar n\u00edvel 0 no pino, para isso usamos a func\u00e3o pio_clear() . J\u00e1 para apagar o LED devemos colocar valor 1 , usando a func\u00e3o pio_set() Task: Modifique main() Modifique a fun\u00e7\u00e3o main para fazermos o LED piscar interruptamente (1 -> delay 200 ms -> 0 -> delay 200 ms -> ....): Lembre de: Compilar o c\u00f3digo e programar o uC Verifique o resultado esperado Brinque com os valores da fun\u00e7\u00e3o delay_ms // Funcao principal chamada na inicalizacao do uC. int main ( void ) { // inicializa sistema e IOs init (); // super loop // aplicacoes embarcadas n\u00e3o devem sair do while(1). while ( 1 ) { pio_set ( LED_PIO , LED_PIO_IDX_MASK ); // Coloca 1 no pino LED delay_ms ( 200 ); // Delay por software de 200 ms pio_clear ( LED_PIO , LED_PIO_IDX_MASK ); // Coloca 0 no pino do LED delay_ms ( 200 ); // Delay por software de 200 ms } return 0 ; } Task: Praticando Agora fa\u00e7a o LED ficar aceso por 3 segundos e ficar apagado por 1 segundo. Programe o uC Verifique o resultado esperado Progress Click para continuar.... Analogia com o Arduino No arduino esse mesmo c\u00f3digo seria escrito da seguinte forma: // the setup function runs once when you press reset or power the board void setup () { // initialize digital pin LED_BUILTIN as an output. pinMode ( LED_BUILTIN , OUTPUT ); } // the loop function runs over and over again forever void loop () { digitalWrite ( LED_BUILTIN , HIGH ); // turn the LED on (HIGH is the voltage level) delay ( 1000 ); // wait for a second digitalWrite ( LED_BUILTIN , LOW ); // turn the LED off by making the voltage LOW delay ( 1000 ); // wait for a second } O Arduino esconde a fun\u00e7\u00e3o main(), que seria: void main ( void ){ init (); setup (); while ( 1 ){ loop (); } } Note que a fun\u00e7\u00e3o setup() do arduino precede de uma oura fun\u00e7\u00e3o init() que possui funcionalidade parecidas com a nossa de inicializar o clock do sistema e desabilitar o WDT. Progress Click para continuar....","title":"Controlando o LED"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#pino-como-entrada-input","text":"Para configurarmos um pino como entrada ser\u00e1 necess\u00e1rio: Identificar o pino a ser controlado (extrair dados do manual) Exportar para o c\u00f3digo informa\u00e7\u00f5es do pino Ativar o perif\u00e9rico (PIO) respons\u00e1vel pelo pino Configurar o PIO para controlar o pino como entrada Ler o valor do pino.","title":"Pino como entrada (input)"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#extraindo-dados-do-manual","text":"O kit de desenvolvimento SAME7-XPLD possui dois bot\u00f5es, um deles reservado para o reset do microcontrolador e outro de uso geral. Exercise Utilizando o manual do kit de desenvolvimento ( SAME70-XPLD.pdf ) preencha a tabela a seguir: Perif. SAME70-XPLD PIO(A,B,C,D,...) INDEX ID_PIO Bot\u00e3o SW300 DICA: Ver novamente como foi feito com o LED. Answer Solu\u00e7\u00e3o: Perif. SAME70-XPLD PIO(A,B,C,D,...) INDEX ID_PIO Bot\u00e3o SW300 PIO A 11 10 Progress Click para continuar....","title":"Extraindo dados do manual"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#exportando-informacoes-para-o-codigo","text":"Agora precisamos fazer a ponte entre o mundo externo e o firmware que ser\u00e1 executado no microcontrolador, pela tabela anterior insira e complete os defines a seguir no main.c (perto dos defines do LED). Task Com a tabela preenchida agora conseguimos passar a informacao para o c\u00f3digo com novos defines, da mesma maneira que foi feito o LED: Criei os defines no main.c e coloque os valores extra\u00eddos da tabela: // Configuracoes do botao #define BUT_PIO #define BUT_PIO_ID #define BUT_PIO_IDX #define BUT_PIO_IDX_MASK (1u << BUT_PIO_IDX) // esse j\u00e1 est\u00e1 pronto. Progress Click para continuar....","title":"Exportando informa\u00e7\u00f5es para o c\u00f3digo"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#funcao-init_1","text":"Agora \u00e9 necess\u00e1rio: Ativarmos o PIO no PMC Configurarmos o novo pino como entrada Ativamos PULL-UP no pino","title":"Fun\u00e7\u00e3o init()"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#pmc-pio","text":"Com os defines \"definidos\" podemos ativar o clock do PIO que gerencia o pino, para isso insira na fun\u00e7\u00e3o de inicializa\u00e7\u00e3o init() ap\u00f3s a inicializa\u00e7\u00e3o do LED. Task Modifique a fun\u00e7\u00e3o init() inserindo a inicializa\u00e7\u00e3o do novo PIO: // Inicializa PIO do botao pmc_enable_periph_clk ( BUT_PIO_ID );","title":"PMC PIO"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#configurando-o-pino-como-input","text":"Agora \u00e9 necess\u00e1rio configurarmos o BUT_PIO para gerenciar o BUT_PIO_IDX como uma entrada, para isso usaremos a fun\u00e7\u00e3o pio_set_input() definida na biblioteca da ASF: // configura pino ligado ao bot\u00e3o como entrada com um pull-up. pio_set_input ( ARG0 , ARG1 , ARG2 ); Task Voc\u00ea deve fazer a chamada da fun\u00e7\u00e3o pio_set_input na func\u00e3o init , substituindo os argumentos pelos valores corretos. Para isso voc\u00ea deve ler a descri\u00e7\u00e3o da fun\u00e7\u00e3o: pio_set_input() pio_set_input ( ARG0 , ARG1 , PIO_DEFAULT ); No ul_attribute utilize: PIO_DEFAULT . Progress Click para continuar....","title":"Configurando o pino como Input"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#pull-up","text":"Para esse pino funcionar \u00e9 necess\u00e1rio que ativemos o pull-up nele. Pull-up \u00e9 um resistor alimentando para VCC , ele faz com que o valor padr\u00e3o do pino seja o energizado. Para ativarmos o pull-up basta chamar a fun\u00e7\u00e3o: pio_pull_up() com os par\u00e2metros correto. A fun\u00e7\u00e3o est\u00e1 detalhada na documenta\u00e7\u00e3o do ASF. Task: Modifique: init() Voc\u00ea deve fazer uso da fun\u00e7\u00e3o pio_pull_up() na fun\u00e7\u00e3o init() Progress Click para continuar....","title":"PULL-UP"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#lendo-o-botao","text":"Para lermos um valor de um pino, que j\u00e1 foi configurado como entrada, devemos utilizar alguma das fun\u00e7\u00f5es fornecidas no ASF de interface com o PIO, procure por ela na documenta\u00e7\u00e3o do PIO. Exercise Qual fun\u00e7\u00e3o pode ser utilizada para ler o valor digital do pino PA11? Consulte as fun\u00e7\u00f5es dispon\u00edveis na documenta\u00e7\u00e3o do ASF PIO Answer A fun\u00e7\u00e3o a ser utilizada \u00e9 a pio_get() Progress Click para continuar....","title":"Lendo o bot\u00e3o"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#implementando-a-logica","text":"Vamos usar o bot\u00e3o para fazer alguma coisa? Agora conseguimos acionar um pino (LED) e ler um pino (bot\u00e3o). Task Faca um c\u00f3digo que o LED pisca 5 vezes na sequ\u00eancia somente quando o bot\u00e3o da placa for pressionado. Lembre de usar a fun\u00e7\u00e3o pio_get() , voc\u00ea vai precisar realizar uma condi\u00e7\u00e3o com o valor que ela retorna. Utilize PIO_INPUT no par\u00e2metro ul_type da fun\u00e7\u00e3o. N\u00e3o funcionou? De uma olhada como eu implementei: https://github.com/Insper/SAME70-examples/blob/96fb17e758e7eef9273ca2ddfb8dcd33ebcb4eb7/Perifericos-uC/PIO-IO/PIO-IO/src/main.c#L66 Progress Click para continuar....","title":"Implementando a l\u00f3gica"},{"location":"navigation/Labs/Lab_PIO/Lab-PIO/#praticando-entrega-obrigatoria","text":"Task Muito bom! Agora vamos pegar a placa OLED1 (que voc\u00ea recebeu no kit) e usar os LEDs e Boto\u1ebds dela? Para isso voc\u00ea vai ter que entender quais pinos configurar como entrada e sa\u00edda. A placa possui tr\u00eas bot\u00f5es e tr\u00eas LEDs que podem ser lidos e controlados pelo microcontrolador. A ideia da atividade \u00e9 que cada bot\u00e3o controle o LED associado a ele (Bot\u00e3o 1 - Led 1/ Bot\u00e3o 2 - Led 2/ ...) fazendo piscar da mesma maneira como feito com o bot\u00e3o da placa (cada botao controla um LED). Para isso, voc\u00eas devem conectar a placa OLED na entrada EXT-1 do seu kit e ent\u00e3o consultar os manuais no link a seguir para saber qual pino devem configurar como sa\u00edda (LEDs) e quais devem configurar como entrada (Bot\u00f5es) Dica: Comece pelos LEDs (fazendo piscar) e depois v\u00e1 implementando os bot\u00f5es um a um. Link para os documentos: https://insper.github.io/ComputacaoEmbarcada/navigation/Util/Util-Documentos/ OLED1 Xplained Pro User Guide: Explica a placa OLED SAME70-XPLD.pdf: Explica a placa de desenvolviment Preencher ao finalizar o lab Carregando\u2026","title":"Praticando (entrega obrigat\u00f3ria)"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Perguntas/","text":"PIO - IRQ - Perguntas Descreva o uso de uma IRQ Qual a diferen\u00e7a entre as exce\u00e7\u00f5es NMI e IRQ ? IRQ vs ISR Qual a diferen\u00e7a entre as exce\u00e7\u00f5es IRQ e ISR ? No ARM que utilizamos no curso, quantas s\u00e3o as interrup\u00e7\u00f5es suportadas e qual a sua menor prioridade ? dica: manual do microcontrolador Quem possui maior prioridade IRQ ou FIQ ? No datasheet, sec\u00e7\u00e3o 13.1 informa o ID do perif\u00e9rico que est\u00e1 associado com a sua interrup\u00e7\u00e3o. Busque a informa\u00e7\u00e3o e liste o ID dos seguintes perif\u00e9ricos : PIOA PIOC TC0 O que acontece se n\u00e3o limparmos a interrup\u00e7\u00e3o (Ack) ? Com base na explica\u00e7\u00e3o do datasheet sobre interrup\u00e7\u00f5es no PIO descreva o uso da interrup\u00e7\u00e3o nesse perif\u00e9rico e de e suas op\u00e7\u00f5es. Descreva as fun\u00e7\u00f5es dos registradores do PIO: PIO_ELSR PIO_FRLHSR Fa\u00e7a um diagrama que sintetize como a interrup\u00e7\u00e3o funciona em um microcontrolador.","title":"PIO - IRQ - Perguntas"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Perguntas/#pio-irq-perguntas","text":"Descreva o uso de uma IRQ Qual a diferen\u00e7a entre as exce\u00e7\u00f5es NMI e IRQ ? IRQ vs ISR Qual a diferen\u00e7a entre as exce\u00e7\u00f5es IRQ e ISR ? No ARM que utilizamos no curso, quantas s\u00e3o as interrup\u00e7\u00f5es suportadas e qual a sua menor prioridade ? dica: manual do microcontrolador Quem possui maior prioridade IRQ ou FIQ ? No datasheet, sec\u00e7\u00e3o 13.1 informa o ID do perif\u00e9rico que est\u00e1 associado com a sua interrup\u00e7\u00e3o. Busque a informa\u00e7\u00e3o e liste o ID dos seguintes perif\u00e9ricos : PIOA PIOC TC0 O que acontece se n\u00e3o limparmos a interrup\u00e7\u00e3o (Ack) ? Com base na explica\u00e7\u00e3o do datasheet sobre interrup\u00e7\u00f5es no PIO descreva o uso da interrup\u00e7\u00e3o nesse perif\u00e9rico e de e suas op\u00e7\u00f5es. Descreva as fun\u00e7\u00f5es dos registradores do PIO: PIO_ELSR PIO_FRLHSR Fa\u00e7a um diagrama que sintetize como a interrup\u00e7\u00e3o funciona em um microcontrolador.","title":"PIO - IRQ - Perguntas"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Teoria/","text":"IRQ - Teoria Em computa\u00e7\u00e3o \u00e9 comum a necessidade de realizar a\u00e7\u00f5es com base em eventos. Eventos podem ser classificados como internos ou externos ao processador/microcontrolador. O t\u00e9rmino de um c\u00e1lculo realizado por um dos n\u00facleos de um processador multicore ou a detec\u00e7\u00e3o de um overflow de mem\u00f3ria s\u00e3o exemplos eventos interno ao CORE (processador). J\u00e1 a notifica\u00e7\u00e3o de um novo pacote oriundo da comunica\u00e7\u00e3o Ethernet \u00e9 um exemplo de um evento externo ao CORE. A estrutura\u00e7\u00e3o de um programa orientada a eventos ^1 d\u00e1 uma s\u00e9rie de vantagens ao programador: independ\u00eancia entre as diferentes partes do programador facilidade de modifica\u00e7\u00e3o e upgrade defini\u00e7\u00e3o de prioridades facilita a correla\u00e7\u00e3o entre o c\u00f3digo e a documenta\u00e7\u00e3o Nesse paradigma de programa\u00e7\u00e3o define-se fun\u00e7\u00f5es para determinados eventos e essas fun\u00e7\u00f5es s\u00e3o executada quando um evento \u00e9 detectado. As fun\u00e7\u00f5es/eventos podem possuir diferentes n\u00edveis de prioridades, o que possibilita ao programador definir o que deve ser executado caso dois eventos ocorram simultaneamente. Por exemplo, podemos definir uma fun\u00e7\u00e3o que \u00e9 acionada toda vez que chega um dado pela porta Ethernet, e outra fun\u00e7\u00e3o que \u00e9 executada toda vez que um bot\u00e3o for pressionado, podemos tamb\u00e9m definir eventos peri\u00f3dicos, tais como: execute uma fun\u00e7\u00e3o a cada X segundos (piscar LED!). Embarcado Em computadores os eventos s\u00e3o em geral tratados pelo sistema operacional (OS) (linux/ windows, /....) por\u00e9m em sistemas embarcados nem sempre possu\u00edmos um sistema operacional ou n\u00e3o podemos tolerar a lat\u00eancia entre a troca de contexto do OS (nada \u00e9 de gra\u00e7a!). Existe para isso as interrup\u00e7\u00f5es de hardware, que s\u00e3o chamadas de fun\u00e7\u00f5es (eventos) realizados pelo uC para eventos detectados pelos perif\u00e9ricos (no computador tamb\u00e9m tem, mas o OS toma conta de tudo). Podemos por exemplo configurar o uC para que toda vez que um bot\u00e3o for pressionado (no nosso caso, mudan\u00e7a de HIGI par LOW) uma fun\u00e7\u00e3o ( handler ) seja executada. Evitando a necessidade de verificarmos pela mudan\u00e7a de estado do pino no while(1) (t\u00e9cnica conhecida como polling). Isso abre portas para uma s\u00e9rie de otimiza\u00e7\u00f5es sendo uma da principal a quest\u00e3o energ\u00e9tica. O estilo de programa\u00e7\u00e3o que fica checando por uma mudan\u00e7a \u00e9 chamado de polling , o mesmo utilizado nos lab realizados at\u00e9 agora: while ( 1 ){ /** * @Brief Verifica constantemente o status do botao * 1 : nao apertado * 0 : apertado */ if ( BUT_PIO -> PIO_PDSR & ( BUT_PIN_MASK )) { LED_PIO -> PIO_CODR = LED_PIN_MASK ; } else { LED_PIO -> PIO_SODR = LED_PIN_MASK ; } }; Nesse exemplo de c\u00f3digo fica-se constantemente checando por altera\u00e7\u00f5es no registrador do PIO respons\u00e1vel pelo bot\u00e3o a fim de decidirmos se o LED ficar\u00e1 acesso ou apagado. O CORE est\u00e1 constantemente trabalhando a fim de executar essas opera\u00e7\u00f5es, o que ele faz constantemente \u00e9: busca o valor do registrador PIO_PDSR aplica a m\u00e1scara ao valor checa se o resultado da m\u00e1scara \u00e9 verdadeiro ou falso executa uma das duas a\u00e7\u00f5es diferentes O CORE Cortex M7 com ponto flutuante operando a 300MHz fica realizado uma simples a\u00e7\u00e3o de comparar o valor de um registrador com uma m\u00e1scara para detectarmos uma mudan\u00e7a no bot\u00e3o. E se, o c\u00f3digo fosse alertado dessa altera\u00e7\u00e3o e uma fun\u00e7\u00e3o espec\u00edfica chamada para tratar essa mudan\u00e7a? O CORE poderia estar em um modo de baixo consumo energ\u00e9tico (sleep mode) e configurado para acordar dado um determinado evento (ex:mudan\u00e7a de estado do bot\u00e3o). Deve-se ponderar a utiliza\u00e7\u00e3o do modo de baixo consumo energ\u00e9tico j\u00e1 que esse tipo de a\u00e7\u00e3o (sleep mode -> wakeup) implica em um atraso entre o evento e a retomada plena do CORE e in\u00edcio da execu\u00e7\u00e3o do c\u00f3digo. Esse atraso que pode variar entre microcontroladores (no caso do SAME70 entre 10us e 2ms dependendo do modo de powerdown) pode ser cr\u00edtico para sistemas que devem agir de forma \u00e1gil a uma determinada a\u00e7\u00e3o. O trecho de c\u00f3digo a seguir ilustra a poss\u00edvel solu\u00e7\u00e3o utilizando interrup\u00e7\u00e3o para executar uma a\u00e7\u00e3o quando o bot\u00e3o \u00e9 alterado. No while(1) o processador entra em modo sleep (fun\u00e7\u00e3o blocante) e s\u00f3 \u00e9 \"acordado\" dado uma mudan\u00e7a no valor digital do pino que o bot\u00e3o est\u00e1 conectado. /** * Funcao responsavel por tratar a mudanca de * estado do botao. * E' chamada sempre que houver uma transicao * de High -> Low (falling_egde). */ void but_Handler ( void ){ if ( BUT_PIO -> PIO_PDSR & ( BUT_PIN_MASK )){ LED_PIO -> PIO_CODR = LED_PIN_MASK ; } else { LED_PIO -> PIO_SODR = LED_PIN_MASK ; } } void main (){ /* inicializacoes */ ... /** * Superloop em modo sleep */ while ( 1 ){ pmc_sleep ( SLEEPMGR_SLEEP_WFI ); }; } Exce\u00e7\u00f5es Exce\u00e7\u00f5es ^2 s\u00e3o eventos que causam uma mudan\u00e7a no fluxo de execu\u00e7\u00e3o do programa, quando ocorridas levam a unidade de processamento a executar uma parte espec\u00edfica do c\u00f3digo chamada de: exception handler . Depois do t\u00e9rmino da execu\u00e7\u00e3o da exce\u00e7\u00e3o o programa principal volta a ser executado normalmente. O hardware respons\u00e1vel por gerenciar as exce\u00e7\u00f5es no ARM \u00e9 chamado de Nested vectored interrupt controller (NVIC) . O NVIC pode suportar de 1 \u00e0 240 diferentes exce\u00e7\u00f5es, sendo elas classificadas basicamente em quatro grupos: System Exceptions Fault Detection Non-Maskable Interrupt (NMI) Interrupt Requests (IRQ) Exce\u00e7\u00f5es numeradas de -15 at\u00e9 -1 s\u00e3o consideradas exce\u00e7\u00f5es do sistema (reset, overflow, bus fault, ...), exce\u00e7\u00f5es de n\u00famero superior a 15 s\u00e3o consideradas interrup\u00e7\u00f5es. No CortexM n\u00e3o existe exce\u00e7\u00e3o 0 (quem executa nesse n\u00edvel \u00e9 o main ) Exemplos O PIO pode gerar uma interrup\u00e7\u00e3o quando acontecer uma mudan\u00e7a de n\u00edvel em uma entrada; O perif\u00e9rico do USB pode gerar uma interrup\u00e7\u00e3o quando um dado novo chegar; ou quando a transmiss\u00e3o de um dado finalizar; O timer pode gerar uma interrup\u00e7\u00e3o quando atingido um determinado valor; Interrup\u00e7\u00e3o No ARM interrup\u00e7\u00f5es s\u00e3o um tipo de exce\u00e7\u00e3o, normalmente geradas pelos perif\u00e9ricos do microcontrolador. Quando um perif\u00e9rico imp\u00f5em um sinal de interrup\u00e7\u00e3o ao NVIC, o seguinte acontece: uma interrup\u00e7\u00e3o \u00e9 acionada (IRQ); O processador suspende a execu\u00e7\u00e3o do c\u00f3digo; O processador executa o servi\u00e7o de rotina da interrup\u00e7\u00e3o ( Interrupt Service Routine - ISR ); O processador retoma a execu\u00e7\u00e3o do c\u00f3digo para o estado anterior da interrup\u00e7\u00e3o acontecer. Devemos notar que o processador deve salvar os contextos (registradores do core) na primeira passagem (1 -> 2) e ap\u00f3s executar o ISR, recarregar os valores na passagem (2 -> 3). Prioridades No ARM, podemos classificar as interrup\u00e7\u00f5es por prioridade sendo a de n\u00famero menor considerada de MAIOR prioridade e de n\u00famero maior de MENOR prioridade. O ARM permite que tenhamos uma gama de 256 n\u00edveis de prioridades distintas por\u00e9m fica a cargo do fabricante decidir a quantidade de n\u00edveis. Quando duas interrup\u00e7\u00f5es acontecem (n\u00e3o necessariamente simultaneamente) o NVIC verificar\u00e1 qual \u00e9 a de maior prioridade e a executar\u00e1 primeiro, ap\u00f3s sua execu\u00e7\u00e3o \u00e9 chamada o ISR da interrup\u00e7\u00e3o de menor prioridade. A figura a seguir ilustra o que acontece quando uma interrup\u00e7\u00e3o \u00e9 ativada quando um sistema operacional est\u00e1 em uso, nesse caso existem dois tipos distintos de interrup\u00e7\u00e3o : IRQ e FIQ ( Fast Interruption Routine ). Interrupt Requests - IRQ As interrup\u00e7\u00f5es do tipo IRQs, geradas pelos perif\u00e9ricos s\u00e3o \"mascaradas\", ou seja, devemos ativar em em um registrador (de configura\u00e7\u00e3o do CORE) quais ser\u00e3o as interrup\u00e7\u00f5es que estar\u00e3o ativas. Al\u00e9m de ativarmos a interrup\u00e7\u00e3o do perif\u00e9rico espec\u00edfico, precisamos definir sua prioridade. Na inicializa\u00e7\u00e3o do uC o ARM configura todas as prioridades para o n\u00edvel 0 (mais alto). Esse controle \u00e9 realizado via acesso aos registradores especiais do NVIC, especificamente o IRQ. Sinais de interrup\u00e7\u00e3o vindo dos perif\u00e9ricos Os perif\u00e9ricos geram um sinal de interrup\u00e7\u00e3o para o NVIC, esse sinal fica ativo at\u00e9 ser limpo manualmente pelo CORE e \u00e9 utilizado pelo NVIC a fim de gerar a interrpu\u00e7\u00e3o no CORE. \u00c9 de responsabilidade do programador (c\u00f3digo) em dizer ao perif\u00e9rico que a interrup\u00e7\u00e3o foi resolvida, isso \u00e9 feito acessando um registrador espec\u00edfico do perif\u00e9rico. O NVIC trata as interrup\u00e7\u00f5es de maior prioridade antes das de menor prioridade, nesse meio termo os perif\u00e9ricos de menor prioridade devem manter sua requisi\u00e7\u00e3o de interrup\u00e7\u00e3o ao NVIC. Os perif\u00e9ricos n\u00e3o possuem uma maneira direta de saber que a interrup\u00e7\u00e3o j\u00e1 foi tratada, por isso mant\u00e9m em alto a requisi\u00e7\u00e3o at\u00e9 receberem um mensagem dizendo que podem baixar o sinal da interrup\u00e7\u00e3o. Isso \u00e9 feito via acesso do CORE a um registrador do perif\u00e9rico, todos os perif\u00e9ricos que geram interrup\u00e7\u00f5es possuem um registrador espec\u00edfico para isso. Podemos tomar por exemplo o PIO: 31.5.10 Input Edge/Level Interrupt When the software reads PIO_ISR, all the interrupts are automatically cleared. This signifies that all the interrupts that are pending when PIO_ISR is read must be handled. When an Interrupt is enabled on a \"level\", the interrupt is generated as long as the interrupt source is not cleared, even if some read accesses in PIO_ISR are performed. Interrupt Service Routine - ISR Ap\u00f3s uma interrup\u00e7\u00e3o ser detectada pelo NVIC, o CORE salva os contextos e aponta a execu\u00e7\u00e3o do c\u00f3digo para uma regi\u00e3o espec\u00edfica. Uma fun\u00e7\u00e3o especial para cada perif\u00e9rico chamada de Handler \u00e9 utilizado a fim de tratar as interrup\u00e7\u00f5es em n\u00edvel de software. Uma interrup\u00e7\u00e3o no uC pode estar nos seguintes estados : Cada interrup\u00e7\u00e3o pode estar desativada (padr\u00e3o) ou ativada; Cada interrup\u00e7\u00e3o pode estar pendente (esperando para ser executada) ou n\u00e3o pendente; Cada interrup\u00e7\u00e3o pode estar ativada (em execu\u00e7\u00e3o) ou inativada. Podemos fazer diferentes combina\u00e7\u00f5es dos atributos listados anteriormente, por exemplo, enquanto estivermos lidando com uma interrup\u00e7\u00e3o (ativada) podemos desativar l\u00e1 para que a mesma interrup\u00e7\u00e3o n\u00e3o seja chamada novamente quando a interrup\u00e7\u00e3o acabar de ser executada. Para uma interrup\u00e7\u00e3o ser aceita, devemos ter o seguinte cen\u00e1rio : A interrup\u00e7\u00e3o est\u00e1 em pend\u00eancia, A interrup\u00e7\u00e3o est\u00e1 ativada, e, A prioridade da interrup\u00e7\u00e3o \u00e9 maior (menor valor) do que o n\u00edvel atual. Software - CMSIS Utilizaremos as fun\u00e7\u00f5es definidas no Cortex Microcontroller Software Interface Standard (CMSIS) ^3 para configurar o NVIC e o CORE, essas fun\u00e7\u00f5es s\u00e3o de uso geral do ARM Cortex e s\u00e3o independentes do fabricante (Atmel, Texas, ...). As fun\u00e7\u00f5es utilizadas ser\u00e3o : //Set the priority grouping void NVIC_SetPriorityGrouping ( uint32_t priority_grouping ) //Enable IRQn void NVIC_EnableIRQ ( IRQn_t IRQn ) // Disable IRQn void NVIC_DisableIRQ ( IRQn_t IRQn ) // Set priority for IRQn void NVIC_SetPriority ( IRQn_t IRQn , uint32_t priority ) Essas fun\u00e7\u00f5es apenas configura o NVIC + CORE, devemos tamb\u00e9m configurar o perif\u00e9rico que ser\u00e1 respons\u00e1vel por gerar a interrup\u00e7\u00e3o. O par\u00e2metro IRQn das fun\u00e7\u00f5es de configura\u00e7\u00e3o do NVIC \u00e9 o ID do perif\u00e9rico em quest\u00e3o (o mesmo utilizado no PMC). PIO - Interrup\u00e7\u00e3o A interrup\u00e7\u00e3o no PIO \u00e9 gerenciada por meio de registradores e pode ser configurada para detectar: Rising edge detection Falling edge detection Low-level detection High-level detection Uma vis\u00e3o geral do hardware respons\u00e1vel por gerenciar as interrup\u00e7\u00f5es \u00e9 demonstrado a seguir: O texto a seguir foi extra\u00eddo do datasheet do SAME70 e descreve a opera\u00e7\u00e3o dessa parte do PIO: 31.5.10 Input Edge/Level Interrupt ... is controlled by writing the Interrupt Enable Register () and the Interrupt Disable Register (), which enable and disable the input change interrupt respectively by setting and clearing the corresponding bit in the Interrupt Mask Register (PIO_IMR). , the peripheral clock must be enabled. The Input Change interrupt is available regardless of the configuration of the I/O line, i.e., configured as an input only, controlled by the PIO Controller or assigned to a peripheral function. By default, the interrupt can be generated at any time an edge is detected on the input. and Additional Interrupt Modes Disable Register (PIO_AIMDR). The current state of this selection can be read through the Additional Interrupt Modes Mask Register (PIO_AIMMR). These additional modes are: - Rising edge detection - Falling edge detection - Low-level detection High-level detection In order to select an additional interrupt mode: must be selected by writing in the Edge Select Register () and Level Select Register () which select, respectively, the edge and level detection. The current status of this selection is accessible through the Edge/Level Status Register (PIO_ELSR). must be selected by in the Falling Edge/Low-Level Select Register () and Rising Edge/High-Level Select Register () which allow to select falling or rising edge (if edge is selected in PIO_ELSR) edge or high- or low-level detection (if level is selected in PIO_ELSR). The current status of this selection is accessible through the Fall/Rise - Low/High Status Register (PIO_FRLHSR). , the corresponding in the Interrupt Status Register () is . If the corresponding bit in , the PIO Controller interrupt line is asserted. . This signifies that all the interrupts that are pending when PIO_ISR is read must be handled. When an Interrupt is enabled on a \"level\", the interrupt is generated as long as the interrupt source is not cleared, even if some read accesses in PIO_ISR are performed. Refer\u00eancias [1] https://en.wikipedia.org/wiki/Event-driven_programming [2] https://www.ece.umd.edu/class/enee447.S2016/ARM-Documentation/ARM-Interrupts-1.pdf [3] http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php","title":"Teoria"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Teoria/#irq-teoria","text":"Em computa\u00e7\u00e3o \u00e9 comum a necessidade de realizar a\u00e7\u00f5es com base em eventos. Eventos podem ser classificados como internos ou externos ao processador/microcontrolador. O t\u00e9rmino de um c\u00e1lculo realizado por um dos n\u00facleos de um processador multicore ou a detec\u00e7\u00e3o de um overflow de mem\u00f3ria s\u00e3o exemplos eventos interno ao CORE (processador). J\u00e1 a notifica\u00e7\u00e3o de um novo pacote oriundo da comunica\u00e7\u00e3o Ethernet \u00e9 um exemplo de um evento externo ao CORE. A estrutura\u00e7\u00e3o de um programa orientada a eventos ^1 d\u00e1 uma s\u00e9rie de vantagens ao programador: independ\u00eancia entre as diferentes partes do programador facilidade de modifica\u00e7\u00e3o e upgrade defini\u00e7\u00e3o de prioridades facilita a correla\u00e7\u00e3o entre o c\u00f3digo e a documenta\u00e7\u00e3o Nesse paradigma de programa\u00e7\u00e3o define-se fun\u00e7\u00f5es para determinados eventos e essas fun\u00e7\u00f5es s\u00e3o executada quando um evento \u00e9 detectado. As fun\u00e7\u00f5es/eventos podem possuir diferentes n\u00edveis de prioridades, o que possibilita ao programador definir o que deve ser executado caso dois eventos ocorram simultaneamente. Por exemplo, podemos definir uma fun\u00e7\u00e3o que \u00e9 acionada toda vez que chega um dado pela porta Ethernet, e outra fun\u00e7\u00e3o que \u00e9 executada toda vez que um bot\u00e3o for pressionado, podemos tamb\u00e9m definir eventos peri\u00f3dicos, tais como: execute uma fun\u00e7\u00e3o a cada X segundos (piscar LED!).","title":"IRQ - Teoria"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Teoria/#embarcado","text":"Em computadores os eventos s\u00e3o em geral tratados pelo sistema operacional (OS) (linux/ windows, /....) por\u00e9m em sistemas embarcados nem sempre possu\u00edmos um sistema operacional ou n\u00e3o podemos tolerar a lat\u00eancia entre a troca de contexto do OS (nada \u00e9 de gra\u00e7a!). Existe para isso as interrup\u00e7\u00f5es de hardware, que s\u00e3o chamadas de fun\u00e7\u00f5es (eventos) realizados pelo uC para eventos detectados pelos perif\u00e9ricos (no computador tamb\u00e9m tem, mas o OS toma conta de tudo). Podemos por exemplo configurar o uC para que toda vez que um bot\u00e3o for pressionado (no nosso caso, mudan\u00e7a de HIGI par LOW) uma fun\u00e7\u00e3o ( handler ) seja executada. Evitando a necessidade de verificarmos pela mudan\u00e7a de estado do pino no while(1) (t\u00e9cnica conhecida como polling). Isso abre portas para uma s\u00e9rie de otimiza\u00e7\u00f5es sendo uma da principal a quest\u00e3o energ\u00e9tica. O estilo de programa\u00e7\u00e3o que fica checando por uma mudan\u00e7a \u00e9 chamado de polling , o mesmo utilizado nos lab realizados at\u00e9 agora: while ( 1 ){ /** * @Brief Verifica constantemente o status do botao * 1 : nao apertado * 0 : apertado */ if ( BUT_PIO -> PIO_PDSR & ( BUT_PIN_MASK )) { LED_PIO -> PIO_CODR = LED_PIN_MASK ; } else { LED_PIO -> PIO_SODR = LED_PIN_MASK ; } }; Nesse exemplo de c\u00f3digo fica-se constantemente checando por altera\u00e7\u00f5es no registrador do PIO respons\u00e1vel pelo bot\u00e3o a fim de decidirmos se o LED ficar\u00e1 acesso ou apagado. O CORE est\u00e1 constantemente trabalhando a fim de executar essas opera\u00e7\u00f5es, o que ele faz constantemente \u00e9: busca o valor do registrador PIO_PDSR aplica a m\u00e1scara ao valor checa se o resultado da m\u00e1scara \u00e9 verdadeiro ou falso executa uma das duas a\u00e7\u00f5es diferentes O CORE Cortex M7 com ponto flutuante operando a 300MHz fica realizado uma simples a\u00e7\u00e3o de comparar o valor de um registrador com uma m\u00e1scara para detectarmos uma mudan\u00e7a no bot\u00e3o. E se, o c\u00f3digo fosse alertado dessa altera\u00e7\u00e3o e uma fun\u00e7\u00e3o espec\u00edfica chamada para tratar essa mudan\u00e7a? O CORE poderia estar em um modo de baixo consumo energ\u00e9tico (sleep mode) e configurado para acordar dado um determinado evento (ex:mudan\u00e7a de estado do bot\u00e3o). Deve-se ponderar a utiliza\u00e7\u00e3o do modo de baixo consumo energ\u00e9tico j\u00e1 que esse tipo de a\u00e7\u00e3o (sleep mode -> wakeup) implica em um atraso entre o evento e a retomada plena do CORE e in\u00edcio da execu\u00e7\u00e3o do c\u00f3digo. Esse atraso que pode variar entre microcontroladores (no caso do SAME70 entre 10us e 2ms dependendo do modo de powerdown) pode ser cr\u00edtico para sistemas que devem agir de forma \u00e1gil a uma determinada a\u00e7\u00e3o. O trecho de c\u00f3digo a seguir ilustra a poss\u00edvel solu\u00e7\u00e3o utilizando interrup\u00e7\u00e3o para executar uma a\u00e7\u00e3o quando o bot\u00e3o \u00e9 alterado. No while(1) o processador entra em modo sleep (fun\u00e7\u00e3o blocante) e s\u00f3 \u00e9 \"acordado\" dado uma mudan\u00e7a no valor digital do pino que o bot\u00e3o est\u00e1 conectado. /** * Funcao responsavel por tratar a mudanca de * estado do botao. * E' chamada sempre que houver uma transicao * de High -> Low (falling_egde). */ void but_Handler ( void ){ if ( BUT_PIO -> PIO_PDSR & ( BUT_PIN_MASK )){ LED_PIO -> PIO_CODR = LED_PIN_MASK ; } else { LED_PIO -> PIO_SODR = LED_PIN_MASK ; } } void main (){ /* inicializacoes */ ... /** * Superloop em modo sleep */ while ( 1 ){ pmc_sleep ( SLEEPMGR_SLEEP_WFI ); }; }","title":"Embarcado"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Teoria/#excecoes","text":"Exce\u00e7\u00f5es ^2 s\u00e3o eventos que causam uma mudan\u00e7a no fluxo de execu\u00e7\u00e3o do programa, quando ocorridas levam a unidade de processamento a executar uma parte espec\u00edfica do c\u00f3digo chamada de: exception handler . Depois do t\u00e9rmino da execu\u00e7\u00e3o da exce\u00e7\u00e3o o programa principal volta a ser executado normalmente. O hardware respons\u00e1vel por gerenciar as exce\u00e7\u00f5es no ARM \u00e9 chamado de Nested vectored interrupt controller (NVIC) . O NVIC pode suportar de 1 \u00e0 240 diferentes exce\u00e7\u00f5es, sendo elas classificadas basicamente em quatro grupos: System Exceptions Fault Detection Non-Maskable Interrupt (NMI) Interrupt Requests (IRQ) Exce\u00e7\u00f5es numeradas de -15 at\u00e9 -1 s\u00e3o consideradas exce\u00e7\u00f5es do sistema (reset, overflow, bus fault, ...), exce\u00e7\u00f5es de n\u00famero superior a 15 s\u00e3o consideradas interrup\u00e7\u00f5es. No CortexM n\u00e3o existe exce\u00e7\u00e3o 0 (quem executa nesse n\u00edvel \u00e9 o main )","title":"Exce\u00e7\u00f5es"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Teoria/#exemplos","text":"O PIO pode gerar uma interrup\u00e7\u00e3o quando acontecer uma mudan\u00e7a de n\u00edvel em uma entrada; O perif\u00e9rico do USB pode gerar uma interrup\u00e7\u00e3o quando um dado novo chegar; ou quando a transmiss\u00e3o de um dado finalizar; O timer pode gerar uma interrup\u00e7\u00e3o quando atingido um determinado valor;","title":"Exemplos"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Teoria/#interrupcao","text":"No ARM interrup\u00e7\u00f5es s\u00e3o um tipo de exce\u00e7\u00e3o, normalmente geradas pelos perif\u00e9ricos do microcontrolador. Quando um perif\u00e9rico imp\u00f5em um sinal de interrup\u00e7\u00e3o ao NVIC, o seguinte acontece: uma interrup\u00e7\u00e3o \u00e9 acionada (IRQ); O processador suspende a execu\u00e7\u00e3o do c\u00f3digo; O processador executa o servi\u00e7o de rotina da interrup\u00e7\u00e3o ( Interrupt Service Routine - ISR ); O processador retoma a execu\u00e7\u00e3o do c\u00f3digo para o estado anterior da interrup\u00e7\u00e3o acontecer. Devemos notar que o processador deve salvar os contextos (registradores do core) na primeira passagem (1 -> 2) e ap\u00f3s executar o ISR, recarregar os valores na passagem (2 -> 3).","title":"Interrup\u00e7\u00e3o"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Teoria/#prioridades","text":"No ARM, podemos classificar as interrup\u00e7\u00f5es por prioridade sendo a de n\u00famero menor considerada de MAIOR prioridade e de n\u00famero maior de MENOR prioridade. O ARM permite que tenhamos uma gama de 256 n\u00edveis de prioridades distintas por\u00e9m fica a cargo do fabricante decidir a quantidade de n\u00edveis. Quando duas interrup\u00e7\u00f5es acontecem (n\u00e3o necessariamente simultaneamente) o NVIC verificar\u00e1 qual \u00e9 a de maior prioridade e a executar\u00e1 primeiro, ap\u00f3s sua execu\u00e7\u00e3o \u00e9 chamada o ISR da interrup\u00e7\u00e3o de menor prioridade. A figura a seguir ilustra o que acontece quando uma interrup\u00e7\u00e3o \u00e9 ativada quando um sistema operacional est\u00e1 em uso, nesse caso existem dois tipos distintos de interrup\u00e7\u00e3o : IRQ e FIQ ( Fast Interruption Routine ).","title":"Prioridades"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Teoria/#interrupt-requests-irq","text":"As interrup\u00e7\u00f5es do tipo IRQs, geradas pelos perif\u00e9ricos s\u00e3o \"mascaradas\", ou seja, devemos ativar em em um registrador (de configura\u00e7\u00e3o do CORE) quais ser\u00e3o as interrup\u00e7\u00f5es que estar\u00e3o ativas. Al\u00e9m de ativarmos a interrup\u00e7\u00e3o do perif\u00e9rico espec\u00edfico, precisamos definir sua prioridade. Na inicializa\u00e7\u00e3o do uC o ARM configura todas as prioridades para o n\u00edvel 0 (mais alto). Esse controle \u00e9 realizado via acesso aos registradores especiais do NVIC, especificamente o IRQ.","title":"Interrupt Requests - IRQ"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Teoria/#sinais-de-interrupcao-vindo-dos-perifericos","text":"Os perif\u00e9ricos geram um sinal de interrup\u00e7\u00e3o para o NVIC, esse sinal fica ativo at\u00e9 ser limpo manualmente pelo CORE e \u00e9 utilizado pelo NVIC a fim de gerar a interrpu\u00e7\u00e3o no CORE. \u00c9 de responsabilidade do programador (c\u00f3digo) em dizer ao perif\u00e9rico que a interrup\u00e7\u00e3o foi resolvida, isso \u00e9 feito acessando um registrador espec\u00edfico do perif\u00e9rico. O NVIC trata as interrup\u00e7\u00f5es de maior prioridade antes das de menor prioridade, nesse meio termo os perif\u00e9ricos de menor prioridade devem manter sua requisi\u00e7\u00e3o de interrup\u00e7\u00e3o ao NVIC. Os perif\u00e9ricos n\u00e3o possuem uma maneira direta de saber que a interrup\u00e7\u00e3o j\u00e1 foi tratada, por isso mant\u00e9m em alto a requisi\u00e7\u00e3o at\u00e9 receberem um mensagem dizendo que podem baixar o sinal da interrup\u00e7\u00e3o. Isso \u00e9 feito via acesso do CORE a um registrador do perif\u00e9rico, todos os perif\u00e9ricos que geram interrup\u00e7\u00f5es possuem um registrador espec\u00edfico para isso. Podemos tomar por exemplo o PIO: 31.5.10 Input Edge/Level Interrupt When the software reads PIO_ISR, all the interrupts are automatically cleared. This signifies that all the interrupts that are pending when PIO_ISR is read must be handled. When an Interrupt is enabled on a \"level\", the interrupt is generated as long as the interrupt source is not cleared, even if some read accesses in PIO_ISR are performed.","title":"Sinais de interrup\u00e7\u00e3o vindo dos perif\u00e9ricos"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Teoria/#interrupt-service-routine-isr","text":"Ap\u00f3s uma interrup\u00e7\u00e3o ser detectada pelo NVIC, o CORE salva os contextos e aponta a execu\u00e7\u00e3o do c\u00f3digo para uma regi\u00e3o espec\u00edfica. Uma fun\u00e7\u00e3o especial para cada perif\u00e9rico chamada de Handler \u00e9 utilizado a fim de tratar as interrup\u00e7\u00f5es em n\u00edvel de software. Uma interrup\u00e7\u00e3o no uC pode estar nos seguintes estados : Cada interrup\u00e7\u00e3o pode estar desativada (padr\u00e3o) ou ativada; Cada interrup\u00e7\u00e3o pode estar pendente (esperando para ser executada) ou n\u00e3o pendente; Cada interrup\u00e7\u00e3o pode estar ativada (em execu\u00e7\u00e3o) ou inativada. Podemos fazer diferentes combina\u00e7\u00f5es dos atributos listados anteriormente, por exemplo, enquanto estivermos lidando com uma interrup\u00e7\u00e3o (ativada) podemos desativar l\u00e1 para que a mesma interrup\u00e7\u00e3o n\u00e3o seja chamada novamente quando a interrup\u00e7\u00e3o acabar de ser executada. Para uma interrup\u00e7\u00e3o ser aceita, devemos ter o seguinte cen\u00e1rio : A interrup\u00e7\u00e3o est\u00e1 em pend\u00eancia, A interrup\u00e7\u00e3o est\u00e1 ativada, e, A prioridade da interrup\u00e7\u00e3o \u00e9 maior (menor valor) do que o n\u00edvel atual.","title":"Interrupt Service Routine - ISR"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Teoria/#software-cmsis","text":"Utilizaremos as fun\u00e7\u00f5es definidas no Cortex Microcontroller Software Interface Standard (CMSIS) ^3 para configurar o NVIC e o CORE, essas fun\u00e7\u00f5es s\u00e3o de uso geral do ARM Cortex e s\u00e3o independentes do fabricante (Atmel, Texas, ...). As fun\u00e7\u00f5es utilizadas ser\u00e3o : //Set the priority grouping void NVIC_SetPriorityGrouping ( uint32_t priority_grouping ) //Enable IRQn void NVIC_EnableIRQ ( IRQn_t IRQn ) // Disable IRQn void NVIC_DisableIRQ ( IRQn_t IRQn ) // Set priority for IRQn void NVIC_SetPriority ( IRQn_t IRQn , uint32_t priority ) Essas fun\u00e7\u00f5es apenas configura o NVIC + CORE, devemos tamb\u00e9m configurar o perif\u00e9rico que ser\u00e1 respons\u00e1vel por gerar a interrup\u00e7\u00e3o. O par\u00e2metro IRQn das fun\u00e7\u00f5es de configura\u00e7\u00e3o do NVIC \u00e9 o ID do perif\u00e9rico em quest\u00e3o (o mesmo utilizado no PMC).","title":"Software - CMSIS"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Teoria/#pio-interrupcao","text":"A interrup\u00e7\u00e3o no PIO \u00e9 gerenciada por meio de registradores e pode ser configurada para detectar: Rising edge detection Falling edge detection Low-level detection High-level detection Uma vis\u00e3o geral do hardware respons\u00e1vel por gerenciar as interrup\u00e7\u00f5es \u00e9 demonstrado a seguir: O texto a seguir foi extra\u00eddo do datasheet do SAME70 e descreve a opera\u00e7\u00e3o dessa parte do PIO: 31.5.10 Input Edge/Level Interrupt ... is controlled by writing the Interrupt Enable Register () and the Interrupt Disable Register (), which enable and disable the input change interrupt respectively by setting and clearing the corresponding bit in the Interrupt Mask Register (PIO_IMR). , the peripheral clock must be enabled. The Input Change interrupt is available regardless of the configuration of the I/O line, i.e., configured as an input only, controlled by the PIO Controller or assigned to a peripheral function. By default, the interrupt can be generated at any time an edge is detected on the input. and Additional Interrupt Modes Disable Register (PIO_AIMDR). The current state of this selection can be read through the Additional Interrupt Modes Mask Register (PIO_AIMMR). These additional modes are: - Rising edge detection - Falling edge detection - Low-level detection High-level detection In order to select an additional interrupt mode: must be selected by writing in the Edge Select Register () and Level Select Register () which select, respectively, the edge and level detection. The current status of this selection is accessible through the Edge/Level Status Register (PIO_ELSR). must be selected by in the Falling Edge/Low-Level Select Register () and Rising Edge/High-Level Select Register () which allow to select falling or rising edge (if edge is selected in PIO_ELSR) edge or high- or low-level detection (if level is selected in PIO_ELSR). The current status of this selection is accessible through the Fall/Rise - Low/High Status Register (PIO_FRLHSR). , the corresponding in the Interrupt Status Register () is . If the corresponding bit in , the PIO Controller interrupt line is asserted. . This signifies that all the interrupts that are pending when PIO_ISR is read must be handled. When an Interrupt is enabled on a \"level\", the interrupt is generated as long as the interrupt source is not cleared, even if some read accesses in PIO_ISR are performed.","title":"PIO - Interrup\u00e7\u00e3o"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-Teoria/#referencias","text":"[1] https://en.wikipedia.org/wiki/Event-driven_programming [2] https://www.ece.umd.edu/class/enee447.S2016/ARM-Documentation/ARM-Interrupts-1.pdf [3] http://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php","title":"Refer\u00eancias"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-pratica/","text":"Praticando - OLED Entrega Pasta: /Led3-OLED-PIO-IRQ Data LIMITE para entrega: 04/09/22 - 23h59 Agora vamos praticar um pouco o uso de interrup\u00e7\u00e3o, para isso voc\u00eas dever\u00e3o abrir/ criar um novo projeto. Copie o projeto localizado no reposit\u00f3rio de exemplos: SAME70-examples/Screens/OLED-Xplained-Pro-SPI/ para a pasta do seu reposit\u00f3rio de laborat\u00f3rios da disciplina Lab3-OLED-PIO-IRQ . Iremos trabalhar com esse exemplo que configura o OLED (que deve ser conectado na placa no EXT1 ) e incorporar o exemplo da interrup\u00e7\u00e3o aqui (vamos ampliar sua funcionalidade!). A entrega final (conceito A) deve possuir tr\u00eas bot\u00f5es externos a placa que ir\u00e3o configurar a frequ\u00eancia na qual o LED ir\u00e1 piscar (via interrup\u00e7\u00e3o \u00e9 claro). Um dos bot\u00f5es ir\u00e1 aumentar/diminuir a frequ\u00eancia do piscar do LED, depdendendo do modo de pressionamento (curto/longo), um outro ir\u00e1 parar a piscada do LED e o \u00faltimo ter\u00e1 apenas a fun\u00e7\u00e3o de diminuir (modo pressionamento curto). O OLED dever\u00e1 exibir a frequ\u00eancia atual do LED \"graficamente\". O c\u00f3digo deve funcionar por interrup\u00e7\u00e3o nos bot\u00f5es e sempre que poss\u00edvel, entrar em sleep mode . Conceito C Agora voc\u00ea deve adicionar o bot\u00e3o 1 da placa OLED para alterar a frequ\u00eancia na qual o LED ir\u00e1 piscar. Al\u00e9m disso, voc\u00ea precisa exibir o valor da frequ\u00eancia no display do OLED. Tip Utilize a fun\u00e7\u00e3o pisca_led para controlar a piscada, deixe como padr\u00e3o o n\u00famero de piscada em 30 vezes. 1 - Bot\u00e3o OLED1: Modifica a frequ\u00eancia do LED (por IRQ) - Se usu\u00e1rio aperta e solta: Aumenta a freq em uma unidade ( delay -= 100 ) - Se usu\u00e1rio aperta e segura: Diminui a freq em uma unidade ( delay += 100 ) Tip Para testar a l\u00f3gica, voc\u00ea pode primeiramente utilizar 2 bot\u00f5es, um para aumentar e outro para diminuir, e posteriormente migrar para utilizar apenas 1 bot\u00e3o para as duas fun\u00e7\u00f5es. 2 - Exibir o valor da frequ\u00eancia no OLED Tip Para escrevermos uma string no OLED devemos usar a fun\u00e7\u00e3o: void gfx_mono_draw_string ( const char * str , const gfx_coord_t x , const gfx_coord_t y , const struct font * font ); Que recebe como par\u00e2metro: cont char str : String com o texto a ser escrito no OLED gfx_coord_t x : Coordenada pixel X de onde a string ir\u00e1 ser escrita gfx_coord_t y : Coordenada pixel Y de onde a string ir\u00e1 ser escrita const struct font *font : Fonte a ser utilizada, a configura\u00e7\u00e3o dela est\u00e1 em src/config/conf_sysfont.h Notem que a fun\u00e7\u00e3o recebe uma string e n\u00e3o um inteiro, ent\u00e3o voc\u00eas N\u00c3O PODEM fazer isso: // ------------------ // - ATENC\u00c3O ERRADO - // ------------------ int cnt = 5 ; gfx_mono_draw_string ( cnt , 0 , 0 , & sysfont ); // (1) N\u00e3o pode pois n\u00e3o \u00e9 uma string!! Lembrem que em C uma string \u00e9 um vetor de char em ASCII terminado em NULL, ent\u00e3o precisamos converter o valor inteiro 5 em uma string. Existe uma fun\u00e7\u00e3o muito interessante em C que \u00e9 a sprintf , que funciona de forma similar ao printf s\u00f3 que no lugar de enviar a string formatada para o terminal a sprintf formata a string em um vetor. Veja o exemplo a seguir: int cnt = 5 ; char str [ 128 ]; // (1) sprintf ( str , \"%d\" , cnt ); // (2) gfx_mono_draw_string ( str , 0 , 0 , & sysfont ); Declaramos um vetor ( str ) para armazenar a string formatada. Agora usamos a fun\u00e7\u00e3o sprintf para formatar uma string no vetor str . Podemos formatar a string como de forma similar ao printf, exe: sprintf(str, \"O cnt \u00e9: %d\", cnt); Alguns detalhes: O OLED possui dimens\u00f5es de 128x32 pixels, o texto n\u00e3o pode passar desse tamanho! Tome cuidado com o tamanho da string pois ele deve ser capaz de armazenar toda o texto formatado. Exercise Podemos chamar as fun\u00e7\u00f5es que manipulam o OLED dentro de interrup\u00e7\u00e3o/ callback do bot\u00e3o? N\u00c3O podemos. SIM podemos. Answer N\u00e3o podemos atualizar o OLED dentro de interrup\u00e7\u00f5es e callbacks de HW, pois \u00e9 um evento demorado e as fun\u00e7\u00f5es n\u00e3o s\u00e3o reentrantes. A solu\u00e7\u00e3o \u00e9 atualizar o display no main via uso de flags. Exercise Comecando: Configure o LED e Bot\u00e3o da placa OLED para operar com IRQ. Fa\u00e7a o exemplo anterior funcionar (com o novo led e bot\u00e3o) Crie uma vari\u00e1vel para frequ\u00eancia, exiba o valor no OLED Implemente apenas o incremento da frequ\u00eancia, teste. Pense na l\u00f3gica de como identificar uma aperto longo Implemente o decremento da frequ\u00eancia, pelo aperto longo. Teste sempre na placa. Utilize o DEBUG: https://www.youtube.com/watch?v=dMm4CmQkqPI Lembrem: N\u00e3o podemos ter delay dentro de interrup\u00e7\u00e3o. O OLED n\u00e3o pode ser atualizado dentro de irq. Display Oled: Voc\u00ea deve usar sprintf para formatar a string que ir\u00e1 exibir no OLED Para exibir uma string no OLED use a fun\u00e7\u00e3o gfx_mono_draw_string Carregando\u2026 Conceito B Exercise Acrescente os outros dois bot\u00f5es do oled (2 e 3) do OLED para: Bot\u00e3o 2: Para o pisca pisca Bot\u00e3o 3: Diminuir a frequ\u00eancia (aperto curto) Conceito A Exercise Exiba no OLED n\u00e3o s\u00f3 a frequ\u00eancia, mas uma barra indicando quando o LED ir\u00e1 parar de piscar (como uma barra de progresso).","title":"Praticando"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-pratica/#praticando-oled","text":"","title":"Praticando - OLED"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-pratica/#entrega","text":"Pasta: /Led3-OLED-PIO-IRQ Data LIMITE para entrega: 04/09/22 - 23h59 Agora vamos praticar um pouco o uso de interrup\u00e7\u00e3o, para isso voc\u00eas dever\u00e3o abrir/ criar um novo projeto. Copie o projeto localizado no reposit\u00f3rio de exemplos: SAME70-examples/Screens/OLED-Xplained-Pro-SPI/ para a pasta do seu reposit\u00f3rio de laborat\u00f3rios da disciplina Lab3-OLED-PIO-IRQ . Iremos trabalhar com esse exemplo que configura o OLED (que deve ser conectado na placa no EXT1 ) e incorporar o exemplo da interrup\u00e7\u00e3o aqui (vamos ampliar sua funcionalidade!). A entrega final (conceito A) deve possuir tr\u00eas bot\u00f5es externos a placa que ir\u00e3o configurar a frequ\u00eancia na qual o LED ir\u00e1 piscar (via interrup\u00e7\u00e3o \u00e9 claro). Um dos bot\u00f5es ir\u00e1 aumentar/diminuir a frequ\u00eancia do piscar do LED, depdendendo do modo de pressionamento (curto/longo), um outro ir\u00e1 parar a piscada do LED e o \u00faltimo ter\u00e1 apenas a fun\u00e7\u00e3o de diminuir (modo pressionamento curto). O OLED dever\u00e1 exibir a frequ\u00eancia atual do LED \"graficamente\". O c\u00f3digo deve funcionar por interrup\u00e7\u00e3o nos bot\u00f5es e sempre que poss\u00edvel, entrar em sleep mode .","title":"Entrega"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-pratica/#conceito-c","text":"Agora voc\u00ea deve adicionar o bot\u00e3o 1 da placa OLED para alterar a frequ\u00eancia na qual o LED ir\u00e1 piscar. Al\u00e9m disso, voc\u00ea precisa exibir o valor da frequ\u00eancia no display do OLED. Tip Utilize a fun\u00e7\u00e3o pisca_led para controlar a piscada, deixe como padr\u00e3o o n\u00famero de piscada em 30 vezes. 1 - Bot\u00e3o OLED1: Modifica a frequ\u00eancia do LED (por IRQ) - Se usu\u00e1rio aperta e solta: Aumenta a freq em uma unidade ( delay -= 100 ) - Se usu\u00e1rio aperta e segura: Diminui a freq em uma unidade ( delay += 100 ) Tip Para testar a l\u00f3gica, voc\u00ea pode primeiramente utilizar 2 bot\u00f5es, um para aumentar e outro para diminuir, e posteriormente migrar para utilizar apenas 1 bot\u00e3o para as duas fun\u00e7\u00f5es. 2 - Exibir o valor da frequ\u00eancia no OLED Tip Para escrevermos uma string no OLED devemos usar a fun\u00e7\u00e3o: void gfx_mono_draw_string ( const char * str , const gfx_coord_t x , const gfx_coord_t y , const struct font * font ); Que recebe como par\u00e2metro: cont char str : String com o texto a ser escrito no OLED gfx_coord_t x : Coordenada pixel X de onde a string ir\u00e1 ser escrita gfx_coord_t y : Coordenada pixel Y de onde a string ir\u00e1 ser escrita const struct font *font : Fonte a ser utilizada, a configura\u00e7\u00e3o dela est\u00e1 em src/config/conf_sysfont.h Notem que a fun\u00e7\u00e3o recebe uma string e n\u00e3o um inteiro, ent\u00e3o voc\u00eas N\u00c3O PODEM fazer isso: // ------------------ // - ATENC\u00c3O ERRADO - // ------------------ int cnt = 5 ; gfx_mono_draw_string ( cnt , 0 , 0 , & sysfont ); // (1) N\u00e3o pode pois n\u00e3o \u00e9 uma string!! Lembrem que em C uma string \u00e9 um vetor de char em ASCII terminado em NULL, ent\u00e3o precisamos converter o valor inteiro 5 em uma string. Existe uma fun\u00e7\u00e3o muito interessante em C que \u00e9 a sprintf , que funciona de forma similar ao printf s\u00f3 que no lugar de enviar a string formatada para o terminal a sprintf formata a string em um vetor. Veja o exemplo a seguir: int cnt = 5 ; char str [ 128 ]; // (1) sprintf ( str , \"%d\" , cnt ); // (2) gfx_mono_draw_string ( str , 0 , 0 , & sysfont ); Declaramos um vetor ( str ) para armazenar a string formatada. Agora usamos a fun\u00e7\u00e3o sprintf para formatar uma string no vetor str . Podemos formatar a string como de forma similar ao printf, exe: sprintf(str, \"O cnt \u00e9: %d\", cnt); Alguns detalhes: O OLED possui dimens\u00f5es de 128x32 pixels, o texto n\u00e3o pode passar desse tamanho! Tome cuidado com o tamanho da string pois ele deve ser capaz de armazenar toda o texto formatado. Exercise Podemos chamar as fun\u00e7\u00f5es que manipulam o OLED dentro de interrup\u00e7\u00e3o/ callback do bot\u00e3o? N\u00c3O podemos. SIM podemos. Answer N\u00e3o podemos atualizar o OLED dentro de interrup\u00e7\u00f5es e callbacks de HW, pois \u00e9 um evento demorado e as fun\u00e7\u00f5es n\u00e3o s\u00e3o reentrantes. A solu\u00e7\u00e3o \u00e9 atualizar o display no main via uso de flags. Exercise Comecando: Configure o LED e Bot\u00e3o da placa OLED para operar com IRQ. Fa\u00e7a o exemplo anterior funcionar (com o novo led e bot\u00e3o) Crie uma vari\u00e1vel para frequ\u00eancia, exiba o valor no OLED Implemente apenas o incremento da frequ\u00eancia, teste. Pense na l\u00f3gica de como identificar uma aperto longo Implemente o decremento da frequ\u00eancia, pelo aperto longo. Teste sempre na placa. Utilize o DEBUG: https://www.youtube.com/watch?v=dMm4CmQkqPI Lembrem: N\u00e3o podemos ter delay dentro de interrup\u00e7\u00e3o. O OLED n\u00e3o pode ser atualizado dentro de irq. Display Oled: Voc\u00ea deve usar sprintf para formatar a string que ir\u00e1 exibir no OLED Para exibir uma string no OLED use a fun\u00e7\u00e3o gfx_mono_draw_string Carregando\u2026","title":"Conceito C"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-pratica/#conceito-b","text":"Exercise Acrescente os outros dois bot\u00f5es do oled (2 e 3) do OLED para: Bot\u00e3o 2: Para o pisca pisca Bot\u00e3o 3: Diminuir a frequ\u00eancia (aperto curto)","title":"Conceito B"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ-pratica/#conceito-a","text":"Exercise Exiba no OLED n\u00e3o s\u00f3 a frequ\u00eancia, mas uma barra indicando quando o LED ir\u00e1 parar de piscar (como uma barra de progresso).","title":"Conceito A"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ/","text":"LAB - PIO - IRQ Esse laborat\u00f3rio possui duas entregas, a primeira \u00e9 um passo a passo do laborat\u00f3rio e a segunda \u00e9 parte de pr\u00e1tica que coloca em uso o que foi visto na aula. As duas devem ser entregues at\u00e9 a data limite. Entrega Pastas: /Lab3-PIO-IRQ /Lab3-OLED-PIO-IRQ Data LIMITE para entrega: 04/09/22 - 23h59 Teoria Antes de seguir leia a teoria sobre IRQ A disciplina possui um reposit\u00f3rio de c\u00f3digos exemplos, que ser\u00e1 bastante utilizado ao longo do curso: https://github.com/Insper/SAME70-examples O reposit\u00f3rio est\u00e1 organizado por categorias: comunica\u00e7\u00e3o, demos, perif\u00e9ricos, screens, sensores, ... e assim por diante. Neste laborat\u00f3rio iremos trabalhar com o c\u00f3digo exemplo SAME70-exemples/Perifericos-uC/PIO-IRQ que demonstra como configurar o bot\u00e3o da placa utilizando interrup\u00e7\u00e3o. Esse c\u00f3digo ser\u00e1 a base do laborat\u00f3rio. Exercise Copie o c\u00f3digo exemplo SAME70-examples/Perifericos-uC/PIO-IRQ para a pasta Lab3-PIO-IRQ do seu reposit\u00f3rio. Estude o README desse exemplo! Execute o exemplo na placa! Analise o c\u00f3digo fonte. Progress Click para continuar.... Iremos entender melhor e come\u00e7ar a implementar mudan\u00e7as no c\u00f3digo de exemplo. Bordas Agora vamos modificar o c\u00f3digo um pouco, o exemplo est\u00e1 funcionando com interrup\u00e7\u00e3o em borda de descida no pino, ou seja, a fun\u00e7\u00e3o de callback \u00e9 chamada quando voc\u00ea aperta o bot\u00e3o (High -> Low). Iremos modificar o comportamento para operar com borda de subida, fazendo com que a fun\u00e7\u00e3o de callback seja chamada quando soltarmos o bot\u00e3o (Low -> High). Exercise Mude a fun\u00e7\u00e3o que configura a interrup\u00e7\u00e3o do pino para operar em PIO_IT_RISE_EDGE . Teste na placa. Percebeu a diferen\u00e7a? Exercise As vezes pode acontecer que quando voc aperta o bot\u00e3o o LED pisca e quando voc\u00ea solta tamb\u00e9m? O comportamento teria que ser de piscar apenas quando solta o bot\u00e3o. Por que isso acontece? (N\u00e3o s\u00e3o todas as vezes que isso acontece). Answer Isso acontece por conta do bounce de quando apertamos o bot\u00e3o, o PIO detecta esse movimento e gera uma interrup\u00e7\u00e3o na descida e na subida. Um comportamento indesej\u00e1vel. Para corrigir isso devemos ativar o debounce no pino do bot\u00e3o, isso \u00e9 feito atrav\u00e9s das fun\u00e7\u00f5es a seguir: -pio_configure(BUT_PIO, PIO_INPUT, BUT_IDX_MASK, PIO_PULLUP); +pio_configure(BUT_PIO, PIO_INPUT, BUT_IDX_MASK, PIO_PULLUP | PIO_DEBOUNCE); +pio_set_debounce_filter(BUT_PIO, BUT_IDX_MASK, 60); Exercise Modifique a fun\u00e7\u00e3o init com o trecho de c\u00f3digo anterior e ative o debounce no pino. Teste na placa Progress Click para continuar.... IRQ - Keep it short and simple O tempo que um firmware deve ficar na interrup\u00e7\u00e3o deve ser o menor poss\u00edvel, pelos principais motivos: Outras interrup\u00e7\u00f5es de mesma prioridade ir\u00e3o aguardar o retorno da interrup\u00e7\u00e3o. O firmware ir\u00e1 deixar de servir de maneira r\u00e1pida a diferentes interrup\u00e7\u00f5es se gastar tempo nelas. Nem todas as fun\u00e7\u00f5es s\u00e3o reentrantes . Fun\u00e7\u00f5es como printf podem n\u00e3o operar corretamente dentro de interrup\u00e7\u00f5es por poderem ser chamadas mais de uma vez, sem terem terminado de executar. RTOS: As tarefas devem ser executadas em tasks e n\u00e3o nas interrup\u00e7\u00f5es, possibilitando assim um maior controle do fluxo de execu\u00e7\u00e3o do firmware (vamos ver isso mais para frente). Para maiores informa\u00e7\u00f5es acesse: https://betterembsw.blogspot.com/2013/03/rules-for-using-interrupts.html Existem algumas solu\u00e7\u00f5es para essa quest\u00e3o, a mais simples delas \u00e9 a de realizar o processamento de uma interrup\u00e7\u00e3o no loop principal ( while(1) ), essa abordagem \u00e9 muito utilizada em sistemas embarcados. E deve ser feita da forma a seguir: Define-se uma vari\u00e1vel global que servir\u00e1 como flag ( true ou false ) [^1] e importante, essa vari\u00e1vel precisa ser do tipo volatile ) Interrup\u00e7\u00e3o altera o status da flag para True while(1) verifica status da flag para realizar a\u00e7\u00e3o. while(1) volta a flag para o estado original False. Analise o exemplo a seguir que ilustra o uso de flags para tratar o evento no bot\u00e3o: /* flag */ volatile char but_flag ; // (1) /* funcao de callback/ Handler */ void but_callBack ( void ){ but_flag = 1 ; } void main ( void ){ /* inicializacao */ // .... // ... while ( 1 ){ if ( but_flag ) { // (2) pisca_led ( 5 , 200 ); but_flag = 0 ; // (3) } } } :man_raising_hand: Note que a vari\u00e1vel que ser\u00e1 utilizada como flag foi declarada como volatile O bloco de c\u00f3digo dentro do if s\u00f3 ser\u00e1 processado quando o but_flag for True Essa linha \u00e9 muito importante pois sem ela o bloco do if seria executuado novamente sem o evento externo do bot\u00e3o. True/False A linguagem C n\u00e3o define True/False, indicamos usando o valor 1 para verdadeiro e 0 para falso. volatile Sempre que uma interrup\u00e7\u00e3o alterar uma vari\u00e1vel global, essa deve possuir o 'pragma'/modificador volatile . Exemplo: volatile int valADC; Esse pragma serve para informar o compilador (no nosso caso GCC) que essa vari\u00e1vel ser\u00e1 modificada sem que o compilador saiba, evitando assim que a vari\u00e1vel n\u00e3o seja compilada. Compiladores s\u00e3o projetados para otimizar programas removendo trechos ou vari\u00e1veis desnecess\u00e1rias. Como a fun\u00e7\u00e3o de Handler (interrup\u00e7\u00e3o) nunca \u00e9 chamada diretamente pelo programa, o compilador pode supor que essa fun\u00e7\u00e3o n\u00e3o vai ser executada nunca e pode optimizar a vari\u00e1vel que nela seria atualizada (j\u00e1 que n\u00e3o \u00e9 chamada diretamente, mas sim pelo hardware quando ocorre um evento). Leia mais sobre volatile ATEN\u00c7\u00c3O: s\u00f3 usar volatile quando necess\u00e1rio uma IRQ altera o valor de uma vari\u00e1vel . Exercise Agora modifique o c\u00f3digo do Lab3 para usar flag e processar o evento do bot\u00e3o na func\u00e3o main. Lembre que dentro do callback do bot\u00e3o n\u00e3o pode mais ter a fun\u00e7\u00e3o pisca_led ! Modifique o exemplo para piscar o led no while(1) utilizando flag vindo da interrup\u00e7\u00e3o. Programe e teste no HW Progress Click para continuar.... Low power modes Trabalhar por interrup\u00e7\u00e3o possui v\u00e1rias vantagens, e uma delas \u00e9 a possibilidade de fazer o uC entrar em modos de opera\u00e7\u00e3o de baixo consumo energ\u00e9tico ( sleep modes ). No caso do uC utilizado no curso, s\u00e3o 4 modos distintos de lowpower, cada um com sua vantagem / desvantagem: Active Mode: Active mode is the normal running mode with the core clock running from the fast RC oscillator, the main crystaloscillator or the PLLA. The Power Management Controller can be used to adapt the core, bus and peripheral frequencies and to enable and/or disable the peripheral clocks. Backup mode: The purpose of Backup mode is to achieve the lowest power consumption possible in a system which is performing periodic wake-ups to perform tasks but not requiring fast startup time. Wait mode: The purpose of Wait mode is to achieve very low power consumption while maintaining the whole device in a powered state for a startup time of less than 10 us. Sleep Mode: The purpose of sleep mode is to optimize power consumption of the device versus response time. In this mode, only the core clock is stopped. The peripheral clocks can be enabled. The current consumption in this mode is application-dependent Informa\u00e7\u00f5es importantes N\u00e3o \u00e9 qualquer interrup\u00e7\u00e3o que consegue tirar o uC de modos de sleep mais profundos Quanto mais profundo o sleep, mais tempo o uC leva para 'acordar' Alguns modos podem perder informa\u00e7\u00f5es da mem\u00f3ria RAM Mais informa\u00e7\u00f5es na sec\u00e7\u00e3o 6.6 do datasheet Exercise Na tabela anterior aparece na coluna do Potential Wake-Up Sources um item chamado de WKUP0-13 pins , o que voc\u00ea acha que isso significa? Pinos espec\u00edficos do uc Pinos do RTT Pinos de um PIO N\u00e3o fa\u00e7o ideia Answer WKUP (wake-up) pins: s\u00e3o pinos espec\u00edficos do SAME70 que al\u00e9m de irem para o PIO v\u00e3o tamb\u00e9m para o Supply Controller e que possibilita re-energizar o uC ap\u00f3s um evento externo. Exercise Quais sleep-modes podemos usar se desejamos acordar o uC com eventos do PIO (sem usar os pinos com as fun\u00e7\u00f5es especiais de WKUP)?: Sleep Mode Sleep Mode / Wait Mode Sleep Mode / Wait Mode/ Deep-Power-mode Sleep Mode / Wait Mode/ Deep-Power-mode/ Backup Mode Answer Podemos usar apenas o Sleep Mode pois o uC \u00e9 acordado por qualquer interrup\u00e7\u00e3o. Para entrarmos em um modo de menor n\u00edvel energ\u00e9ticos temos que usar um dos WKUP pins ou algum outro perif\u00e9rico da lista para poder acordar o uC (entrar n\u00f3s podemos, mas nunca vamos sair do sono). Adicionando a lib de lowpower mode (ASF Wizard) Para termos acessos as fun\u00e7\u00f5es da Microchip que lidam com o sleep mode devemos adicionar a biblioteca Sleep manager (service) no Microchip Studio: ASF ASF Wizard Agora basta adicionar a biblioteca Sleep manager (service) ao projeto. Lembre de dar apply. Entrando em lowpower Agora podemos usar as fun\u00e7\u00f5es de low power, primeiramente iremos utilizar somente o modo sleep mode via a chamada da fun\u00e7\u00e3o pmc_sleep() conforme exemplo a seguir: void main ( void ){ while ( 1 ){ if ( but_flag ) { ... } // Entra em sleep mode pmc_sleep ( SAM_PM_SMODE_SLEEP_WFI ); // (1) } } C\u00f3digo 'trava' aqui at\u00e9 ser 'acordado' Uma vez chamada essa fun\u00e7\u00e3o o uC entrar\u00e1 em modo sleep WFI (WaitForInterrupt), ou seja, o CORE para a execu\u00e7\u00e3o do c\u00f3digo e retoma as atividades normais somente quando uma interrup\u00e7\u00e3o \"acordar\" o CORE. Exercise Modifique o exemplo para entrar em modo sleep Programe e teste no HW Como testar o sleepmode? No laborat\u00f3rio temos um mult\u00edmetro de bancada que \u00e9 capaz de medir com at\u00e9 5 d\u00edgitos uma corrente el\u00e9trica. Podemos usar esse equipamento para medir a corrente consumida pelo uC durante os diferentes ciclos de opera\u00e7\u00e3o. Progress Click para continuar.... Pensando um pouco Exercise Vamos imaginar o cen\u00e1rio a seguir: Voc\u00ea est\u00e1 desenvolvendo uma interface na qual um usu\u00e1rio pode configurar por meio de um bot\u00e3o, a quantidade desejada de um determinado item (a\u00e7\u00facar da m\u00e1quina de caf\u00e9, temperatura do forno, ....). \u00c9 muito comum que a interface possibilite manter o bot\u00e3o pressionado para alterar mais rapidamente o contador, ou seja: O usu\u00e1rio apertar e soltar o bot\u00e3o para cada vez que ele quer incrementar o contador O contador aumenta enquanto o usu\u00e1rio mantiver o bot\u00e3o pressionado A solu\u00e7\u00e3o de c\u00f3digo para a primeira op\u00e7\u00e3o \u00e9 trivial e conseguimos fazer com o que j\u00e1 temos, mas e a solu\u00e7\u00e3o para o outro caso (bot\u00e3o apertado), alguma ideia de como fazer? (solu\u00e7\u00e3o a seguir) Answer A ideia \u00e9 simples: configurar a interrup\u00e7\u00e3o do pino para descida e subida, assim sabemos quando o usu\u00e1rio apertou o bot\u00e3o e depois quando ele soltou. Mas temos um problema, s\u00f3 podemos configurar uma fun\u00e7\u00e3o de callback por o pino! Para ativarmos a interrup\u00e7\u00e3o nos dois casos (subida/ descida) devemos usar o PIO_IT_EDGE . A chamada de fun\u00e7\u00e3o que configura interrup\u00e7\u00e3o no pino ficaria assim: pio_handler_set(BUT_PIO, BUT_PIO_ID, BUT_IDX_MASK, + PIO_IT_EDGE, but_callback); Notem que a mesma fun\u00e7\u00e3o but_callback ser\u00e1 chamada para os dois casos de evento. ---- \\____ Fall-Edge ==> but_callback() _____ High-Edge ___/ Exercise Legal! mas agora a fun\u00e7\u00e3o but_callback ser\u00e1 chamada pelo HW quando ocorrer uma mudan\u00e7a de n\u00edvel de qualquer tipo. Alguma ideia de como vamos saber se entramos na fun\u00e7\u00e3o but_callback pela borda de descida (usu\u00e1rio apertou o bot\u00e3o) ou plea borda de subida (usu\u00e1rio soltou o bot\u00e3o)? (solu\u00e7\u00e3o a seguir) Answer A solu\u00e7\u00e3o \u00e9 verificamos imediatamente dentro da fun\u00e7\u00e3o de callback o valor atual do pino: se ele for '0' quer dizer que entramos por uma borda de descida e se for '1' por uma borda de subida! O c\u00f3digo a seguir indica como fazer isso: void but_callback ( void ) { if ( pio_get ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK )) { // PINO == 1 --> Borda de subida } else { // PINO == 0 --> Borda de descida } } Sacada legal n\u00e9? Progress Click para continuar.... Agora siga para a p\u00e1gina: Praticando, que faz parte desse lab.","title":"Lab"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ/#lab-pio-irq","text":"Esse laborat\u00f3rio possui duas entregas, a primeira \u00e9 um passo a passo do laborat\u00f3rio e a segunda \u00e9 parte de pr\u00e1tica que coloca em uso o que foi visto na aula. As duas devem ser entregues at\u00e9 a data limite.","title":"LAB - PIO - IRQ"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ/#entrega","text":"Pastas: /Lab3-PIO-IRQ /Lab3-OLED-PIO-IRQ Data LIMITE para entrega: 04/09/22 - 23h59 Teoria Antes de seguir leia a teoria sobre IRQ A disciplina possui um reposit\u00f3rio de c\u00f3digos exemplos, que ser\u00e1 bastante utilizado ao longo do curso: https://github.com/Insper/SAME70-examples O reposit\u00f3rio est\u00e1 organizado por categorias: comunica\u00e7\u00e3o, demos, perif\u00e9ricos, screens, sensores, ... e assim por diante. Neste laborat\u00f3rio iremos trabalhar com o c\u00f3digo exemplo SAME70-exemples/Perifericos-uC/PIO-IRQ que demonstra como configurar o bot\u00e3o da placa utilizando interrup\u00e7\u00e3o. Esse c\u00f3digo ser\u00e1 a base do laborat\u00f3rio. Exercise Copie o c\u00f3digo exemplo SAME70-examples/Perifericos-uC/PIO-IRQ para a pasta Lab3-PIO-IRQ do seu reposit\u00f3rio. Estude o README desse exemplo! Execute o exemplo na placa! Analise o c\u00f3digo fonte. Progress Click para continuar.... Iremos entender melhor e come\u00e7ar a implementar mudan\u00e7as no c\u00f3digo de exemplo.","title":"Entrega"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ/#bordas","text":"Agora vamos modificar o c\u00f3digo um pouco, o exemplo est\u00e1 funcionando com interrup\u00e7\u00e3o em borda de descida no pino, ou seja, a fun\u00e7\u00e3o de callback \u00e9 chamada quando voc\u00ea aperta o bot\u00e3o (High -> Low). Iremos modificar o comportamento para operar com borda de subida, fazendo com que a fun\u00e7\u00e3o de callback seja chamada quando soltarmos o bot\u00e3o (Low -> High). Exercise Mude a fun\u00e7\u00e3o que configura a interrup\u00e7\u00e3o do pino para operar em PIO_IT_RISE_EDGE . Teste na placa. Percebeu a diferen\u00e7a? Exercise As vezes pode acontecer que quando voc aperta o bot\u00e3o o LED pisca e quando voc\u00ea solta tamb\u00e9m? O comportamento teria que ser de piscar apenas quando solta o bot\u00e3o. Por que isso acontece? (N\u00e3o s\u00e3o todas as vezes que isso acontece). Answer Isso acontece por conta do bounce de quando apertamos o bot\u00e3o, o PIO detecta esse movimento e gera uma interrup\u00e7\u00e3o na descida e na subida. Um comportamento indesej\u00e1vel. Para corrigir isso devemos ativar o debounce no pino do bot\u00e3o, isso \u00e9 feito atrav\u00e9s das fun\u00e7\u00f5es a seguir: -pio_configure(BUT_PIO, PIO_INPUT, BUT_IDX_MASK, PIO_PULLUP); +pio_configure(BUT_PIO, PIO_INPUT, BUT_IDX_MASK, PIO_PULLUP | PIO_DEBOUNCE); +pio_set_debounce_filter(BUT_PIO, BUT_IDX_MASK, 60); Exercise Modifique a fun\u00e7\u00e3o init com o trecho de c\u00f3digo anterior e ative o debounce no pino. Teste na placa Progress Click para continuar....","title":"Bordas"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ/#irq-keep-it-short-and-simple","text":"O tempo que um firmware deve ficar na interrup\u00e7\u00e3o deve ser o menor poss\u00edvel, pelos principais motivos: Outras interrup\u00e7\u00f5es de mesma prioridade ir\u00e3o aguardar o retorno da interrup\u00e7\u00e3o. O firmware ir\u00e1 deixar de servir de maneira r\u00e1pida a diferentes interrup\u00e7\u00f5es se gastar tempo nelas. Nem todas as fun\u00e7\u00f5es s\u00e3o reentrantes . Fun\u00e7\u00f5es como printf podem n\u00e3o operar corretamente dentro de interrup\u00e7\u00f5es por poderem ser chamadas mais de uma vez, sem terem terminado de executar. RTOS: As tarefas devem ser executadas em tasks e n\u00e3o nas interrup\u00e7\u00f5es, possibilitando assim um maior controle do fluxo de execu\u00e7\u00e3o do firmware (vamos ver isso mais para frente). Para maiores informa\u00e7\u00f5es acesse: https://betterembsw.blogspot.com/2013/03/rules-for-using-interrupts.html Existem algumas solu\u00e7\u00f5es para essa quest\u00e3o, a mais simples delas \u00e9 a de realizar o processamento de uma interrup\u00e7\u00e3o no loop principal ( while(1) ), essa abordagem \u00e9 muito utilizada em sistemas embarcados. E deve ser feita da forma a seguir: Define-se uma vari\u00e1vel global que servir\u00e1 como flag ( true ou false ) [^1] e importante, essa vari\u00e1vel precisa ser do tipo volatile ) Interrup\u00e7\u00e3o altera o status da flag para True while(1) verifica status da flag para realizar a\u00e7\u00e3o. while(1) volta a flag para o estado original False. Analise o exemplo a seguir que ilustra o uso de flags para tratar o evento no bot\u00e3o: /* flag */ volatile char but_flag ; // (1) /* funcao de callback/ Handler */ void but_callBack ( void ){ but_flag = 1 ; } void main ( void ){ /* inicializacao */ // .... // ... while ( 1 ){ if ( but_flag ) { // (2) pisca_led ( 5 , 200 ); but_flag = 0 ; // (3) } } } :man_raising_hand: Note que a vari\u00e1vel que ser\u00e1 utilizada como flag foi declarada como volatile O bloco de c\u00f3digo dentro do if s\u00f3 ser\u00e1 processado quando o but_flag for True Essa linha \u00e9 muito importante pois sem ela o bloco do if seria executuado novamente sem o evento externo do bot\u00e3o. True/False A linguagem C n\u00e3o define True/False, indicamos usando o valor 1 para verdadeiro e 0 para falso. volatile Sempre que uma interrup\u00e7\u00e3o alterar uma vari\u00e1vel global, essa deve possuir o 'pragma'/modificador volatile . Exemplo: volatile int valADC; Esse pragma serve para informar o compilador (no nosso caso GCC) que essa vari\u00e1vel ser\u00e1 modificada sem que o compilador saiba, evitando assim que a vari\u00e1vel n\u00e3o seja compilada. Compiladores s\u00e3o projetados para otimizar programas removendo trechos ou vari\u00e1veis desnecess\u00e1rias. Como a fun\u00e7\u00e3o de Handler (interrup\u00e7\u00e3o) nunca \u00e9 chamada diretamente pelo programa, o compilador pode supor que essa fun\u00e7\u00e3o n\u00e3o vai ser executada nunca e pode optimizar a vari\u00e1vel que nela seria atualizada (j\u00e1 que n\u00e3o \u00e9 chamada diretamente, mas sim pelo hardware quando ocorre um evento). Leia mais sobre volatile ATEN\u00c7\u00c3O: s\u00f3 usar volatile quando necess\u00e1rio uma IRQ altera o valor de uma vari\u00e1vel . Exercise Agora modifique o c\u00f3digo do Lab3 para usar flag e processar o evento do bot\u00e3o na func\u00e3o main. Lembre que dentro do callback do bot\u00e3o n\u00e3o pode mais ter a fun\u00e7\u00e3o pisca_led ! Modifique o exemplo para piscar o led no while(1) utilizando flag vindo da interrup\u00e7\u00e3o. Programe e teste no HW Progress Click para continuar....","title":"IRQ - Keep it short and simple"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ/#low-power-modes","text":"Trabalhar por interrup\u00e7\u00e3o possui v\u00e1rias vantagens, e uma delas \u00e9 a possibilidade de fazer o uC entrar em modos de opera\u00e7\u00e3o de baixo consumo energ\u00e9tico ( sleep modes ). No caso do uC utilizado no curso, s\u00e3o 4 modos distintos de lowpower, cada um com sua vantagem / desvantagem: Active Mode: Active mode is the normal running mode with the core clock running from the fast RC oscillator, the main crystaloscillator or the PLLA. The Power Management Controller can be used to adapt the core, bus and peripheral frequencies and to enable and/or disable the peripheral clocks. Backup mode: The purpose of Backup mode is to achieve the lowest power consumption possible in a system which is performing periodic wake-ups to perform tasks but not requiring fast startup time. Wait mode: The purpose of Wait mode is to achieve very low power consumption while maintaining the whole device in a powered state for a startup time of less than 10 us. Sleep Mode: The purpose of sleep mode is to optimize power consumption of the device versus response time. In this mode, only the core clock is stopped. The peripheral clocks can be enabled. The current consumption in this mode is application-dependent Informa\u00e7\u00f5es importantes N\u00e3o \u00e9 qualquer interrup\u00e7\u00e3o que consegue tirar o uC de modos de sleep mais profundos Quanto mais profundo o sleep, mais tempo o uC leva para 'acordar' Alguns modos podem perder informa\u00e7\u00f5es da mem\u00f3ria RAM Mais informa\u00e7\u00f5es na sec\u00e7\u00e3o 6.6 do datasheet Exercise Na tabela anterior aparece na coluna do Potential Wake-Up Sources um item chamado de WKUP0-13 pins , o que voc\u00ea acha que isso significa? Pinos espec\u00edficos do uc Pinos do RTT Pinos de um PIO N\u00e3o fa\u00e7o ideia Answer WKUP (wake-up) pins: s\u00e3o pinos espec\u00edficos do SAME70 que al\u00e9m de irem para o PIO v\u00e3o tamb\u00e9m para o Supply Controller e que possibilita re-energizar o uC ap\u00f3s um evento externo. Exercise Quais sleep-modes podemos usar se desejamos acordar o uC com eventos do PIO (sem usar os pinos com as fun\u00e7\u00f5es especiais de WKUP)?: Sleep Mode Sleep Mode / Wait Mode Sleep Mode / Wait Mode/ Deep-Power-mode Sleep Mode / Wait Mode/ Deep-Power-mode/ Backup Mode Answer Podemos usar apenas o Sleep Mode pois o uC \u00e9 acordado por qualquer interrup\u00e7\u00e3o. Para entrarmos em um modo de menor n\u00edvel energ\u00e9ticos temos que usar um dos WKUP pins ou algum outro perif\u00e9rico da lista para poder acordar o uC (entrar n\u00f3s podemos, mas nunca vamos sair do sono).","title":"Low power modes"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ/#adicionando-a-lib-de-lowpower-mode-asf-wizard","text":"Para termos acessos as fun\u00e7\u00f5es da Microchip que lidam com o sleep mode devemos adicionar a biblioteca Sleep manager (service) no Microchip Studio: ASF ASF Wizard Agora basta adicionar a biblioteca Sleep manager (service) ao projeto. Lembre de dar apply.","title":"Adicionando a lib de lowpower mode (ASF Wizard)"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ/#entrando-em-lowpower","text":"Agora podemos usar as fun\u00e7\u00f5es de low power, primeiramente iremos utilizar somente o modo sleep mode via a chamada da fun\u00e7\u00e3o pmc_sleep() conforme exemplo a seguir: void main ( void ){ while ( 1 ){ if ( but_flag ) { ... } // Entra em sleep mode pmc_sleep ( SAM_PM_SMODE_SLEEP_WFI ); // (1) } } C\u00f3digo 'trava' aqui at\u00e9 ser 'acordado' Uma vez chamada essa fun\u00e7\u00e3o o uC entrar\u00e1 em modo sleep WFI (WaitForInterrupt), ou seja, o CORE para a execu\u00e7\u00e3o do c\u00f3digo e retoma as atividades normais somente quando uma interrup\u00e7\u00e3o \"acordar\" o CORE. Exercise Modifique o exemplo para entrar em modo sleep Programe e teste no HW Como testar o sleepmode? No laborat\u00f3rio temos um mult\u00edmetro de bancada que \u00e9 capaz de medir com at\u00e9 5 d\u00edgitos uma corrente el\u00e9trica. Podemos usar esse equipamento para medir a corrente consumida pelo uC durante os diferentes ciclos de opera\u00e7\u00e3o. Progress Click para continuar....","title":"Entrando em lowpower"},{"location":"navigation/Labs/Lab_PIO_IRQ/Lab-PIO-IRQ/#pensando-um-pouco","text":"Exercise Vamos imaginar o cen\u00e1rio a seguir: Voc\u00ea est\u00e1 desenvolvendo uma interface na qual um usu\u00e1rio pode configurar por meio de um bot\u00e3o, a quantidade desejada de um determinado item (a\u00e7\u00facar da m\u00e1quina de caf\u00e9, temperatura do forno, ....). \u00c9 muito comum que a interface possibilite manter o bot\u00e3o pressionado para alterar mais rapidamente o contador, ou seja: O usu\u00e1rio apertar e soltar o bot\u00e3o para cada vez que ele quer incrementar o contador O contador aumenta enquanto o usu\u00e1rio mantiver o bot\u00e3o pressionado A solu\u00e7\u00e3o de c\u00f3digo para a primeira op\u00e7\u00e3o \u00e9 trivial e conseguimos fazer com o que j\u00e1 temos, mas e a solu\u00e7\u00e3o para o outro caso (bot\u00e3o apertado), alguma ideia de como fazer? (solu\u00e7\u00e3o a seguir) Answer A ideia \u00e9 simples: configurar a interrup\u00e7\u00e3o do pino para descida e subida, assim sabemos quando o usu\u00e1rio apertou o bot\u00e3o e depois quando ele soltou. Mas temos um problema, s\u00f3 podemos configurar uma fun\u00e7\u00e3o de callback por o pino! Para ativarmos a interrup\u00e7\u00e3o nos dois casos (subida/ descida) devemos usar o PIO_IT_EDGE . A chamada de fun\u00e7\u00e3o que configura interrup\u00e7\u00e3o no pino ficaria assim: pio_handler_set(BUT_PIO, BUT_PIO_ID, BUT_IDX_MASK, + PIO_IT_EDGE, but_callback); Notem que a mesma fun\u00e7\u00e3o but_callback ser\u00e1 chamada para os dois casos de evento. ---- \\____ Fall-Edge ==> but_callback() _____ High-Edge ___/ Exercise Legal! mas agora a fun\u00e7\u00e3o but_callback ser\u00e1 chamada pelo HW quando ocorrer uma mudan\u00e7a de n\u00edvel de qualquer tipo. Alguma ideia de como vamos saber se entramos na fun\u00e7\u00e3o but_callback pela borda de descida (usu\u00e1rio apertou o bot\u00e3o) ou plea borda de subida (usu\u00e1rio soltou o bot\u00e3o)? (solu\u00e7\u00e3o a seguir) Answer A solu\u00e7\u00e3o \u00e9 verificamos imediatamente dentro da fun\u00e7\u00e3o de callback o valor atual do pino: se ele for '0' quer dizer que entramos por uma borda de descida e se for '1' por uma borda de subida! O c\u00f3digo a seguir indica como fazer isso: void but_callback ( void ) { if ( pio_get ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK )) { // PINO == 1 --> Borda de subida } else { // PINO == 0 --> Borda de descida } } Sacada legal n\u00e9? Progress Click para continuar.... Agora siga para a p\u00e1gina: Praticando, que faz parte desse lab.","title":"Pensando um pouco"},{"location":"navigation/Labs/Lab_RTOS/Lab-RTOS-dicas/","text":"Lab - RTOS - Dicas Notei alguns erros e dificuldades neste laborat\u00f3rio que pretendo retomar aqui. Vale notar que este exemplo foi extra\u00eddo dos exemplos fornecidos pelo fabricante do microcontrolador e possui algumas coisas diferentes do que estamos acostumados. UNUSED(pvParameters) Isso aparece na fun\u00e7\u00e3o que define a tarefa task_led e serve apenas para remover warning do gcc que indica que um argumento da fun\u00e7\u00e3o n\u00e3o foi usado na sua implementa\u00e7\u00e3o. https://stackoverflow.com/questions/3599160/how-to-suppress-unused-parameter-warnings-in-c/12891181 Mas professor n\u00e3o podemos remover esse argumento j\u00e1 que n\u00e3o estamos usando? N\u00c3O pois o freeRTOS espera que a fun\u00e7\u00e3o que implementa uma tarefa tenha um argumento, da documenta\u00e7\u00e3o: // A task should have the following structure: void vATaskFunction ( void * pvParameters ) { for ( ;; ) { -- Task application code here . -- } /* Tasks must not attempt to return from their implementing function or otherwise exit. In newer FreeRTOS port attempting to do so will result in an configASSERT() being called if it is defined. If it is necessary for a task to exit then have the task call vTaskDelete( NULL ) to ensure its exit is clean. */ vTaskDelete ( NULL ); } https://www.freertos.org/implementing-a-FreeRTOS-task.html LED_Toggle(LED0) Muitas pessoas empacaram aqui ou n\u00e3o entenderam essa fun\u00e7\u00e3o, o c\u00f3digo exemplo \u00e9 original do fabricante do microcontrolador e \u00e9 comum aparecerem coisas que n\u00e3o conhecemos, mas sem muito alarde n\u00e9? O pr\u00f3prio nome da fun\u00e7\u00e3o diz o que faz: LED TOGGLE ou: INVERTE LED . A fun\u00e7\u00e3o n\u00e3o faz o LED piscar, ela apenas inverte o estado do LED toda vez que for chamada, o uso dessa fun\u00e7\u00e3o com o vTaskDelay(1000) faz o LED piscar. Essa fun\u00e7\u00e3o \u00e9 muito espec\u00edfica e n\u00e3o ajuda muito porque n\u00e3o podemos usar em outros pinos (LEDs), s\u00f3 funciona para o LED0 que foi definido em um include muito espec\u00edfico do projeto. Podemos no lugar ousar esta outra implementa\u00e7\u00e3o que faz a mesma coisa, mas recebe como par\u00e2metro o PIO e a m\u00e1scara e inverte o valor do pino (1 \u2192 0 \u2192 1) toda vez que a fun\u00e7\u00e3o for chamada, a fun\u00e7\u00e3o a seguir implementa isso: void pin_toggle ( Pio * pio , uint32_t mask ){ if ( pio_get_output_data_status ( pio , mask )) pio_clear ( pio , mask ); else pio_set ( pio , mask ); } Info Mas professor daria para fazer de outra forma, sem usar esse pin_toggle ou a LED_Toggle ? Da sim, mas temos que usar uma vari\u00e1vel local para isso (no lugar de acessar o PIO): ```c static void task_led(void *pvParameters) { UNUSED(pvParameters); char f_led = 0 for (;;) { f_led = !f_led; if (f_led) pio_set(LED_PIO, LED_IDX_MASK); else pio_clear(LED_PIO, LED_IDX_MASK); \u200b vTaskDelay(1000); } } ``` task_led1 C\u00f3digos originais Vamos ter que ter esses trechos de c\u00f3digo em mente: Callback do bot\u00e3o 1 void but1_callback ( void ){ printf ( \"but_callback \\n \" ); BaseType_t xHigherPriorityTaskWoken = pdFALSE ; xSemaphoreGiveFromISR ( xSemaphore , & xHigherPriorityTaskWoken ); } 2. task led static void task_led ( void * pvParameters ) { xSemaphore = xSemaphoreCreateBinary (); /* ... init but1 .... */ for (;;) { if ( xSemaphoreTake ( xSemaphore , ( TickType_t ) 500 / portTICK_PERIOD_MS ) == pdTRUE ){ LED_Toggle ( LED0 ); } } } Essa tarefa deveria ser executada sempre que o bot\u00e3o 1 da placa OLED fosse pressionado, mas isso n\u00e3o deveria impedir que a task_led de tamb\u00e9m ser executada, o que muitos fizeram foi usar o mesmo sem\u00e1foro que j\u00e1 estava sendo usado pela task_led nesta task, da seguinte maneira: static void task_led1 ( void * pvParameters ) { for (;;) { if ( xSemaphoreTake ( xSemaphore , 500 / portTICK_PERIOD_MS )){ for ( int i = 0 ; i < n ; i ++ ){ pio_clear ( LED1_PIO , LED1_IDX_MASK ); vtaskDelay ( 500 ); pio_set ( LED1_PIO , LED1_IDX_MASK ); vtaskDelay ( 500 ); } } } } O problema disso \u00e9 que tanto a task_led quanto a task_led1 est\u00e3o compartilhando o mesmo sem\u00e1foro, e o sem\u00e1foro usado aqui \u00e9 do tipo bin\u00e1rio, ou seja, pode ser 0 ou 1 a primeira tarefa que consumir o sem\u00e1foro vai o tornar 0 e a segunda tarefa n\u00e3o vai ser executada corretamente, conforme diagrama a baixo: Existem duas solu\u00e7\u00f5es para esse problemas, a primeira seria a de usar um Counting Semaphores a outra \u00e9 a de usar um outro sem\u00e1foro para indicar para a nova tarefa que ela deve ser executada, para isso: Definir uma vari\u00e1vel global para o novo sem\u00e1foro: Fazer a fun\u00e7\u00e3o but1_callback liberar dois sem\u00e1foros Criar o sem\u00e1foro dentro da task_led1 Usar o sem\u00e1foro novo na task_led1 SemaphoreHandle_t xSemaphore; +SemaphoreHandle_t xSemaphore1; void but1_callback(void){ printf(\"but_callback \\n\"); BaseType_t xHigherPriorityTaskWoken = pdFALSE; xSemaphoreGiveFromISR(xSemaphore, &xHigherPriorityTaskWoken); + xSemaphoreGiveFromISR(xSemaphore1, &xHigherPriorityTaskWoken); } static void task_led1(void *pvParameters) { + xSemaphore1 = xSemaphoreCreateBinary(); for (;;) { + if( xSemaphoreTake(xSemaphore1, 500/portTICK_PERIOD_MS)){ for (int i=0;i<n;i++){ pio_clear(LED1_PIO, LED1_IDX_MASK); vtaskDelay(500); pio_set(LED1_PIO, LED1_IDX_MASK); vtaskDelay(500); } } } }","title":"Lab - RTOS - Dicas"},{"location":"navigation/Labs/Lab_RTOS/Lab-RTOS-dicas/#lab-rtos-dicas","text":"Notei alguns erros e dificuldades neste laborat\u00f3rio que pretendo retomar aqui. Vale notar que este exemplo foi extra\u00eddo dos exemplos fornecidos pelo fabricante do microcontrolador e possui algumas coisas diferentes do que estamos acostumados.","title":"Lab - RTOS - Dicas"},{"location":"navigation/Labs/Lab_RTOS/Lab-RTOS-dicas/#unusedpvparameters","text":"Isso aparece na fun\u00e7\u00e3o que define a tarefa task_led e serve apenas para remover warning do gcc que indica que um argumento da fun\u00e7\u00e3o n\u00e3o foi usado na sua implementa\u00e7\u00e3o. https://stackoverflow.com/questions/3599160/how-to-suppress-unused-parameter-warnings-in-c/12891181 Mas professor n\u00e3o podemos remover esse argumento j\u00e1 que n\u00e3o estamos usando? N\u00c3O pois o freeRTOS espera que a fun\u00e7\u00e3o que implementa uma tarefa tenha um argumento, da documenta\u00e7\u00e3o: // A task should have the following structure: void vATaskFunction ( void * pvParameters ) { for ( ;; ) { -- Task application code here . -- } /* Tasks must not attempt to return from their implementing function or otherwise exit. In newer FreeRTOS port attempting to do so will result in an configASSERT() being called if it is defined. If it is necessary for a task to exit then have the task call vTaskDelete( NULL ) to ensure its exit is clean. */ vTaskDelete ( NULL ); } https://www.freertos.org/implementing-a-FreeRTOS-task.html","title":"UNUSED(pvParameters)"},{"location":"navigation/Labs/Lab_RTOS/Lab-RTOS-dicas/#led_toggleled0","text":"Muitas pessoas empacaram aqui ou n\u00e3o entenderam essa fun\u00e7\u00e3o, o c\u00f3digo exemplo \u00e9 original do fabricante do microcontrolador e \u00e9 comum aparecerem coisas que n\u00e3o conhecemos, mas sem muito alarde n\u00e9? O pr\u00f3prio nome da fun\u00e7\u00e3o diz o que faz: LED TOGGLE ou: INVERTE LED . A fun\u00e7\u00e3o n\u00e3o faz o LED piscar, ela apenas inverte o estado do LED toda vez que for chamada, o uso dessa fun\u00e7\u00e3o com o vTaskDelay(1000) faz o LED piscar. Essa fun\u00e7\u00e3o \u00e9 muito espec\u00edfica e n\u00e3o ajuda muito porque n\u00e3o podemos usar em outros pinos (LEDs), s\u00f3 funciona para o LED0 que foi definido em um include muito espec\u00edfico do projeto. Podemos no lugar ousar esta outra implementa\u00e7\u00e3o que faz a mesma coisa, mas recebe como par\u00e2metro o PIO e a m\u00e1scara e inverte o valor do pino (1 \u2192 0 \u2192 1) toda vez que a fun\u00e7\u00e3o for chamada, a fun\u00e7\u00e3o a seguir implementa isso: void pin_toggle ( Pio * pio , uint32_t mask ){ if ( pio_get_output_data_status ( pio , mask )) pio_clear ( pio , mask ); else pio_set ( pio , mask ); } Info Mas professor daria para fazer de outra forma, sem usar esse pin_toggle ou a LED_Toggle ? Da sim, mas temos que usar uma vari\u00e1vel local para isso (no lugar de acessar o PIO): ```c static void task_led(void *pvParameters) { UNUSED(pvParameters); char f_led = 0 for (;;) { f_led = !f_led; if (f_led) pio_set(LED_PIO, LED_IDX_MASK); else pio_clear(LED_PIO, LED_IDX_MASK); \u200b vTaskDelay(1000); } } ```","title":"LED_Toggle(LED0)"},{"location":"navigation/Labs/Lab_RTOS/Lab-RTOS-dicas/#task_led1","text":"C\u00f3digos originais Vamos ter que ter esses trechos de c\u00f3digo em mente: Callback do bot\u00e3o 1 void but1_callback ( void ){ printf ( \"but_callback \\n \" ); BaseType_t xHigherPriorityTaskWoken = pdFALSE ; xSemaphoreGiveFromISR ( xSemaphore , & xHigherPriorityTaskWoken ); } 2. task led static void task_led ( void * pvParameters ) { xSemaphore = xSemaphoreCreateBinary (); /* ... init but1 .... */ for (;;) { if ( xSemaphoreTake ( xSemaphore , ( TickType_t ) 500 / portTICK_PERIOD_MS ) == pdTRUE ){ LED_Toggle ( LED0 ); } } } Essa tarefa deveria ser executada sempre que o bot\u00e3o 1 da placa OLED fosse pressionado, mas isso n\u00e3o deveria impedir que a task_led de tamb\u00e9m ser executada, o que muitos fizeram foi usar o mesmo sem\u00e1foro que j\u00e1 estava sendo usado pela task_led nesta task, da seguinte maneira: static void task_led1 ( void * pvParameters ) { for (;;) { if ( xSemaphoreTake ( xSemaphore , 500 / portTICK_PERIOD_MS )){ for ( int i = 0 ; i < n ; i ++ ){ pio_clear ( LED1_PIO , LED1_IDX_MASK ); vtaskDelay ( 500 ); pio_set ( LED1_PIO , LED1_IDX_MASK ); vtaskDelay ( 500 ); } } } } O problema disso \u00e9 que tanto a task_led quanto a task_led1 est\u00e3o compartilhando o mesmo sem\u00e1foro, e o sem\u00e1foro usado aqui \u00e9 do tipo bin\u00e1rio, ou seja, pode ser 0 ou 1 a primeira tarefa que consumir o sem\u00e1foro vai o tornar 0 e a segunda tarefa n\u00e3o vai ser executada corretamente, conforme diagrama a baixo: Existem duas solu\u00e7\u00f5es para esse problemas, a primeira seria a de usar um Counting Semaphores a outra \u00e9 a de usar um outro sem\u00e1foro para indicar para a nova tarefa que ela deve ser executada, para isso: Definir uma vari\u00e1vel global para o novo sem\u00e1foro: Fazer a fun\u00e7\u00e3o but1_callback liberar dois sem\u00e1foros Criar o sem\u00e1foro dentro da task_led1 Usar o sem\u00e1foro novo na task_led1 SemaphoreHandle_t xSemaphore; +SemaphoreHandle_t xSemaphore1; void but1_callback(void){ printf(\"but_callback \\n\"); BaseType_t xHigherPriorityTaskWoken = pdFALSE; xSemaphoreGiveFromISR(xSemaphore, &xHigherPriorityTaskWoken); + xSemaphoreGiveFromISR(xSemaphore1, &xHigherPriorityTaskWoken); } static void task_led1(void *pvParameters) { + xSemaphore1 = xSemaphoreCreateBinary(); for (;;) { + if( xSemaphoreTake(xSemaphore1, 500/portTICK_PERIOD_MS)){ for (int i=0;i<n;i++){ pio_clear(LED1_PIO, LED1_IDX_MASK); vtaskDelay(500); pio_set(LED1_PIO, LED1_IDX_MASK); vtaskDelay(500); } } } }","title":"task_led1"},{"location":"navigation/Labs/Lab_RTOS/Lab-RTOS/","text":"LAB - RTOS (freeRTOS) Pastas: Lab4-RTOS-PIO-IRQ Lab4-RTOS-IRQ-ADC ------------------------------------------------ Data LIMITE para entrega: 20/09/22 - 23h59 Warning Atualize o reposit\u00f3rio de exemplos: same70-examples antes de continuar. O reposit\u00f3rio est\u00e1 organizado por categorias: comunica\u00e7\u00e3o, demos, perif\u00e9ricos, screens, sensores, ... e assim por diante. Na primeira parte deste laborat\u00f3rio iremos trabalhar com o c\u00f3digo exemplo SAME70-examples/Perifericos-uC/RTOS-PIO-IRQ/ . Esse c\u00f3digo ser\u00e1 a base da primeira parte do laborat\u00f3rio. Na segunda parte, iremos trabalhar com o c\u00f3digo exemplo SAME70-examples/Perifericos-uC/RTOS-IRQ-ADC/ . Esse c\u00f3digo ser\u00e1 a base da segunda parte do laborat\u00f3rio. Embedded FM - epis\u00f3dio 175 How Hard Could It Be? Jean Labrosse of Micrium (@Micrium) spoke with us about writing a real time operating system (uC/OS), building a business, and caring about code quality. https://embedded.fm/episodes/175 Video Neste laborat\u00f3rio iremos trabalhar com o uso de um sistema operacional de tempo real (RTOS). O sistema operacional a ser utilizado \u00e9 o FreeRtos (www.freertos.org) , um sistema operacional muito utilizado pela industria, sendo o segundo sistema operacional ( 20% ) mais utilizado em projetos embarcados, perdendo s\u00f3 para o Linux . Progress Continuar ... LAB O laborat\u00f3rio consiste em: Executar uma demo de RTOS Entender e modificar o exemplo Praticar Setup OLED1 Plugue a placa OLED1 no EXT1, vamos usar seus bot\u00f5es e LEDs. Terminal Esse exemplo faz uso da comunica\u00e7\u00e3o UART para debug de c\u00f3digo (via printf), para acessar o terminal no microchip est\u00fadio clique em: No microchip studio: View Terminal Window Configure o terminal para a porta COM correta (verificar no windows) para operar com um BaudRate de 115200. Caso n\u00e3o tenha essa op\u00e7\u00e3o, instale o pacote extra do microchip studio Progress Continuar ... RTOS Para dicas de como usar o RTOS acesse: Util/Freertos PIO-IRQ-RTOS https://github.com/Insper/SAME70-examples/tree/master/Perifericos-uC/RTOS-PIO-IRQ Vamos usar esse c\u00f3digo exemplo para aprenderemos os principais recursos do RTOS, nele criamos duas tasks: task_but e task_led que se comunicam via uma fila. O bot\u00e3o da placa \u00e9 configurado para operar com interrup\u00e7\u00e3o de borda, liberando um sem\u00e1foro para a task_but , que processa a informa\u00e7\u00e3o e envia um novo valor de delay para a task_led : Executando Compile e grave o c\u00f3digo no uC Abra o e configure a UART (baudrate 115200). Veja o LED piscar! Aperte o bot\u00e3o da placa e veja a frequ\u00eancia mudar. Antes de seguir analise um pouco o c\u00f3digo e tente entender o que est\u00e1 acontecendo, para isso consulte a p\u00e1gina desse lab chamada de Teoria. Praticando - sem\u00e1foro Fa\u00e7a uma c\u00f3pia desse c\u00f3digo para Lab4-pio-irq-rtos e vamos mexer nele! A ideia aqui \u00e9 possibilitar diminuirmos a frequ\u00eancia atrav\u00e9s de outro bot\u00e3o! Para isso teremos que adicionar mais um sem\u00e1foro que ir\u00e1 se comunicar com a task but. Tarefa: Modifique o c\u00f3digo adicionando um bot\u00e3o da placa OLED (interrupcao, callback...) Crie um novo sem\u00e1foro e libere ele quando o bot\u00e3o novo for apertado. Na task but processe o sem\u00e1foro aumentado o valor da frequ\u00eancia Dicas: Voc\u00ea N\u00c3O deve criar outra task, tem que fazer tudo na task_but As interrup\u00e7\u00f5es de HW devem possuir prioridade maior que 4. Praticando - queue Agora vamos usar fila no lugar de sem\u00e1foro para comunicar os bot\u00f5es com a task_but . Tarefa: Crie uma mais uma fila Cada callback deve colocar o valor do incremento na fila (ou o id do bot\u00e3o) A task_but recebe o valor, faz o c\u00e1lculo e envia para a task_led Progress Continuar ... ADC-IRQ-RTOS https://github.com/Insper/SAME70-examples/tree/master/Perifericos-uC/RTOS-IRQ-ADC Outro exemplo que vamos usar como base \u00e9 o ADC-IRQ-RTOS que faz a leitura de um valor anal\u00f3gico do pino do uC, voc\u00ea deve ler o README que possui o diagrama de liga\u00e7\u00f5es e uma pequena explica\u00e7\u00e3o. Executando Leia o README do exemplo e ligue conforme indicado Compile e grave o c\u00f3digo no uC Abra o terminal e configure a UART (baudrate 115200). Aperte o bot\u00e3o da placa e veja a frequ\u00eancia mudar. Antes de seguir analise um pouco o c\u00f3digo e tente entender o que est\u00e1 acontecendo, analise a task, as interrup\u00e7\u00f5es e tamb\u00e9m o uso da fila. Praticando Fa\u00e7a uma c\u00f3pia desse c\u00f3digo para Lab4-adc-irq-rtos e vamos mexer nele! A ideia agora \u00e9 criarmos uma task intermedi\u00e1ria (task_proc) que ir\u00e1 fazer o processamento dos dados recebidos pelo ADC, conforme o diagrama atualizado a seguir: A task_proc dever\u00e1 calcular a m\u00e9dia m\u00f3vel (N=10) dos dados do ADC e ent\u00e3o enviar esses dados para para a task task_adc via uma nova fila, com o objetivo de ser exibido. A ideia da m\u00e9dia m\u00f3vel \u00e9 aplicar um filtro passa baixas para remover ru\u00eddos do sinal. Refer\u00eancia: https://www.analog.com/media/en/technical-documentation/dsp-book/dsp_book_ch15.pdf Tarefas/dicas: Modifique o c\u00f3digo adicionando a task_proc Fa\u00e7a a leitura do dado do AFEC nessa nova tarefa Crie uma nova fila, e envie o dado da task_proc para a task_adc (dado bruto, ainda sem processamento) Na task_adc exiba o dado via printf Agora na task proc calcule a m\u00e9dia m\u00f3vel e o envie para a task_adc. Ao terminar o lab preencha: Carregando\u2026 Projeto Agora que voc\u00eas j\u00e1 entendem um pouco melhor os recursos do RTOS podem e devem aplicar esses conceitos no projeto. Por exemplo, para os bot\u00f5es voc\u00eas podem usar sem\u00e1foros ou filas, para a leitura do valor anal\u00f3gico uma fila.","title":"Lab"},{"location":"navigation/Labs/Lab_RTOS/Lab-RTOS/#lab-rtos-freertos","text":"Pastas: Lab4-RTOS-PIO-IRQ Lab4-RTOS-IRQ-ADC ------------------------------------------------ Data LIMITE para entrega: 20/09/22 - 23h59 Warning Atualize o reposit\u00f3rio de exemplos: same70-examples antes de continuar. O reposit\u00f3rio est\u00e1 organizado por categorias: comunica\u00e7\u00e3o, demos, perif\u00e9ricos, screens, sensores, ... e assim por diante. Na primeira parte deste laborat\u00f3rio iremos trabalhar com o c\u00f3digo exemplo SAME70-examples/Perifericos-uC/RTOS-PIO-IRQ/ . Esse c\u00f3digo ser\u00e1 a base da primeira parte do laborat\u00f3rio. Na segunda parte, iremos trabalhar com o c\u00f3digo exemplo SAME70-examples/Perifericos-uC/RTOS-IRQ-ADC/ . Esse c\u00f3digo ser\u00e1 a base da segunda parte do laborat\u00f3rio. Embedded FM - epis\u00f3dio 175 How Hard Could It Be? Jean Labrosse of Micrium (@Micrium) spoke with us about writing a real time operating system (uC/OS), building a business, and caring about code quality. https://embedded.fm/episodes/175 Video Neste laborat\u00f3rio iremos trabalhar com o uso de um sistema operacional de tempo real (RTOS). O sistema operacional a ser utilizado \u00e9 o FreeRtos (www.freertos.org) , um sistema operacional muito utilizado pela industria, sendo o segundo sistema operacional ( 20% ) mais utilizado em projetos embarcados, perdendo s\u00f3 para o Linux . Progress Continuar ...","title":"LAB - RTOS (freeRTOS)"},{"location":"navigation/Labs/Lab_RTOS/Lab-RTOS/#lab","text":"O laborat\u00f3rio consiste em: Executar uma demo de RTOS Entender e modificar o exemplo Praticar","title":"LAB"},{"location":"navigation/Labs/Lab_RTOS/Lab-RTOS/#setup","text":"OLED1 Plugue a placa OLED1 no EXT1, vamos usar seus bot\u00f5es e LEDs. Terminal Esse exemplo faz uso da comunica\u00e7\u00e3o UART para debug de c\u00f3digo (via printf), para acessar o terminal no microchip est\u00fadio clique em: No microchip studio: View Terminal Window Configure o terminal para a porta COM correta (verificar no windows) para operar com um BaudRate de 115200. Caso n\u00e3o tenha essa op\u00e7\u00e3o, instale o pacote extra do microchip studio Progress Continuar ...","title":"Setup"},{"location":"navigation/Labs/Lab_RTOS/Lab-RTOS/#rtos","text":"Para dicas de como usar o RTOS acesse: Util/Freertos","title":"RTOS"},{"location":"navigation/Labs/Lab_RTOS/Lab-RTOS/#pio-irq-rtos","text":"https://github.com/Insper/SAME70-examples/tree/master/Perifericos-uC/RTOS-PIO-IRQ Vamos usar esse c\u00f3digo exemplo para aprenderemos os principais recursos do RTOS, nele criamos duas tasks: task_but e task_led que se comunicam via uma fila. O bot\u00e3o da placa \u00e9 configurado para operar com interrup\u00e7\u00e3o de borda, liberando um sem\u00e1foro para a task_but , que processa a informa\u00e7\u00e3o e envia um novo valor de delay para a task_led : Executando Compile e grave o c\u00f3digo no uC Abra o e configure a UART (baudrate 115200). Veja o LED piscar! Aperte o bot\u00e3o da placa e veja a frequ\u00eancia mudar. Antes de seguir analise um pouco o c\u00f3digo e tente entender o que est\u00e1 acontecendo, para isso consulte a p\u00e1gina desse lab chamada de Teoria. Praticando - sem\u00e1foro Fa\u00e7a uma c\u00f3pia desse c\u00f3digo para Lab4-pio-irq-rtos e vamos mexer nele! A ideia aqui \u00e9 possibilitar diminuirmos a frequ\u00eancia atrav\u00e9s de outro bot\u00e3o! Para isso teremos que adicionar mais um sem\u00e1foro que ir\u00e1 se comunicar com a task but. Tarefa: Modifique o c\u00f3digo adicionando um bot\u00e3o da placa OLED (interrupcao, callback...) Crie um novo sem\u00e1foro e libere ele quando o bot\u00e3o novo for apertado. Na task but processe o sem\u00e1foro aumentado o valor da frequ\u00eancia Dicas: Voc\u00ea N\u00c3O deve criar outra task, tem que fazer tudo na task_but As interrup\u00e7\u00f5es de HW devem possuir prioridade maior que 4. Praticando - queue Agora vamos usar fila no lugar de sem\u00e1foro para comunicar os bot\u00f5es com a task_but . Tarefa: Crie uma mais uma fila Cada callback deve colocar o valor do incremento na fila (ou o id do bot\u00e3o) A task_but recebe o valor, faz o c\u00e1lculo e envia para a task_led Progress Continuar ...","title":"PIO-IRQ-RTOS"},{"location":"navigation/Labs/Lab_RTOS/Lab-RTOS/#adc-irq-rtos","text":"https://github.com/Insper/SAME70-examples/tree/master/Perifericos-uC/RTOS-IRQ-ADC Outro exemplo que vamos usar como base \u00e9 o ADC-IRQ-RTOS que faz a leitura de um valor anal\u00f3gico do pino do uC, voc\u00ea deve ler o README que possui o diagrama de liga\u00e7\u00f5es e uma pequena explica\u00e7\u00e3o. Executando Leia o README do exemplo e ligue conforme indicado Compile e grave o c\u00f3digo no uC Abra o terminal e configure a UART (baudrate 115200). Aperte o bot\u00e3o da placa e veja a frequ\u00eancia mudar. Antes de seguir analise um pouco o c\u00f3digo e tente entender o que est\u00e1 acontecendo, analise a task, as interrup\u00e7\u00f5es e tamb\u00e9m o uso da fila. Praticando Fa\u00e7a uma c\u00f3pia desse c\u00f3digo para Lab4-adc-irq-rtos e vamos mexer nele! A ideia agora \u00e9 criarmos uma task intermedi\u00e1ria (task_proc) que ir\u00e1 fazer o processamento dos dados recebidos pelo ADC, conforme o diagrama atualizado a seguir: A task_proc dever\u00e1 calcular a m\u00e9dia m\u00f3vel (N=10) dos dados do ADC e ent\u00e3o enviar esses dados para para a task task_adc via uma nova fila, com o objetivo de ser exibido. A ideia da m\u00e9dia m\u00f3vel \u00e9 aplicar um filtro passa baixas para remover ru\u00eddos do sinal. Refer\u00eancia: https://www.analog.com/media/en/technical-documentation/dsp-book/dsp_book_ch15.pdf Tarefas/dicas: Modifique o c\u00f3digo adicionando a task_proc Fa\u00e7a a leitura do dado do AFEC nessa nova tarefa Crie uma nova fila, e envie o dado da task_proc para a task_adc (dado bruto, ainda sem processamento) Na task_adc exiba o dado via printf Agora na task proc calcule a m\u00e9dia m\u00f3vel e o envie para a task_adc. Ao terminar o lab preencha: Carregando\u2026","title":"ADC-IRQ-RTOS"},{"location":"navigation/Labs/Lab_RTOS/Lab-RTOS/#projeto","text":"Agora que voc\u00eas j\u00e1 entendem um pouco melhor os recursos do RTOS podem e devem aplicar esses conceitos no projeto. Por exemplo, para os bot\u00f5es voc\u00eas podem usar sem\u00e1foros ou filas, para a leitura do valor anal\u00f3gico uma fila.","title":"Projeto"},{"location":"navigation/Labs/Lab_RTOS/Teoria/","text":"PIO-IRQ-RTOS Vamos usar esse c\u00f3digo exemplo para aprenderemos os principais recursos deo RTOS, nele criamos duas tasks: task_but e task_led que se comunicam via uma fila. O bot\u00e3o da placa \u00e9 configurado para operar com interrupc\u00e3o de boarda, liberando um sem\u00e1foro para a task_but , que processa a informac\u00e3o e envia um novo valor de delay para a task_led : Executando Compile e grave o c\u00f3digo no uC Abra o terminal e configure a UART (baudrate 115200). Veja o LED piscar! Aperte o bot\u00e3o da placa e veja a frequ\u00eancia mudar. Antes de seguir analise um pouco o c\u00f3digo e tente enteder o que est\u00e1 acontecendo. Tasks Tasks s\u00e3o pequenos programas executados pelo sistema operacional, cada tarefa possui uma stack reservada para ela e \u00e9 gerenciada pelo sistema operacional. Notem que toda task \u00e9 uma fun\u00e7\u00e3o que n\u00e3o retorna e possui la\u00e7o infinito ( for (;;){} ), tasks em um RTOS n\u00e3o devem retornar , elas executam como se estivessem exclusividade da CPU (assim como um c\u00f3digo bare-metal que n\u00e3o deve retornar da fun\u00e7\u00e3o main ). A fun\u00e7\u00e3o vTaskDelay() faz com que a tarefa fique em estado de blocked (permitindo que outras tarefas utilizem a CPU) por um determinado n\u00famero de ticks . Essa fun\u00e7\u00e3o \u00e9 diferente da delay_ms() que bloqueia a CPU para sua execu\u00e7\u00e3o. Deve-se evitar o uso de fun\u00e7\u00f5es de delay baseadas em \"queimar\" clocks na tarefas de um RTOS, j\u00e1 que elas agem como um trecho de c\u00f3digo a ser executada. A fun\u00e7\u00e3o vTaskDelay() faz com que o RTOS libere processamento para outras tarefas durante o tempo especificado em sua chamada. Esse valor \u00e9 determinado em ticks . Podemos traduzir ticks para ms , usando o define portTICK_PERIOD_MS como no exemplo a seguir } /* suspende por delayMs */ vTaskDelay(delayTicks / portTICK_PERIOD_MS); O Tick de um RTOS define quantas fezes por segundo o escalonador ir\u00e1 executar o algoritmo de mudan\u00e7a de tarefas, no ARM o tick \u00e9 implementado utilizando um timer do pr\u00f3prio CORE da ARM chamado de system clock ou systick , criado para essa fun\u00e7\u00e3o. Por exemplo, um RTOS que opera com um tick de 10ms ir\u00e1 decidir pelo chaveamento de suas tarefas 100 vezes por segundo, j\u00e1 um tick configurado para 1ms ir\u00e1 executar o escalonador a uma taxa de 1000 vezes por segundo. Trechos de c\u00f3digo que necessitam executar a uma taxa maior que 1000 vezes por segundo (tick = 1ms) n\u00e3o devem ser implementados em tasks do RTOS mas sim via interrup\u00e7\u00e3o de timer. Note O impacto do tick na fun\u00e7\u00e3o vTaskDelay \u00e9 que a mesma s\u00f3 pode ser chamada com m\u00faltiplos inteiros referente ao tick. N\u00e3o temos uma resolu\u00e7\u00e3o t\u00e3o boa quanto o TimerCounter ou RTT. Quanto maior a frequ\u00eancia de chaveamento mais vezes/segundo o OS necessita salvar e recuperar o contexto, diminuindo assim sua efici\u00eancia. Frequ\u00eancia m\u00e1xima recomendada para o freertos em uma ARM e a de 1000 Hz Estados de uma task A m\u00e1quina de estados a seguir ilustra os poss\u00edveis estados de uma task assim como as transi\u00e7\u00f5es. Para saber mais a respeito acesse: https://www.freertos.org/RTOS-task-states.html Progress Continuar ... Criando tarefas Criar uma tarefa \u00e9 similar ao de inicializar um programa em um sistema operacional, mas no caso devemos indicar para o RTOS quais \"fun\u00e7\u00f5es\" ir\u00e3o se comportar como pequenos programas (tarefas). Para isso devemos chamar a fun\u00e7\u00e3o xTaskCreate que possui a seguinte estrutura: Leitura necess[aria] Acesse e leia a documenta;\u00e1o do freertos sobre cria;\u00e1o de tasks: https://www.freertos.org/a00125.html A fun\u00e7\u00e3o utilizada para criar uma task no freertos \u00e9: /** * task. h * BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, uint16_t usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pvCreatedTask ); * * Create a new task and add it to the list of tasks that are ready to run. * * xTaskCreate() can only be used to create a task that has unrestricted * access to the entire microcontroller memory map. Systems that include MPU * support can alternatively create an MPU constrained task using * xTaskCreateRestricted(). * */ A cria\u00e7\u00e3o das tasks but e LED s\u00e3o feitas da seguinte maneira (na fun\u00e7\u00e3o main ): /* Create task to make led blink */ if ( xTaskCreate ( task_led , \"Led\" , TASK_LED_STACK_SIZE , NULL , TASK_LED_STACK_PRIORITY , NULL ) != pdPASS ) { printf ( \"Failed to create test led task \\r\\n \" ); } /* Create task to monitor processor activity */ if ( xTaskCreate ( task_but , \"BUT\" , TASK_BUT_STACK_SIZE , NULL , TASK_BUT_STACK_PRIORITY , NULL ) != pdPASS ) { printf ( \"Failed to create UartTx task \\r\\n \" ); } O primeiro par\u00e2metro da xTaskCreate \u00e9 o ponteiro da fun\u00e7\u00e3o que ser\u00e1 lidada como uma task. A segunda \u00e9 o nome dessa tarefa, a terceira \u00e9 o tamanho da stack que cada task vai possuir, o quarto seria um ponteiro para uma estrutura de dados que poderia ser passada para a task em sua cria\u00e7\u00e3o, o quinto a sua prioridade e o \u00faltimo \u00e9 um ponteiro e retorna uma vari\u00e1vel que pode ser usada para gerencias a task (deletar, pausar). O tamanho da stack da tarefa e sua prioridade est\u00e3o definidos no pr\u00f3prio main.c : #define TASK_LED_STACK_SIZE (1024 / sizeof(portSTACK_TYPE)) #define TASK_LED_STACK_PRIORITY (tskIDLE_PRIORITY) #define TASK_BUT_STACK_SIZE (2048 / sizeof(portSTACK_TYPE)) #define TASK_BUT_STACK_PRIORITY (tskIDLE_PRIORITY) A cada tarefa pode ser atribu\u00edda uma prioridade que vai de 0 at\u00e9 configMAX_PRIORITIES - 1 , onde configMAX_PRIORITIES est\u00e1 definido no arquivo de configura\u00e7\u00e3o FreeRTOSConfig.h , 0 \u00e9 menor prioridade . taskIDLE_PRIORITY \u00c9 a menor prioridade! #define tskIDLE_PRIORITY ( ( UBaseType_t ) 0U ) Caso queira definir uma task de maior prioridade fa\u00e7a da seguinte maneira: #define TASK_LED_PRIORITY (taskIDLE_PRIORITY + 1) Stack size Uma das d\u00favidas mais comum no uso de RTOS \u00e9 o quanto de espa\u00e7o devemos alocar para cada tarefa, e essa \u00e9 uma pergunta que n\u00e3o existe um resposta correta, caso esse valor seja muito grande podemos estar alocando um espa\u00e7o extra que nunca ser\u00e1 utilizado e pode fazer falta para a aplica\u00e7\u00e3o. E se caso pequena, podemos ter um stack overflow e o firmware parar de funcionar. A melhor solu\u00e7\u00e3o \u00e9 a de executar o programa e analisar o consumo da stack pelas tasks ao longo de sua execu\u00e7\u00e3o, tendo assim maiores par\u00e2metros para a sua configura\u00e7\u00e3o. No curso vamos usar 2048 como padr\u00e3o para o stack size Power Save mode? Uma forma muito simples de conseguirmos diminuir o consumo energ\u00e9tico de um sistema embarcado com RTOS \u00e9 o de ativar os modos de baixo consumo energ\u00e9tico (powersave/ sleep mode) quando o SO estiver na tarefa idle . A tarefa idle \u00e9 aquela executada quando nenhuma outra tarefa est\u00e1 em execu\u00e7\u00e3o. Sempre que essa tarefa idle for chamada a o RTOS ir\u00e1 executar a fun\u00e7\u00e3o a seguir j\u00e1 definida no main.c : /** * \\brief This function is called by FreeRTOS idle task */ extern void vApplicationIdleHook ( void ) { } Note que devemos entrar em um modo de sleep que o timer utilizado pelo tick consiga ainda acordar a CPU executar, caso contr\u00e1rio o RTOS n\u00e3o ir\u00e1 operar corretamente j\u00e1 que o escalonador n\u00e3o ser\u00e1 chamado. O timer usado pelo escalonador \u00e9 o System Timer, SysTick . Comunicacao RTOS Uma das principais vantagens de usar um sistema operacional \u00e9 o de usar ferramentas de comunica\u00e7\u00e3o entre tarefas ou entre ISR e tarefas, em um c\u00f3digo baremetal fazemos esse comunica\u00e7\u00e3o via vari\u00e1veis globais (buffers, flags, ...), essa implementa\u00e7\u00e3o carece de funcionalidades que o RTOS ir\u00e1 suprir, tais como: Sem\u00e1foro (semaphore) \u00c9 como uma flag bin\u00e1ria, permitindo ou n\u00e3o a execu\u00e7\u00e3o de uma task, funciona para sincroniza\u00e7\u00e3o de tarefas ou para exclus\u00e3o m\u00fatua (multual exclusion), sem nenhum tipo de prioridade. Mutex: Similar aos sem\u00e1foros por\u00e9m com prioridade de execu\u00e7\u00e3o (mutex alteram a prioridade da tarefa) MailBox ou Queues: Usado para enviar dados entre tarefas ou entre ISR e Tasks [5] : https://www.freertos.org/Embedded-RTOS-Binary-Semaphores.html Semaphore No nosso exemplo o sem\u00e1foro serve para avisar a task_but que um bot\u00e3o foi apertado: Consulta: xSemaphoreGiveFromISR Agora vamos modificar a fun\u00e7\u00e3o task_led para inicializar um sem\u00e1foro, e configura o bot\u00e3o da placa OLED para funcionar com interrup\u00e7\u00e3o chamanado a fun\u00e7\u00e3o: but1_callback sempre que houver uma borda de descida no pino que l\u00ea o bot\u00e3o. A tarefa agora fica no while(1) aguardando o sem\u00e1foro xSemaphore que ser\u00e1 liberado pelo callback. Sempre que houver a leitura do sem\u00e1foro, o mesmo torna-se vermelho. Vis\u00e3o geral Para implementarmos um sem\u00e1foro precisamos primeiramente definir uma vari\u00e1vel global que ser\u00e1 utilizada pelo sistema operacional para definir o endere\u00e7o desse sem\u00e1foro (global): SemaphoreHandle_t xSemaphoreBut ; Devemos antes de usar o sem\u00e1foro, fazermos sua cria\u00e7\u00e3o/inicializa\u00e7\u00e3o. De prefer\u00eancia na main: /* Attempt to create a semaphore. */ xSemaphoreBut = xSemaphoreCreateBinary (); Uma vez criado o sem\u00e1foro podemos esperar a libera\u00e7\u00e3o do sem\u00e1foro via a fun\u00e7\u00e3o: xSemaphoreTake ( xSemaphoreBut , Tick ); xSemaphoreBut O sem\u00e1foro a ser utilizado Tick : timeout (em ticks) que a fun\u00e7\u00e3o deve liberar caso o sem\u00e1foro n\u00e3o chegue. Se passado o valor 0, a fun\u00e7\u00e3o ir\u00e1 bloquear at\u00e9 a chegada do sem\u00e1foro. Para liberarmos o sem\u00e1foro devemos usar a fun\u00e7\u00e3o de dentro da interrup\u00e7\u00e3o/callback: xSemaphoreGiveFromISR (...); Note Note o ISR no final da fun\u00e7\u00e3o, isso quer dizer que estamos liberando um sem\u00e1foro de dentro de uma interrup\u00e7\u00e3o. Caso a libera\u00e7\u00e3o do sem\u00e1foro n\u00e3o seja de dentro de uma interrup\u00e7\u00e3o, basta utilizar a fun\u00e7\u00e3o xSemaphoreGive Queues Mailbox/ queue \u00e9 uma das maneiras de enviarmos dados entre tarefa em um sistema operacional, com ele podemos comunicar interrup\u00e7\u00e3o com tarefa e tarefa com tarefa, enviando valores (diferente do sem\u00e1foro que s\u00f3 funciona de forma bin\u00e1ria). Note Queues are the primary form of intertask communications. They can be used to send messages between tasks, and between interrupts and tasks. In most cases they are used as thread safe FIFO (First In First Out) buffers with new data being sent to the back of the queue, although data can also be sent to the front. Writing to and reading from a queue. In this example the queue was created to hold 5 items, and the queue never becomes full. Material retirado do site: https://www.freertos.org/Embedded-RTOS-Queues.html Tip Para mais informa\u00e7\u00f5es ler o site do freeRTOS sobre filas: https://www.freertos.org/Embedded-RTOS-Queues.html https://freertos.org/a00018.html Tamb\u00e9m temos uma sec\u00e7\u00e3o na nossa p\u00e1gina de dicas com exemplo de fila: https://insper.github.io/ComputacaoEmbarcada/Util-freertos/#fila No nosso exemplo usamos a queue para comunicar a t task_but com a task_led passando por ela o valor do delay a ser processado. Uma fila pode ser de diversos tamanhos e largura, a ser definida na criac\u00e3o! Isso permite o envio de mais de um dado por ela, como por exemplo um struct, ou um array.","title":"Teoria"},{"location":"navigation/Labs/Lab_RTOS/Teoria/#pio-irq-rtos","text":"Vamos usar esse c\u00f3digo exemplo para aprenderemos os principais recursos deo RTOS, nele criamos duas tasks: task_but e task_led que se comunicam via uma fila. O bot\u00e3o da placa \u00e9 configurado para operar com interrupc\u00e3o de boarda, liberando um sem\u00e1foro para a task_but , que processa a informac\u00e3o e envia um novo valor de delay para a task_led : Executando Compile e grave o c\u00f3digo no uC Abra o terminal e configure a UART (baudrate 115200). Veja o LED piscar! Aperte o bot\u00e3o da placa e veja a frequ\u00eancia mudar. Antes de seguir analise um pouco o c\u00f3digo e tente enteder o que est\u00e1 acontecendo.","title":"PIO-IRQ-RTOS"},{"location":"navigation/Labs/Lab_RTOS/Teoria/#tasks","text":"Tasks s\u00e3o pequenos programas executados pelo sistema operacional, cada tarefa possui uma stack reservada para ela e \u00e9 gerenciada pelo sistema operacional. Notem que toda task \u00e9 uma fun\u00e7\u00e3o que n\u00e3o retorna e possui la\u00e7o infinito ( for (;;){} ), tasks em um RTOS n\u00e3o devem retornar , elas executam como se estivessem exclusividade da CPU (assim como um c\u00f3digo bare-metal que n\u00e3o deve retornar da fun\u00e7\u00e3o main ). A fun\u00e7\u00e3o vTaskDelay() faz com que a tarefa fique em estado de blocked (permitindo que outras tarefas utilizem a CPU) por um determinado n\u00famero de ticks . Essa fun\u00e7\u00e3o \u00e9 diferente da delay_ms() que bloqueia a CPU para sua execu\u00e7\u00e3o. Deve-se evitar o uso de fun\u00e7\u00f5es de delay baseadas em \"queimar\" clocks na tarefas de um RTOS, j\u00e1 que elas agem como um trecho de c\u00f3digo a ser executada. A fun\u00e7\u00e3o vTaskDelay() faz com que o RTOS libere processamento para outras tarefas durante o tempo especificado em sua chamada. Esse valor \u00e9 determinado em ticks . Podemos traduzir ticks para ms , usando o define portTICK_PERIOD_MS como no exemplo a seguir } /* suspende por delayMs */ vTaskDelay(delayTicks / portTICK_PERIOD_MS); O Tick de um RTOS define quantas fezes por segundo o escalonador ir\u00e1 executar o algoritmo de mudan\u00e7a de tarefas, no ARM o tick \u00e9 implementado utilizando um timer do pr\u00f3prio CORE da ARM chamado de system clock ou systick , criado para essa fun\u00e7\u00e3o. Por exemplo, um RTOS que opera com um tick de 10ms ir\u00e1 decidir pelo chaveamento de suas tarefas 100 vezes por segundo, j\u00e1 um tick configurado para 1ms ir\u00e1 executar o escalonador a uma taxa de 1000 vezes por segundo. Trechos de c\u00f3digo que necessitam executar a uma taxa maior que 1000 vezes por segundo (tick = 1ms) n\u00e3o devem ser implementados em tasks do RTOS mas sim via interrup\u00e7\u00e3o de timer. Note O impacto do tick na fun\u00e7\u00e3o vTaskDelay \u00e9 que a mesma s\u00f3 pode ser chamada com m\u00faltiplos inteiros referente ao tick. N\u00e3o temos uma resolu\u00e7\u00e3o t\u00e3o boa quanto o TimerCounter ou RTT. Quanto maior a frequ\u00eancia de chaveamento mais vezes/segundo o OS necessita salvar e recuperar o contexto, diminuindo assim sua efici\u00eancia. Frequ\u00eancia m\u00e1xima recomendada para o freertos em uma ARM e a de 1000 Hz Estados de uma task A m\u00e1quina de estados a seguir ilustra os poss\u00edveis estados de uma task assim como as transi\u00e7\u00f5es. Para saber mais a respeito acesse: https://www.freertos.org/RTOS-task-states.html Progress Continuar ...","title":"Tasks"},{"location":"navigation/Labs/Lab_RTOS/Teoria/#criando-tarefas","text":"Criar uma tarefa \u00e9 similar ao de inicializar um programa em um sistema operacional, mas no caso devemos indicar para o RTOS quais \"fun\u00e7\u00f5es\" ir\u00e3o se comportar como pequenos programas (tarefas). Para isso devemos chamar a fun\u00e7\u00e3o xTaskCreate que possui a seguinte estrutura: Leitura necess[aria] Acesse e leia a documenta;\u00e1o do freertos sobre cria;\u00e1o de tasks: https://www.freertos.org/a00125.html A fun\u00e7\u00e3o utilizada para criar uma task no freertos \u00e9: /** * task. h * BaseType_t xTaskCreate( TaskFunction_t pvTaskCode, const char * const pcName, uint16_t usStackDepth, void *pvParameters, UBaseType_t uxPriority, TaskHandle_t *pvCreatedTask ); * * Create a new task and add it to the list of tasks that are ready to run. * * xTaskCreate() can only be used to create a task that has unrestricted * access to the entire microcontroller memory map. Systems that include MPU * support can alternatively create an MPU constrained task using * xTaskCreateRestricted(). * */ A cria\u00e7\u00e3o das tasks but e LED s\u00e3o feitas da seguinte maneira (na fun\u00e7\u00e3o main ): /* Create task to make led blink */ if ( xTaskCreate ( task_led , \"Led\" , TASK_LED_STACK_SIZE , NULL , TASK_LED_STACK_PRIORITY , NULL ) != pdPASS ) { printf ( \"Failed to create test led task \\r\\n \" ); } /* Create task to monitor processor activity */ if ( xTaskCreate ( task_but , \"BUT\" , TASK_BUT_STACK_SIZE , NULL , TASK_BUT_STACK_PRIORITY , NULL ) != pdPASS ) { printf ( \"Failed to create UartTx task \\r\\n \" ); } O primeiro par\u00e2metro da xTaskCreate \u00e9 o ponteiro da fun\u00e7\u00e3o que ser\u00e1 lidada como uma task. A segunda \u00e9 o nome dessa tarefa, a terceira \u00e9 o tamanho da stack que cada task vai possuir, o quarto seria um ponteiro para uma estrutura de dados que poderia ser passada para a task em sua cria\u00e7\u00e3o, o quinto a sua prioridade e o \u00faltimo \u00e9 um ponteiro e retorna uma vari\u00e1vel que pode ser usada para gerencias a task (deletar, pausar). O tamanho da stack da tarefa e sua prioridade est\u00e3o definidos no pr\u00f3prio main.c : #define TASK_LED_STACK_SIZE (1024 / sizeof(portSTACK_TYPE)) #define TASK_LED_STACK_PRIORITY (tskIDLE_PRIORITY) #define TASK_BUT_STACK_SIZE (2048 / sizeof(portSTACK_TYPE)) #define TASK_BUT_STACK_PRIORITY (tskIDLE_PRIORITY) A cada tarefa pode ser atribu\u00edda uma prioridade que vai de 0 at\u00e9 configMAX_PRIORITIES - 1 , onde configMAX_PRIORITIES est\u00e1 definido no arquivo de configura\u00e7\u00e3o FreeRTOSConfig.h , 0 \u00e9 menor prioridade . taskIDLE_PRIORITY \u00c9 a menor prioridade! #define tskIDLE_PRIORITY ( ( UBaseType_t ) 0U ) Caso queira definir uma task de maior prioridade fa\u00e7a da seguinte maneira: #define TASK_LED_PRIORITY (taskIDLE_PRIORITY + 1) Stack size Uma das d\u00favidas mais comum no uso de RTOS \u00e9 o quanto de espa\u00e7o devemos alocar para cada tarefa, e essa \u00e9 uma pergunta que n\u00e3o existe um resposta correta, caso esse valor seja muito grande podemos estar alocando um espa\u00e7o extra que nunca ser\u00e1 utilizado e pode fazer falta para a aplica\u00e7\u00e3o. E se caso pequena, podemos ter um stack overflow e o firmware parar de funcionar. A melhor solu\u00e7\u00e3o \u00e9 a de executar o programa e analisar o consumo da stack pelas tasks ao longo de sua execu\u00e7\u00e3o, tendo assim maiores par\u00e2metros para a sua configura\u00e7\u00e3o. No curso vamos usar 2048 como padr\u00e3o para o stack size","title":"Criando tarefas"},{"location":"navigation/Labs/Lab_RTOS/Teoria/#power-save-mode","text":"Uma forma muito simples de conseguirmos diminuir o consumo energ\u00e9tico de um sistema embarcado com RTOS \u00e9 o de ativar os modos de baixo consumo energ\u00e9tico (powersave/ sleep mode) quando o SO estiver na tarefa idle . A tarefa idle \u00e9 aquela executada quando nenhuma outra tarefa est\u00e1 em execu\u00e7\u00e3o. Sempre que essa tarefa idle for chamada a o RTOS ir\u00e1 executar a fun\u00e7\u00e3o a seguir j\u00e1 definida no main.c : /** * \\brief This function is called by FreeRTOS idle task */ extern void vApplicationIdleHook ( void ) { } Note que devemos entrar em um modo de sleep que o timer utilizado pelo tick consiga ainda acordar a CPU executar, caso contr\u00e1rio o RTOS n\u00e3o ir\u00e1 operar corretamente j\u00e1 que o escalonador n\u00e3o ser\u00e1 chamado. O timer usado pelo escalonador \u00e9 o System Timer, SysTick .","title":"Power Save mode?"},{"location":"navigation/Labs/Lab_RTOS/Teoria/#comunicacao-rtos","text":"Uma das principais vantagens de usar um sistema operacional \u00e9 o de usar ferramentas de comunica\u00e7\u00e3o entre tarefas ou entre ISR e tarefas, em um c\u00f3digo baremetal fazemos esse comunica\u00e7\u00e3o via vari\u00e1veis globais (buffers, flags, ...), essa implementa\u00e7\u00e3o carece de funcionalidades que o RTOS ir\u00e1 suprir, tais como: Sem\u00e1foro (semaphore) \u00c9 como uma flag bin\u00e1ria, permitindo ou n\u00e3o a execu\u00e7\u00e3o de uma task, funciona para sincroniza\u00e7\u00e3o de tarefas ou para exclus\u00e3o m\u00fatua (multual exclusion), sem nenhum tipo de prioridade. Mutex: Similar aos sem\u00e1foros por\u00e9m com prioridade de execu\u00e7\u00e3o (mutex alteram a prioridade da tarefa) MailBox ou Queues: Usado para enviar dados entre tarefas ou entre ISR e Tasks [5] : https://www.freertos.org/Embedded-RTOS-Binary-Semaphores.html","title":"Comunicacao RTOS"},{"location":"navigation/Labs/Lab_RTOS/Teoria/#semaphore","text":"No nosso exemplo o sem\u00e1foro serve para avisar a task_but que um bot\u00e3o foi apertado: Consulta: xSemaphoreGiveFromISR Agora vamos modificar a fun\u00e7\u00e3o task_led para inicializar um sem\u00e1foro, e configura o bot\u00e3o da placa OLED para funcionar com interrup\u00e7\u00e3o chamanado a fun\u00e7\u00e3o: but1_callback sempre que houver uma borda de descida no pino que l\u00ea o bot\u00e3o. A tarefa agora fica no while(1) aguardando o sem\u00e1foro xSemaphore que ser\u00e1 liberado pelo callback. Sempre que houver a leitura do sem\u00e1foro, o mesmo torna-se vermelho. Vis\u00e3o geral Para implementarmos um sem\u00e1foro precisamos primeiramente definir uma vari\u00e1vel global que ser\u00e1 utilizada pelo sistema operacional para definir o endere\u00e7o desse sem\u00e1foro (global): SemaphoreHandle_t xSemaphoreBut ; Devemos antes de usar o sem\u00e1foro, fazermos sua cria\u00e7\u00e3o/inicializa\u00e7\u00e3o. De prefer\u00eancia na main: /* Attempt to create a semaphore. */ xSemaphoreBut = xSemaphoreCreateBinary (); Uma vez criado o sem\u00e1foro podemos esperar a libera\u00e7\u00e3o do sem\u00e1foro via a fun\u00e7\u00e3o: xSemaphoreTake ( xSemaphoreBut , Tick ); xSemaphoreBut O sem\u00e1foro a ser utilizado Tick : timeout (em ticks) que a fun\u00e7\u00e3o deve liberar caso o sem\u00e1foro n\u00e3o chegue. Se passado o valor 0, a fun\u00e7\u00e3o ir\u00e1 bloquear at\u00e9 a chegada do sem\u00e1foro. Para liberarmos o sem\u00e1foro devemos usar a fun\u00e7\u00e3o de dentro da interrup\u00e7\u00e3o/callback: xSemaphoreGiveFromISR (...); Note Note o ISR no final da fun\u00e7\u00e3o, isso quer dizer que estamos liberando um sem\u00e1foro de dentro de uma interrup\u00e7\u00e3o. Caso a libera\u00e7\u00e3o do sem\u00e1foro n\u00e3o seja de dentro de uma interrup\u00e7\u00e3o, basta utilizar a fun\u00e7\u00e3o xSemaphoreGive","title":"Semaphore"},{"location":"navigation/Labs/Lab_RTOS/Teoria/#queues","text":"Mailbox/ queue \u00e9 uma das maneiras de enviarmos dados entre tarefa em um sistema operacional, com ele podemos comunicar interrup\u00e7\u00e3o com tarefa e tarefa com tarefa, enviando valores (diferente do sem\u00e1foro que s\u00f3 funciona de forma bin\u00e1ria). Note Queues are the primary form of intertask communications. They can be used to send messages between tasks, and between interrupts and tasks. In most cases they are used as thread safe FIFO (First In First Out) buffers with new data being sent to the back of the queue, although data can also be sent to the front. Writing to and reading from a queue. In this example the queue was created to hold 5 items, and the queue never becomes full. Material retirado do site: https://www.freertos.org/Embedded-RTOS-Queues.html Tip Para mais informa\u00e7\u00f5es ler o site do freeRTOS sobre filas: https://www.freertos.org/Embedded-RTOS-Queues.html https://freertos.org/a00018.html Tamb\u00e9m temos uma sec\u00e7\u00e3o na nossa p\u00e1gina de dicas com exemplo de fila: https://insper.github.io/ComputacaoEmbarcada/Util-freertos/#fila No nosso exemplo usamos a queue para comunicar a t task_but com a task_led passando por ela o valor do delay a ser processado. Uma fila pode ser de diversos tamanhos e largura, a ser definida na criac\u00e3o! Isso permite o envio de mais de um dado por ela, como por exemplo um struct, ou um array.","title":"Queues"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/","text":"LAB - RTOS - ADC Neste laborat\u00f3rio iremos trabalhar com convers\u00e3o anal\u00f3gica digital, vamos aprender como usar um recurso do rtos chamado de fila. LAB Pasta Lab6-RTOS-ADC Executar exemplo convers\u00e3o anal\u00f3gica Incorporar exemplo ADC no RTOS com OLED Estruturar tasks Criar queue de comunica\u00e7\u00e3o entre IRQ e tasks In\u00edcio Conex\u00f5es EXT1: OLED Potenci\u00f4metro no PD30 conforme exemplo SAME70-examples/Perifericos-uC/AFEC-Pin/ C\u00f3digo exemplo Atualizem o reposit\u00f3rio SAME70-Examples antes de continuar Vamos usar como base o c\u00f3digo Screens/RTOS-OLED-Xplained-Pro , copie para o seu reposit\u00f3rio de entregas e renomeia para: Lab6-RTOS-ADC Exemplo AFEC Abra o exemplo do AFEC-Pin localizado em SAME70-examples/Perifericos-uC/AFEC-Pin/ , leia o README desse exemplo e o execute na sua placa. Note Note que ser\u00e1 necess\u00e1rio conectar o potenci\u00f4metro ao kit, conforme indica\u00e7\u00e3o do README. Incorporando AFEC ao RTOS Vamos incorporar o exemplo do AFEC ao c\u00f3digo do OLED com RTOS, para isso iremos criar uma tarefa que ser\u00e1 respons\u00e1vel por ler o valor do AFEC. Modifique Adicione no ASF o driver do AFEC Traga as fun\u00e7\u00f5es, defines e vari\u00e1veis globais do exemplo AFEC-PIN vari\u00e1veis globais: g_ defines config_afec AFEC_pot_Callback() Compile o c\u00f3digo para ver se est\u00e1 ok Agora vamos criar uma task no RTOS para lidar com a leitura do AFEC, a tarefa vai ter a implementa\u00e7\u00e3o a seguir: void task_adc ( void ){ /* inicializa e configura adc */ config_AFEC_pot ( AFEC_POT , AFEC_POT_ID , AFEC_POT_CHANNEL , AFEC_pot_Callback ); /* Selecina canal e inicializa convers\u00e3o */ afec_channel_enable ( AFEC_POT , AFEC_POT_CHANNEL ); afec_start_software_conversion ( AFEC_POT ); while ( 1 ){ if ( g_is_conversion_done ){ g_is_conversion_done = 0 ; printf ( \"%d \\n \" , g_ul_value ); delay_ms ( 500 ); /* Selecina canal e inicializa convers\u00e3o */ afec_channel_enable ( AFEC_POT , AFEC_POT_CHANNEL ); afec_start_software_conversion ( AFEC_POT ); } } } Note que a task \u00e9 praticamente igual ao main() do exemplo sem RTOS, isso est\u00e1 errado pois ainda usa delay_ms e fica verificando uma flag ( g_is_conversion_done ) no lugar de usar sem\u00e1foro, mas serve como um bom come\u00e7o. Agora \u00e9 necess\u00e1rio modificar a fun\u00e7\u00e3o main para que o freeRTOS crie essa tareafa: /* Create task to handler LCD */ if ( xTaskCreate ( task_adc , \"adc\" , TASK_LCD_STACK_SIZE , NULL , TASK_LCD_STACK_PRIORITY , NULL ) != pdPASS ) { printf ( \"Failed to create test adc task \\r\\n \" ); } Modifique Crie a task task_adc conforme exemplo Inicialize a task no RTOS Abra o terminal e note que est\u00e1 funcionando! Warning Essa task continua usando uma flag que \u00e9 alterada do callback do AFEC para indicar quando o valor est\u00e1 pronto, isso n\u00e3o \u00e9 bom e vamos mudar mais para frente! Usa delay_ms no lugar do vstaskDelay. Diagrama Melhorando Agora vamos melhorar isso, come\u00e7ando por trocar o delay pelo delay do freertos. Tarefa Substitua o delay_ms pelo delay do freeRTOS Por que isso \u00e9 importante? queue Mailbox/ queue \u00e9 uma das maneiras de enviarmos dados entre tarefa em um sistema operacional, com ele podemos comunicar interrup\u00e7\u00e3o com tarefa e tarefa com tarefa, enviando valores (diferente do sem\u00e1foro que s\u00f3 funciona de forma bin\u00e1ria). Note Queues are the primary form of intertask communications. They can be used to send messages between tasks, and between interrupts and tasks. In most cases they are used as thread safe FIFO (First In First Out) buffers with new data being sent to the back of the queue, although data can also be sent to the front. Writing to and reading from a queue. In this example the queue was created to hold 5 items, and the queue never becomes full. Material retirado do site: https://www.freertos.org/Embedded-RTOS-Queues.html Tip Para mais informa\u00e7\u00f5es ler o site do freeRTOS sobre filas: https://www.freertos.org/Embedded-RTOS-Queues.html https://freertos.org/a00018.html Tip Temos uma sec\u00e7\u00e3o na nossa p\u00e1gina de dicas com exemplo de fila: https://insper.github.io/ComputacaoEmbarcada/Util-freertos/#fila Modificando firmware Iremos agora come\u00e7ar a modificar o firmware criando um fila para comunicar a tarefa task_adc com a tarefa task_oled . Fila Vamos criar um queue chamado de xQueueADC essa vari\u00e1vel deve ser global (assim como faz\u00edamos com o sem\u00e1foro): /************************************************************************/ /* RTOS */ /************************************************************************/ #define TASK_OLED_STACK_SIZE (6*1024/sizeof(portSTACK_TYPE)) #define TASK_OLED_STACK_PRIORITY (tskIDLE_PRIORITY) +typedef struct { + uint value; +} adcData; +QueueHandle_t xQueueADC; Tarefa Criei a struct adcData e a vari\u00e1vel global xQueueADC Compile para ver se possui erros. Modificando task_oled e main Agora modifique a tarefa task_oled para alocar uma fila nesse \"endere\u00e7o\", vamos tamb\u00e9m criar uma vari\u00e1vel local da task chamada de adc para recebimento de dados dessa fila, e imprimir na tela o resultado: void task_oled(void){ gfx_mono_ssd1306_init(); gfx_mono_draw_string(\"Exemplo RTOS\", 0, 0, &sysfont); + adcData adc; for (;;) { + // Busca um novo valor na fila do ADC! + // formata e imprime no LCD o dado + if (xQueueReceive( xQueueADC, &(adc), ( TickType_t ) 100 / portTICK_PERIOD_MS)) { + char b[512]; + sprintf(b, \"%04d\", adc.value); + gfx_mono_draw_string(b, 0, 20, &sysfont); + } } } Modifique a func\u00e3o main, criando a fila nela: main(){ .... + xQueueADC = xQueueCreate( 5, sizeof( adcData )); /* Create task to handler LCD */ if (xTaskCreate(task_adc, \"adc\", TASK_LCD_STACK_SIZE, NULL, TASK_LCD_STACK_PRIORITY, NULL) != pdPASS) { printf(\"Failed to create test adc task\\r\\n\"); } Tarefa Modifique a task_oled Compile para ver se possui erros. Diagrama Modificando task_adc Agora precisamos modificar a task_adc para enviar o dado por essa fila: void task_adc(void){ /* inicializa e configura adc */ config_AFEC_pot(AFEC_POT, AFEC_POT_ID, AFEC_POT_CHANNEL, AFEC_pot_Callback); /* Selecina canal e inicializa convers\u00e3o */ afec_channel_enable(AFEC_POT, AFEC_POT_CHANNEL); afec_start_software_conversion(AFEC_POT); + adcData adc; while(1){ if(g_is_conversion_done){ printf(\"%d\\n\", g_ul_value); + adc.value = g_ul_value; + xQueueSend(xQueueADC, &adc, 0); vTaskDelay(500); /* Selecina canal e inicializa convers\u00e3o */ afec_channel_enable(AFEC_POT, AFEC_POT_CHANNEL); afec_start_software_conversion(AFEC_POT); } } } Tarefa Modifique o c\u00f3digo como indicado anteriormente Programe o uC Teste mudando o valor do pot\u00eanciometro e verificando se o valor no oled muda. Diagrama sem\u00e1foro Agora vamos modificar o c\u00f3digo para usar um sem\u00e1foro para substituir a flag: g_is_conversion_done , esse sem\u00e1foro precisa ser liberado na AFEC_pot_Callback e recebido na task_adc . Tarefa Substitua a flag g_is_conversion_done por um sem\u00e1foro. Dica: Voc\u00ea deve criar um sem\u00e1foro, inicializar e enviar. Diagrama C - Dado direto do IRQ AFEC para a task_oled Podemos fazer o envio do dado direto do AFEC_pot_Callback para a task_oled , para isso teremos que usar a fun\u00e7\u00e3o xQueueSendFromISR no lugar da xQueueSend . Tip Voc\u00ea sabia que pode alterar a fonte do OLED? De uma olhada no arquivo: src/config/conf_sysfont : //#define USE_FONT_BPMONO_10x16 #define USE_FONT_BPMONO_10x14 /* #define USE_FONT_MONO_MMM_10x12 */ //#define USE_FONT_BASIC_6x7 Basta escolher entre define diferente. Tarefa Fa\u00e7a o envio direto do callback do AFEC para a task_oled Programe e teste. Teste mudando o valor do pot\u00eanciometro e verificando se o valor no oled muda. Diagrama B - Exibindo graficamente Fa\u00e7a a exibi\u00e7\u00e3o do potenci\u00f4metro de forma gr\u00e1fica no oled. A - Adicionando mais uma entrada anal\u00f3gica No lugar de fazer apenas uma entrada anal\u00f3gica vamos fazer a leitura de dois valores, para isso voc\u00eas podem utilizar o joystick anal\u00f3gico que voc\u00eas possuem no kit. Preencher ao finalizar o lab Carregando\u2026","title":"LAB - RTOS - ADC"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#lab-rtos-adc","text":"Neste laborat\u00f3rio iremos trabalhar com convers\u00e3o anal\u00f3gica digital, vamos aprender como usar um recurso do rtos chamado de fila.","title":"LAB - RTOS - ADC"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#lab","text":"Pasta Lab6-RTOS-ADC Executar exemplo convers\u00e3o anal\u00f3gica Incorporar exemplo ADC no RTOS com OLED Estruturar tasks Criar queue de comunica\u00e7\u00e3o entre IRQ e tasks","title":"LAB"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#inicio","text":"Conex\u00f5es EXT1: OLED Potenci\u00f4metro no PD30 conforme exemplo SAME70-examples/Perifericos-uC/AFEC-Pin/ C\u00f3digo exemplo Atualizem o reposit\u00f3rio SAME70-Examples antes de continuar Vamos usar como base o c\u00f3digo Screens/RTOS-OLED-Xplained-Pro , copie para o seu reposit\u00f3rio de entregas e renomeia para: Lab6-RTOS-ADC","title":"In\u00edcio"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#exemplo-afec","text":"Abra o exemplo do AFEC-Pin localizado em SAME70-examples/Perifericos-uC/AFEC-Pin/ , leia o README desse exemplo e o execute na sua placa. Note Note que ser\u00e1 necess\u00e1rio conectar o potenci\u00f4metro ao kit, conforme indica\u00e7\u00e3o do README.","title":"Exemplo AFEC"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#incorporando-afec-ao-rtos","text":"Vamos incorporar o exemplo do AFEC ao c\u00f3digo do OLED com RTOS, para isso iremos criar uma tarefa que ser\u00e1 respons\u00e1vel por ler o valor do AFEC. Modifique Adicione no ASF o driver do AFEC Traga as fun\u00e7\u00f5es, defines e vari\u00e1veis globais do exemplo AFEC-PIN vari\u00e1veis globais: g_ defines config_afec AFEC_pot_Callback() Compile o c\u00f3digo para ver se est\u00e1 ok Agora vamos criar uma task no RTOS para lidar com a leitura do AFEC, a tarefa vai ter a implementa\u00e7\u00e3o a seguir: void task_adc ( void ){ /* inicializa e configura adc */ config_AFEC_pot ( AFEC_POT , AFEC_POT_ID , AFEC_POT_CHANNEL , AFEC_pot_Callback ); /* Selecina canal e inicializa convers\u00e3o */ afec_channel_enable ( AFEC_POT , AFEC_POT_CHANNEL ); afec_start_software_conversion ( AFEC_POT ); while ( 1 ){ if ( g_is_conversion_done ){ g_is_conversion_done = 0 ; printf ( \"%d \\n \" , g_ul_value ); delay_ms ( 500 ); /* Selecina canal e inicializa convers\u00e3o */ afec_channel_enable ( AFEC_POT , AFEC_POT_CHANNEL ); afec_start_software_conversion ( AFEC_POT ); } } } Note que a task \u00e9 praticamente igual ao main() do exemplo sem RTOS, isso est\u00e1 errado pois ainda usa delay_ms e fica verificando uma flag ( g_is_conversion_done ) no lugar de usar sem\u00e1foro, mas serve como um bom come\u00e7o. Agora \u00e9 necess\u00e1rio modificar a fun\u00e7\u00e3o main para que o freeRTOS crie essa tareafa: /* Create task to handler LCD */ if ( xTaskCreate ( task_adc , \"adc\" , TASK_LCD_STACK_SIZE , NULL , TASK_LCD_STACK_PRIORITY , NULL ) != pdPASS ) { printf ( \"Failed to create test adc task \\r\\n \" ); } Modifique Crie a task task_adc conforme exemplo Inicialize a task no RTOS Abra o terminal e note que est\u00e1 funcionando! Warning Essa task continua usando uma flag que \u00e9 alterada do callback do AFEC para indicar quando o valor est\u00e1 pronto, isso n\u00e3o \u00e9 bom e vamos mudar mais para frente! Usa delay_ms no lugar do vstaskDelay. Diagrama","title":"Incorporando AFEC ao RTOS"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#melhorando","text":"Agora vamos melhorar isso, come\u00e7ando por trocar o delay pelo delay do freertos. Tarefa Substitua o delay_ms pelo delay do freeRTOS Por que isso \u00e9 importante?","title":"Melhorando"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#queue","text":"Mailbox/ queue \u00e9 uma das maneiras de enviarmos dados entre tarefa em um sistema operacional, com ele podemos comunicar interrup\u00e7\u00e3o com tarefa e tarefa com tarefa, enviando valores (diferente do sem\u00e1foro que s\u00f3 funciona de forma bin\u00e1ria). Note Queues are the primary form of intertask communications. They can be used to send messages between tasks, and between interrupts and tasks. In most cases they are used as thread safe FIFO (First In First Out) buffers with new data being sent to the back of the queue, although data can also be sent to the front. Writing to and reading from a queue. In this example the queue was created to hold 5 items, and the queue never becomes full. Material retirado do site: https://www.freertos.org/Embedded-RTOS-Queues.html Tip Para mais informa\u00e7\u00f5es ler o site do freeRTOS sobre filas: https://www.freertos.org/Embedded-RTOS-Queues.html https://freertos.org/a00018.html Tip Temos uma sec\u00e7\u00e3o na nossa p\u00e1gina de dicas com exemplo de fila: https://insper.github.io/ComputacaoEmbarcada/Util-freertos/#fila","title":"queue"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#modificando-firmware","text":"Iremos agora come\u00e7ar a modificar o firmware criando um fila para comunicar a tarefa task_adc com a tarefa task_oled .","title":"Modificando firmware"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#fila","text":"Vamos criar um queue chamado de xQueueADC essa vari\u00e1vel deve ser global (assim como faz\u00edamos com o sem\u00e1foro): /************************************************************************/ /* RTOS */ /************************************************************************/ #define TASK_OLED_STACK_SIZE (6*1024/sizeof(portSTACK_TYPE)) #define TASK_OLED_STACK_PRIORITY (tskIDLE_PRIORITY) +typedef struct { + uint value; +} adcData; +QueueHandle_t xQueueADC; Tarefa Criei a struct adcData e a vari\u00e1vel global xQueueADC Compile para ver se possui erros.","title":"Fila"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#modificando-task_oled-e-main","text":"Agora modifique a tarefa task_oled para alocar uma fila nesse \"endere\u00e7o\", vamos tamb\u00e9m criar uma vari\u00e1vel local da task chamada de adc para recebimento de dados dessa fila, e imprimir na tela o resultado: void task_oled(void){ gfx_mono_ssd1306_init(); gfx_mono_draw_string(\"Exemplo RTOS\", 0, 0, &sysfont); + adcData adc; for (;;) { + // Busca um novo valor na fila do ADC! + // formata e imprime no LCD o dado + if (xQueueReceive( xQueueADC, &(adc), ( TickType_t ) 100 / portTICK_PERIOD_MS)) { + char b[512]; + sprintf(b, \"%04d\", adc.value); + gfx_mono_draw_string(b, 0, 20, &sysfont); + } } } Modifique a func\u00e3o main, criando a fila nela: main(){ .... + xQueueADC = xQueueCreate( 5, sizeof( adcData )); /* Create task to handler LCD */ if (xTaskCreate(task_adc, \"adc\", TASK_LCD_STACK_SIZE, NULL, TASK_LCD_STACK_PRIORITY, NULL) != pdPASS) { printf(\"Failed to create test adc task\\r\\n\"); } Tarefa Modifique a task_oled Compile para ver se possui erros. Diagrama","title":"Modificando task_oled e main"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#modificando-task_adc","text":"Agora precisamos modificar a task_adc para enviar o dado por essa fila: void task_adc(void){ /* inicializa e configura adc */ config_AFEC_pot(AFEC_POT, AFEC_POT_ID, AFEC_POT_CHANNEL, AFEC_pot_Callback); /* Selecina canal e inicializa convers\u00e3o */ afec_channel_enable(AFEC_POT, AFEC_POT_CHANNEL); afec_start_software_conversion(AFEC_POT); + adcData adc; while(1){ if(g_is_conversion_done){ printf(\"%d\\n\", g_ul_value); + adc.value = g_ul_value; + xQueueSend(xQueueADC, &adc, 0); vTaskDelay(500); /* Selecina canal e inicializa convers\u00e3o */ afec_channel_enable(AFEC_POT, AFEC_POT_CHANNEL); afec_start_software_conversion(AFEC_POT); } } } Tarefa Modifique o c\u00f3digo como indicado anteriormente Programe o uC Teste mudando o valor do pot\u00eanciometro e verificando se o valor no oled muda. Diagrama","title":"Modificando task_adc"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#semaforo","text":"Agora vamos modificar o c\u00f3digo para usar um sem\u00e1foro para substituir a flag: g_is_conversion_done , esse sem\u00e1foro precisa ser liberado na AFEC_pot_Callback e recebido na task_adc . Tarefa Substitua a flag g_is_conversion_done por um sem\u00e1foro. Dica: Voc\u00ea deve criar um sem\u00e1foro, inicializar e enviar. Diagrama","title":"sem\u00e1foro"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#c-dado-direto-do-irq-afec-para-a-task_oled","text":"Podemos fazer o envio do dado direto do AFEC_pot_Callback para a task_oled , para isso teremos que usar a fun\u00e7\u00e3o xQueueSendFromISR no lugar da xQueueSend . Tip Voc\u00ea sabia que pode alterar a fonte do OLED? De uma olhada no arquivo: src/config/conf_sysfont : //#define USE_FONT_BPMONO_10x16 #define USE_FONT_BPMONO_10x14 /* #define USE_FONT_MONO_MMM_10x12 */ //#define USE_FONT_BASIC_6x7 Basta escolher entre define diferente. Tarefa Fa\u00e7a o envio direto do callback do AFEC para a task_oled Programe e teste. Teste mudando o valor do pot\u00eanciometro e verificando se o valor no oled muda. Diagrama","title":"C - Dado direto do IRQ AFEC para a task_oled"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#b-exibindo-graficamente","text":"Fa\u00e7a a exibi\u00e7\u00e3o do potenci\u00f4metro de forma gr\u00e1fica no oled.","title":"B - Exibindo graficamente"},{"location":"navigation/Labs/Lab_RTOS_ADC/Lab-RTOS-ADC/#a-adicionando-mais-uma-entrada-analogica","text":"No lugar de fazer apenas uma entrada anal\u00f3gica vamos fazer a leitura de dois valores, para isso voc\u00eas podem utilizar o joystick anal\u00f3gico que voc\u00eas possuem no kit. Preencher ao finalizar o lab Carregando\u2026","title":"A - Adicionando mais uma entrada anal\u00f3gica"},{"location":"navigation/Labs/Lab_RTOS_HCSR04/lab/","text":"LAB - RTOS - HC-SR04 Pasta: Lab5-RTOS-HC-SR04 ------------------------------------------------ Data LIMITE para entrega: 27/09/22 - 23h59 Neste laborat\u00f3rio iremos trabalhar com o sensor de dist\u00e2ncia HC-SR04, que \u00e9 muito utilizado em projetos de rob\u00f3tica e similares. O sensor \u00e9 um m\u00f3dulo ultrass\u00f4nico e que possibilita medirmos a dist\u00e2ncia entre o sensor e um objeto. Para realizarmos a leitura correta do sensor, iremos utilizar os seguintes perif\u00e9ricos (com interrup\u00e7\u00e3o): PIO: Acionamento do sensor (pino TRIG) e leitura do pulso de echo (pino ECHO) TC: Para contarmos a dura\u00e7\u00e3o do pulso. HC-SR04 Refs: http://wiki.sunfounder.cc/index.php?title=Ultrasonic_Module https://www.filipeflop.com/produto/sensor-de-distancia-ultrassonico-hc-sr04/ O Sensor de Dist\u00e2ncia Ultrass\u00f4nico HC-SR04 \u00e9 capaz de medir dist\u00e2ncias de 2cm a 4m com \u00f3tima precis\u00e3o e baixo custo. Este m\u00f3dulo possui um circuito pronto com emissor e receptor acoplados e 4 pinos (VCC, Trigger, ECHO, GND) para medi\u00e7\u00e3o. Para come\u00e7ar a medi\u00e7\u00e3o \u00e9 necess\u00e1rio alimentar o m\u00f3dulo e colocar o pino Trigger em n\u00edvel alto por mais de 10us. Assim, o sensor emitir\u00e1 uma onda sonora que, ao encontrar um obst\u00e1culo, rebater\u00e1 de volta em dire\u00e7\u00e3o ao m\u00f3dulo. Durante o tempo de emiss\u00e3o e recebimento do sinal, o pino ECHO ficar\u00e1 em n\u00edvel alto. Logo, o c\u00e1lculo da dist\u00e2ncia pode ser feito de acordo com o tempo em que o pino ECHO permaneceu em n\u00edvel alto ap\u00f3s o pino Trigger ter sido colocado em n\u00edvel alto. Dist\u00e2ncia = [Tempo ECHO em n\u00edvel alto * Velocidade do Som] / 2 A velocidade do som pode ser considerada idealmente igual a 340 m/s, logo o resultado \u00e9 obtido em metros se considerado o tempo em segundos. Na f\u00f3rmula, a divis\u00e3o por 2 deve-se ao fato de que a onda \u00e9 enviada e rebatida, ou seja, ela percorre 2 vezes a dist\u00e2ncia procurada. Especifica\u00e7\u00f5es: Alimenta\u00e7\u00e3o: 5V DC Corrente de Opera\u00e7\u00e3o: 2mA \u00c2ngulo de efeito: 15\u00b0 Alcance.: 2cm ~ 4m Precis\u00e3o.: 3mm Descric\u00e3o extra\u00edda do site do filipflop: https://www.filipeflop.com/produto/sensor-de-distancia-ultrassonico-hc-sr04/ Info No Brasil o sensor custa em torno de R$14 ( https://www.filipeflop.com/produto/sensor-de-distancia-ultrassonico-hc-sr04/ ) Interagindo Ap\u00f3s feita a montagem voc\u00ea dever\u00e1 escrever um programa que faz o controle do sensor ultrass\u00f4nico, para iniciar uma nova leitura voc\u00ea deve gerar um pulso de 10us no pino de Trig ( Pin Y ) e ent\u00e3o aguardar pela subida do sinal do Echo ( Pin X ) e ent\u00e3o contar o tempo ( dT ) que ele fica em alto. O valor de dT \u00e9 proporcional ao tempo que o som levou para chegar at\u00e9 o obst\u00e1culo e voltar. A figura a seguir demonstra como funciona a leitura do sensor. Exercise Calcule o tempo m\u00ednimo e m\u00e1ximo que o sinal de Echo pode ficar em '1'? Lembre de verificar o range do sensor (voc\u00ea vai precisar saber a velocidade do som). Answer Das informa\u00e7\u00f5es fornecidas do sensor: Dist\u00e2ncia m\u00ednima: 0.02 m Dist\u00e2ncia m\u00e1xima: 4.00 m Sabendo que a velocidade do som \u00e9 aproximadamente 340 m/s, portanto $x [s] = dist / 340$. Lembre que o sensor fornece a dist\u00e2ncia dobrado (tempo de ir e voltar)! Ou seja: Tempo m\u00ednimo: $2 \\times 0,000058$s Tempo m\u00e1ximo: $2 \\times 0,011764$s Exercise Com as informa\u00e7\u00f5es coletadas at\u00e9 aqui voc\u00ea consegue imaginar como deve ser o firmware para fazer a leitura do sensor? N\u00e3o existe uma \u00fanica maneira de fazer, mas algumas solu\u00e7\u00f5es podem n\u00e3o ser muito boas! Descreva aqui como voc\u00ea geraria o sinal do Trig e como voc\u00ea faria a leitura do sinal do Echo e quais perif\u00e9ricos usaria para isso? Answer Uma das solu\u00e7\u00f5es poss\u00edveis (e indicadas) \u00e9: Sinal do Trigger gerar via pio_set(), delay_us(10), pio_clear() . Como o sinal do pino de Trigger pode ser aproximadamente 10 us, n\u00e3o tem muito problema em usar a fun\u00e7\u00e3o de delay para isso! J\u00e1 o sinal do Echo carrega informa\u00e7\u00f5es importantes e devemos contar corretamente o tempo. Para isso sugerimos configurar uma interrup\u00e7\u00e3o de borda no pino do ECHO e inciar o RTT quando ocorrer uma borda de descida e parar a contagem do tempo quando ocorrer uma borda de subida, informando a fun\u00e7\u00e3o main via flag que uma nova leitura aconteceu. Contado tempo Para fazermos a leitura correta do sensor, ser\u00e1 necess\u00e1rio conseguirmos contar o tempo na qual o pulso do echo fica em alto. Para isso iremos usar um novo perif\u00e9rico do nosso microcontrolador chamado de REAL TIME TIMER , que possibilita contarmos tempo (usando o clock do sistema como base). Warning Atualize o reposit\u00f3rio de exemplo (nova vers\u00e3o do exemplo publicada 21/9) Exercise Leia o REAME do c\u00f3digo exemplo: SAME70-examples/Perifericos-uC/RTC-IRQ/ Abra o c\u00f3digo no microchip studio, an\u00e1lise e rode o c\u00f3digo na placa. Lab Comecem copiando o exemplo do OLED-RTOS para o seu reposit\u00f3rio e renomeiem para: Lab5-HC-SR04 , ou se preferir, podem usar um dos labs passados que possui OLED-RTOS e j\u00e1 tem os bot\u00f5es configurados, s\u00f3 lembrem de fazer uma c\u00f3pia e renomear. Montagem O sensor possui dois pinos (TRIG e ECHO) que devem ser ligados no uC os outros s\u00e3o para alimenta\u00e7\u00e3o (GND e VCC), como o m\u00f3dulo opera com 5V teremos que fazer um divisor de tens\u00e3o no pino do ECHO para n\u00e3o danificar o nosso uC que possui tens\u00e3o m\u00e1xima nos pinos de 3v3. Voc\u00ea deve seguir a montagem a seguir, sugerimos utilizar uma protoboard para isso. Os pinos X e Y podem ser qualquer um do EXT-2. Esquem\u00e1tico Protoboard Warning Voc\u00ea deve escolher os pinos X e Y que ir\u00e3o ligar no uC. Exercise Montar a protoboard como indicado. C A entrega do Lab deve ser um sistema que possui um HC-SR04 e faz periodicamente a leitura da dist\u00e2ncia e exibe a informac\u00e3o no OLED, voc\u00eas devem estruturar a solu\u00e7\u00e3o utilizando os recursos do RTOS. Extras: Cada item vale como um conceito a mais. Mostre um gr\u00e1fico da dist\u00e2ncia no tempo!. Ler dois sensores em paralelo (exibe dois pontos no gr\u00e1fico) Ao terminar o lab preencha: Carregando\u2026 Dicas ________ ________ TRIG ______|////////|_____________________________________|////////|_____ ^ 10us | | _____________ | 6.inicia nova leitura ECHO _________________|/////////////|_________ | | | | V V | 1.callback_echo 3.callback_echo | | | | V V | 2.RTT_init 4.rtt_read_timer_value | | | V | 5.valor para main + c\u00e1lculo da dist\u00e2ncia Setup: Fazer a montagem na protoboard Escolher dois pinos para Echo e Trig Configurar Trig como output e Echo como input Configurar irq de boarda no pino Echo Lembre de criar a fun\u00e7\u00e3o de callback. Warning N\u00e3o ative PULL_UP no pino do ECHO! Trig: Gerar o pulso no pino de Trig com delay_us . Echo: Iniciar o RTT na borda de subida do pino Echo Qual prescale usar? Ler valor do RTT em borda de descida do pino Echo Consulte a documenta\u0107\u00e3o do ASF-RTT para saber como ler o valor atual do contador. Dicas RTT Nessa primeira etapa n\u00e3o precisamos de nenhuma interrup\u00e7\u00e3o do RTT, ele vai funcionar apenas como um rel\u00f3gio. Passe 0 no \u00faltimo par\u00e2metro da fun\u00e7\u00e3o RTT_Init() . Para consultarmos o valor atual do RTT, utilize a func\u00e3o rtt_read_timer_value uint32_t rtt_read_timer_value ( Rtt * p_rtt ) Read the current value of the RTT timer value. Parameters p_rtt Pointer to an RTT instance. Returns The current Real-time Timer value. Referenced by configure_rtt(), gpbr_test_configure_rtt(), main(), and refresh_display(). Conta: Realizar o c\u00e1lculo da dist\u00e2ncia usando o valor do RTT Lembre de usar como base de tempo o valor que configurou no RTT. Exiba nos no OLED a dist\u00e2ncia atual em cm.","title":"Lab 5 - RTOS HC-SR04"},{"location":"navigation/Labs/Lab_RTOS_HCSR04/lab/#lab-rtos-hc-sr04","text":"Pasta: Lab5-RTOS-HC-SR04 ------------------------------------------------ Data LIMITE para entrega: 27/09/22 - 23h59 Neste laborat\u00f3rio iremos trabalhar com o sensor de dist\u00e2ncia HC-SR04, que \u00e9 muito utilizado em projetos de rob\u00f3tica e similares. O sensor \u00e9 um m\u00f3dulo ultrass\u00f4nico e que possibilita medirmos a dist\u00e2ncia entre o sensor e um objeto. Para realizarmos a leitura correta do sensor, iremos utilizar os seguintes perif\u00e9ricos (com interrup\u00e7\u00e3o): PIO: Acionamento do sensor (pino TRIG) e leitura do pulso de echo (pino ECHO) TC: Para contarmos a dura\u00e7\u00e3o do pulso.","title":"LAB - RTOS - HC-SR04"},{"location":"navigation/Labs/Lab_RTOS_HCSR04/lab/#hc-sr04","text":"Refs: http://wiki.sunfounder.cc/index.php?title=Ultrasonic_Module https://www.filipeflop.com/produto/sensor-de-distancia-ultrassonico-hc-sr04/ O Sensor de Dist\u00e2ncia Ultrass\u00f4nico HC-SR04 \u00e9 capaz de medir dist\u00e2ncias de 2cm a 4m com \u00f3tima precis\u00e3o e baixo custo. Este m\u00f3dulo possui um circuito pronto com emissor e receptor acoplados e 4 pinos (VCC, Trigger, ECHO, GND) para medi\u00e7\u00e3o. Para come\u00e7ar a medi\u00e7\u00e3o \u00e9 necess\u00e1rio alimentar o m\u00f3dulo e colocar o pino Trigger em n\u00edvel alto por mais de 10us. Assim, o sensor emitir\u00e1 uma onda sonora que, ao encontrar um obst\u00e1culo, rebater\u00e1 de volta em dire\u00e7\u00e3o ao m\u00f3dulo. Durante o tempo de emiss\u00e3o e recebimento do sinal, o pino ECHO ficar\u00e1 em n\u00edvel alto. Logo, o c\u00e1lculo da dist\u00e2ncia pode ser feito de acordo com o tempo em que o pino ECHO permaneceu em n\u00edvel alto ap\u00f3s o pino Trigger ter sido colocado em n\u00edvel alto. Dist\u00e2ncia = [Tempo ECHO em n\u00edvel alto * Velocidade do Som] / 2 A velocidade do som pode ser considerada idealmente igual a 340 m/s, logo o resultado \u00e9 obtido em metros se considerado o tempo em segundos. Na f\u00f3rmula, a divis\u00e3o por 2 deve-se ao fato de que a onda \u00e9 enviada e rebatida, ou seja, ela percorre 2 vezes a dist\u00e2ncia procurada. Especifica\u00e7\u00f5es: Alimenta\u00e7\u00e3o: 5V DC Corrente de Opera\u00e7\u00e3o: 2mA \u00c2ngulo de efeito: 15\u00b0 Alcance.: 2cm ~ 4m Precis\u00e3o.: 3mm Descric\u00e3o extra\u00edda do site do filipflop: https://www.filipeflop.com/produto/sensor-de-distancia-ultrassonico-hc-sr04/ Info No Brasil o sensor custa em torno de R$14 ( https://www.filipeflop.com/produto/sensor-de-distancia-ultrassonico-hc-sr04/ )","title":"HC-SR04"},{"location":"navigation/Labs/Lab_RTOS_HCSR04/lab/#interagindo","text":"Ap\u00f3s feita a montagem voc\u00ea dever\u00e1 escrever um programa que faz o controle do sensor ultrass\u00f4nico, para iniciar uma nova leitura voc\u00ea deve gerar um pulso de 10us no pino de Trig ( Pin Y ) e ent\u00e3o aguardar pela subida do sinal do Echo ( Pin X ) e ent\u00e3o contar o tempo ( dT ) que ele fica em alto. O valor de dT \u00e9 proporcional ao tempo que o som levou para chegar at\u00e9 o obst\u00e1culo e voltar. A figura a seguir demonstra como funciona a leitura do sensor. Exercise Calcule o tempo m\u00ednimo e m\u00e1ximo que o sinal de Echo pode ficar em '1'? Lembre de verificar o range do sensor (voc\u00ea vai precisar saber a velocidade do som). Answer Das informa\u00e7\u00f5es fornecidas do sensor: Dist\u00e2ncia m\u00ednima: 0.02 m Dist\u00e2ncia m\u00e1xima: 4.00 m Sabendo que a velocidade do som \u00e9 aproximadamente 340 m/s, portanto $x [s] = dist / 340$. Lembre que o sensor fornece a dist\u00e2ncia dobrado (tempo de ir e voltar)! Ou seja: Tempo m\u00ednimo: $2 \\times 0,000058$s Tempo m\u00e1ximo: $2 \\times 0,011764$s Exercise Com as informa\u00e7\u00f5es coletadas at\u00e9 aqui voc\u00ea consegue imaginar como deve ser o firmware para fazer a leitura do sensor? N\u00e3o existe uma \u00fanica maneira de fazer, mas algumas solu\u00e7\u00f5es podem n\u00e3o ser muito boas! Descreva aqui como voc\u00ea geraria o sinal do Trig e como voc\u00ea faria a leitura do sinal do Echo e quais perif\u00e9ricos usaria para isso? Answer Uma das solu\u00e7\u00f5es poss\u00edveis (e indicadas) \u00e9: Sinal do Trigger gerar via pio_set(), delay_us(10), pio_clear() . Como o sinal do pino de Trigger pode ser aproximadamente 10 us, n\u00e3o tem muito problema em usar a fun\u00e7\u00e3o de delay para isso! J\u00e1 o sinal do Echo carrega informa\u00e7\u00f5es importantes e devemos contar corretamente o tempo. Para isso sugerimos configurar uma interrup\u00e7\u00e3o de borda no pino do ECHO e inciar o RTT quando ocorrer uma borda de descida e parar a contagem do tempo quando ocorrer uma borda de subida, informando a fun\u00e7\u00e3o main via flag que uma nova leitura aconteceu.","title":"Interagindo"},{"location":"navigation/Labs/Lab_RTOS_HCSR04/lab/#contado-tempo","text":"Para fazermos a leitura correta do sensor, ser\u00e1 necess\u00e1rio conseguirmos contar o tempo na qual o pulso do echo fica em alto. Para isso iremos usar um novo perif\u00e9rico do nosso microcontrolador chamado de REAL TIME TIMER , que possibilita contarmos tempo (usando o clock do sistema como base). Warning Atualize o reposit\u00f3rio de exemplo (nova vers\u00e3o do exemplo publicada 21/9) Exercise Leia o REAME do c\u00f3digo exemplo: SAME70-examples/Perifericos-uC/RTC-IRQ/ Abra o c\u00f3digo no microchip studio, an\u00e1lise e rode o c\u00f3digo na placa.","title":"Contado tempo"},{"location":"navigation/Labs/Lab_RTOS_HCSR04/lab/#lab","text":"Comecem copiando o exemplo do OLED-RTOS para o seu reposit\u00f3rio e renomeiem para: Lab5-HC-SR04 , ou se preferir, podem usar um dos labs passados que possui OLED-RTOS e j\u00e1 tem os bot\u00f5es configurados, s\u00f3 lembrem de fazer uma c\u00f3pia e renomear.","title":"Lab"},{"location":"navigation/Labs/Lab_RTOS_HCSR04/lab/#montagem","text":"O sensor possui dois pinos (TRIG e ECHO) que devem ser ligados no uC os outros s\u00e3o para alimenta\u00e7\u00e3o (GND e VCC), como o m\u00f3dulo opera com 5V teremos que fazer um divisor de tens\u00e3o no pino do ECHO para n\u00e3o danificar o nosso uC que possui tens\u00e3o m\u00e1xima nos pinos de 3v3. Voc\u00ea deve seguir a montagem a seguir, sugerimos utilizar uma protoboard para isso. Os pinos X e Y podem ser qualquer um do EXT-2. Esquem\u00e1tico Protoboard Warning Voc\u00ea deve escolher os pinos X e Y que ir\u00e3o ligar no uC. Exercise Montar a protoboard como indicado.","title":"Montagem"},{"location":"navigation/Labs/Lab_RTOS_HCSR04/lab/#c","text":"A entrega do Lab deve ser um sistema que possui um HC-SR04 e faz periodicamente a leitura da dist\u00e2ncia e exibe a informac\u00e3o no OLED, voc\u00eas devem estruturar a solu\u00e7\u00e3o utilizando os recursos do RTOS.","title":"C"},{"location":"navigation/Labs/Lab_RTOS_HCSR04/lab/#extras","text":"Cada item vale como um conceito a mais. Mostre um gr\u00e1fico da dist\u00e2ncia no tempo!. Ler dois sensores em paralelo (exibe dois pontos no gr\u00e1fico) Ao terminar o lab preencha: Carregando\u2026","title":"Extras:"},{"location":"navigation/Labs/Lab_RTOS_HCSR04/lab/#dicas","text":"________ ________ TRIG ______|////////|_____________________________________|////////|_____ ^ 10us | | _____________ | 6.inicia nova leitura ECHO _________________|/////////////|_________ | | | | V V | 1.callback_echo 3.callback_echo | | | | V V | 2.RTT_init 4.rtt_read_timer_value | | | V | 5.valor para main + c\u00e1lculo da dist\u00e2ncia Setup: Fazer a montagem na protoboard Escolher dois pinos para Echo e Trig Configurar Trig como output e Echo como input Configurar irq de boarda no pino Echo Lembre de criar a fun\u00e7\u00e3o de callback. Warning N\u00e3o ative PULL_UP no pino do ECHO! Trig: Gerar o pulso no pino de Trig com delay_us . Echo: Iniciar o RTT na borda de subida do pino Echo Qual prescale usar? Ler valor do RTT em borda de descida do pino Echo Consulte a documenta\u0107\u00e3o do ASF-RTT para saber como ler o valor atual do contador. Dicas RTT Nessa primeira etapa n\u00e3o precisamos de nenhuma interrup\u00e7\u00e3o do RTT, ele vai funcionar apenas como um rel\u00f3gio. Passe 0 no \u00faltimo par\u00e2metro da fun\u00e7\u00e3o RTT_Init() . Para consultarmos o valor atual do RTT, utilize a func\u00e3o rtt_read_timer_value uint32_t rtt_read_timer_value ( Rtt * p_rtt ) Read the current value of the RTT timer value. Parameters p_rtt Pointer to an RTT instance. Returns The current Real-time Timer value. Referenced by configure_rtt(), gpbr_test_configure_rtt(), main(), and refresh_display(). Conta: Realizar o c\u00e1lculo da dist\u00e2ncia usando o valor do RTT Lembre de usar como base de tempo o valor que configurou no RTT. Exiba nos no OLED a dist\u00e2ncia atual em cm.","title":"Dicas"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/","text":"RTOS - LCD Nesse lab iremos trabalhar com o uso de um sistema operacional de tempo real (RTOS) para gerenciar o LCD max Touch, o forte desse lab ser\u00e1 a linguagem C e como estruturar um firmware. Preencher ao finalizar o lab Carregando\u2026 LAB LAB Labs/RTOS-LCD-maxTouch-Switch Executar demo do LCD com RTOS Trabalha com dados de touch e LCD In\u00edcio LCD max Touch Plugue o LCD max Touch no EXT2. C\u00f3digo exemplo Copie o c\u00f3digo exemplo SAME70-examples/Screens/RTOS-LCD-maxTouch-Switch-Toggle/ para a pasta da entrega do seu reposit\u00f3rio Labs/RTOS-LCD-maxTouch-Switch Vamos modificar esse c\u00f3digo exemplo. Terminal Esse exemplo faz uso da comunica\u00e7\u00e3o UART para debug de c\u00f3digo (via printf), para acessar o terminal no atmel est\u00fadio clique em: View Terminal Window Configure o terminal para a porta que (COM) correta (verificar no windiows) e para operar com um BaudRate de 115200. Entendendo o exemplo Vamos entender o exemplo e como ele funciona! Nesse projeto temos duas tasks: task_mxt : Gerencia o touch do LCD task_lcd : Gerencia a escrita de informa\u00e7\u00e3o no LCD Essas tarefas se comunicam por uma fila chamada: xQueueTouch , onde a task mxt envia dados relativos ao touch ( x , y ) e a tarefa lcd coleta esses dados e processa o evento. Os dados da fila s\u00e3o um struct do tipo: typedef struct { uint x ; uint y ; } touchData ; O diagrama a seguir ilustra o firmware: Execute Programe o uC com o firmware exemplo Analise o resultado Entenda o c\u00f3digo Modificando Vamos modificar esse c\u00f3digo, ele n\u00e3o foi implementando de uma forma que suporta expans\u00e3o. struct Vamos organiza os bot\u00f5es em uma struct, para ficar mais f\u00e1cil de criarmos novos bot\u00f5es, ou modificar os que j\u00e1 existem. Para isso, crie uma struct como a seguir: typedef struct { uint32_t width ; // largura (px) uint32_t height ; // altura (px) uint32_t colorOn ; // cor do bot\u00e3o acionado uint32_t colorOff ; // cor do bot\u00e3o desligado uint32_t x ; // posicao x uint32_t y ; // posicao y } t_but ; Note Estamos assumindo que o bot\u00e3o \u00e9 um ret\u00e2ngulo. Na task_lcd vamos criar o primeiro bot\u00e3o ( but0 ): t_but but0 = {. width = 120 , . height = 75 , . colorOn = COLOR_TOMATO , . colorOff = COLOR_BLACK , . x = ILI9488_LCD_WIDTH / 2 , . y = 40 }; Note Esses dados foram copiados da configura\u00e7\u00e3o dos bot\u00f5es j\u00e1 existentes no c\u00f3digo. draw_button_new E agora vamos criar uma fun\u00e7\u00e3o que recebe o tipo t_but e desenha o bot\u00e3o na tela: void draw_button_new ( t_but but , int status ){ uint32_t color ; if ( status ) color = but . colorOn ; else color = but . colorOff ; ili9488_set_foreground_color ( COLOR_CONVERT ( color )); ili9488_draw_filled_rectangle ( but . x - but . width / 2 , but . y - but . height / 2 , but . x + but . width / 2 , but . y + but . height / 2 ); } Vamos editar a task_lcd para chamar essa fun\u00e7\u00e3o rec\u00e9m criada com o but0 , ela deve ficar: void task_lcd ( void ){ xQueueTouch = xQueueCreate ( 10 , sizeof ( touchData ) ); configure_lcd (); draw_screen (); font_draw_text ( & digital52 , \"DEMO - BUT\" , 0 , 0 , 1 ); t_but but0 = {. width = 120 , . height = 75 , . colorOn = COLOR_TOMATO , . colorOff = COLOR_BLACK , . x = ILI9488_LCD_WIDTH / 2 , . y = 40 }; uint8_t but0_status = 1 ; draw_button_new ( but0 , but0_status ); // struct local para armazenar msg enviada pela task do mxt touchData touch ; while ( true ) { if ( xQueueReceive ( xQueueTouch , & ( touch ), ( TickType_t ) 500 / portTICK_PERIOD_MS )) { //update_screen(touch.x, touch.y); but0_status = ! but0_status ; draw_button_new ( but0 , but0_status ); printf ( \"x:%d y:%d \\n \" , touch . x , touch . y ); } } } Execute Fa\u00e7a as altera\u00e7\u00f5es no c\u00f3digo crie a struct t_but crie o but0 crie a fun\u00e7\u00e3o draw_button_new modifique a tarefa task_lcd Compile e programe o c\u00f3digo Verifique a funcionalidade do programa toque na tela, o bot\u00e3o deve mudar! melhorando a draw_button_new J\u00e1 que possu\u00edmos uma struct que guarda a informa\u00e7\u00e3o do bot\u00e3o, porque n\u00e3o guardar nela o status ( but0_status )? Vamos fazer, modificar a t_but inserindo um campo a mais uint8_t status e modificar a fun\u00e7\u00e3o que desenha o bot\u00e3o para n\u00e3o termos mais que passar o argumento on . void draw_button_new(t_but but){} Execute Fa\u00e7a as altera\u00e7\u00f5es no c\u00f3digo modifique t_but modifique a fun\u00e7\u00e3o draw_button_new() modifique a task_lcd para usar esse novo campo Programe e teste Novos bot\u00f5es Vamos criar dois novos bot\u00f5es ( but1 , but2 ), com as seguintes propriedades: but1 : colorOn: Escolher uma posi\u00e7\u00e3o y 140 but2 : colorOn: Escolher uma posi\u00e7\u00e3o y 240 o que n\u00e3o foi definido, copiar do bot\u00e3o 0 ( but0 ) Agora exiba os novos bot\u00f5es, e fa\u00e7a com que eles mudem o status quando toque na regi\u00e3o deles na tela! Execute Fa\u00e7a as altera\u00e7\u00f5es no c\u00f3digo crie but1 e but2 exiba os bot\u00f5es e fa\u00e7a eles mudarem o status Programe e teste Detectando bot\u00e3o Vamos agora criar uma fun\u00e7\u00e3o que detecta qual bot\u00e3o foi pressionado, para isso, vamos criar um vetor de structs (cada index representa um bot\u00e3o) e passar para essa fun\u00e7\u00e3o o vetor e tamb\u00e9m o valor recebido pela fila do toque referente a x e y . na task_lcd Para criar o vetor de structs: t_but botoes [] = { but0 , but1 , but2 }; Tip Voc\u00ea tem no seu c\u00f3digo algo como isso: draw_button_new(but0); draw_button_new(but1); draw_button_new(but2); Pode mudar para um for varrendo o nosso novo vetor botoes . O c\u00f3digo vai ficar mais clean. Com o vetor criado, vamos criar a fun\u00e7\u00e3o que processa o touch, ela ser\u00e1 chamada de processa_touch e ter\u00e1 a seguinte implementa\u00e7\u00e3o: int process_touch(t_but botoes[], touchData touch, uint32_t n){ } Essa fun\u00e7\u00e3o recebe o vetor de structs e tamb\u00e9m a posi\u00e7\u00e3o na tela de onde ocorreu o toque ( touch.x , touch.y ). A fun\u00e7\u00e3o deve retornar ( int ) um valor ( 0 , 1 , 2 , ...) que indica qual bot\u00e3o que foi pressionado ou -1, indicando que nenhum bot\u00e3o satisfez o toque. n \u00e9 o tamanho do vetor botoes . Warning A fun\u00e7\u00e3o tem que ser gen\u00e9rica, suportando quantidade diferentes de bot\u00f5es e configura\u00e7\u00f5es diferentes de bot\u00f5es! N\u00e3o pode isso: \u200b Tip Abra o terminal uart do atmel, l\u00e1 voc\u00ea consegue ver os dados do touch: Com a fun\u00e7\u00e3o vamos agora alterar somente o status do bot\u00e3o que foi pressionado, para isso, voc\u00eas devem alterar o while(1) da fun\u00e7\u00e3o task_lcd , para chamar a process_touch . Uma sugest\u00e3o de como implementar isso a seguir: if ( xQueueReceive ( xQueueTouch , & ( touch ), ( TickType_t ) 500 / portTICK_PERIOD_MS )) { int b = process_touch ( botoes , touch ); if ( b >= 0 ){ botoes [ b ]. status = ! botoes [ b ]. status ; draw_button_new ( botoes [ b ]); } printf ( \"x:%d y:%d \\n \" , touch . x , touch . y ); } Execute Crie o vetor de bot\u00f5es Declare a fun\u00e7\u00e3o process_touch Implemente a fun\u00e7\u00e3o process_touch Programe e teste S\u00f3 o bot\u00e3o que for tocado deve mudar de status Tip Chegou at\u00e9 aqui? N\u00e3o esque\u00e7a de preencher o forms com a entrega! Extras (C+) Adicione 2 novos bot\u00f5es! Extras (B) Que tal que para cada bot\u00e3o associar uma fun\u00e7\u00e3o de callback , toda vez que o bot\u00e3o for encontrado, a fun\u00e7\u00e3o de callback pode ser executada! Modificar struct Criar uma fun\u00e7\u00e3o de callback por bot\u00e3o Modificar inicializa\u00e7\u00e3o associando essa fun\u00e7\u00e3o ponteiro de fun\u00e7\u00e3o Validar Tip Function Pointer in C Extras (A) No lugar dos bot\u00f5es terem cor podemos fazer com que eles tenham uma imagem associada! Que tal fazer isso? Tip SAME70-examples/Screens/RTOS-LCD-maxTouch-Images/","title":"RTOS - LCD"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/#rtos-lcd","text":"Nesse lab iremos trabalhar com o uso de um sistema operacional de tempo real (RTOS) para gerenciar o LCD max Touch, o forte desse lab ser\u00e1 a linguagem C e como estruturar um firmware. Preencher ao finalizar o lab Carregando\u2026","title":"RTOS - LCD"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/#lab","text":"LAB Labs/RTOS-LCD-maxTouch-Switch Executar demo do LCD com RTOS Trabalha com dados de touch e LCD","title":"LAB"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/#inicio","text":"LCD max Touch Plugue o LCD max Touch no EXT2. C\u00f3digo exemplo Copie o c\u00f3digo exemplo SAME70-examples/Screens/RTOS-LCD-maxTouch-Switch-Toggle/ para a pasta da entrega do seu reposit\u00f3rio Labs/RTOS-LCD-maxTouch-Switch Vamos modificar esse c\u00f3digo exemplo. Terminal Esse exemplo faz uso da comunica\u00e7\u00e3o UART para debug de c\u00f3digo (via printf), para acessar o terminal no atmel est\u00fadio clique em: View Terminal Window Configure o terminal para a porta que (COM) correta (verificar no windiows) e para operar com um BaudRate de 115200.","title":"In\u00edcio"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/#entendendo-o-exemplo","text":"Vamos entender o exemplo e como ele funciona! Nesse projeto temos duas tasks: task_mxt : Gerencia o touch do LCD task_lcd : Gerencia a escrita de informa\u00e7\u00e3o no LCD Essas tarefas se comunicam por uma fila chamada: xQueueTouch , onde a task mxt envia dados relativos ao touch ( x , y ) e a tarefa lcd coleta esses dados e processa o evento. Os dados da fila s\u00e3o um struct do tipo: typedef struct { uint x ; uint y ; } touchData ; O diagrama a seguir ilustra o firmware: Execute Programe o uC com o firmware exemplo Analise o resultado Entenda o c\u00f3digo","title":"Entendendo o exemplo"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/#modificando","text":"Vamos modificar esse c\u00f3digo, ele n\u00e3o foi implementando de uma forma que suporta expans\u00e3o.","title":"Modificando"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/#struct","text":"Vamos organiza os bot\u00f5es em uma struct, para ficar mais f\u00e1cil de criarmos novos bot\u00f5es, ou modificar os que j\u00e1 existem. Para isso, crie uma struct como a seguir: typedef struct { uint32_t width ; // largura (px) uint32_t height ; // altura (px) uint32_t colorOn ; // cor do bot\u00e3o acionado uint32_t colorOff ; // cor do bot\u00e3o desligado uint32_t x ; // posicao x uint32_t y ; // posicao y } t_but ; Note Estamos assumindo que o bot\u00e3o \u00e9 um ret\u00e2ngulo. Na task_lcd vamos criar o primeiro bot\u00e3o ( but0 ): t_but but0 = {. width = 120 , . height = 75 , . colorOn = COLOR_TOMATO , . colorOff = COLOR_BLACK , . x = ILI9488_LCD_WIDTH / 2 , . y = 40 }; Note Esses dados foram copiados da configura\u00e7\u00e3o dos bot\u00f5es j\u00e1 existentes no c\u00f3digo.","title":"struct"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/#draw_button_new","text":"E agora vamos criar uma fun\u00e7\u00e3o que recebe o tipo t_but e desenha o bot\u00e3o na tela: void draw_button_new ( t_but but , int status ){ uint32_t color ; if ( status ) color = but . colorOn ; else color = but . colorOff ; ili9488_set_foreground_color ( COLOR_CONVERT ( color )); ili9488_draw_filled_rectangle ( but . x - but . width / 2 , but . y - but . height / 2 , but . x + but . width / 2 , but . y + but . height / 2 ); } Vamos editar a task_lcd para chamar essa fun\u00e7\u00e3o rec\u00e9m criada com o but0 , ela deve ficar: void task_lcd ( void ){ xQueueTouch = xQueueCreate ( 10 , sizeof ( touchData ) ); configure_lcd (); draw_screen (); font_draw_text ( & digital52 , \"DEMO - BUT\" , 0 , 0 , 1 ); t_but but0 = {. width = 120 , . height = 75 , . colorOn = COLOR_TOMATO , . colorOff = COLOR_BLACK , . x = ILI9488_LCD_WIDTH / 2 , . y = 40 }; uint8_t but0_status = 1 ; draw_button_new ( but0 , but0_status ); // struct local para armazenar msg enviada pela task do mxt touchData touch ; while ( true ) { if ( xQueueReceive ( xQueueTouch , & ( touch ), ( TickType_t ) 500 / portTICK_PERIOD_MS )) { //update_screen(touch.x, touch.y); but0_status = ! but0_status ; draw_button_new ( but0 , but0_status ); printf ( \"x:%d y:%d \\n \" , touch . x , touch . y ); } } } Execute Fa\u00e7a as altera\u00e7\u00f5es no c\u00f3digo crie a struct t_but crie o but0 crie a fun\u00e7\u00e3o draw_button_new modifique a tarefa task_lcd Compile e programe o c\u00f3digo Verifique a funcionalidade do programa toque na tela, o bot\u00e3o deve mudar!","title":"draw_button_new"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/#melhorando-a-draw_button_new","text":"J\u00e1 que possu\u00edmos uma struct que guarda a informa\u00e7\u00e3o do bot\u00e3o, porque n\u00e3o guardar nela o status ( but0_status )? Vamos fazer, modificar a t_but inserindo um campo a mais uint8_t status e modificar a fun\u00e7\u00e3o que desenha o bot\u00e3o para n\u00e3o termos mais que passar o argumento on . void draw_button_new(t_but but){} Execute Fa\u00e7a as altera\u00e7\u00f5es no c\u00f3digo modifique t_but modifique a fun\u00e7\u00e3o draw_button_new() modifique a task_lcd para usar esse novo campo Programe e teste","title":"melhorando a draw_button_new"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/#novos-botoes","text":"Vamos criar dois novos bot\u00f5es ( but1 , but2 ), com as seguintes propriedades: but1 : colorOn: Escolher uma posi\u00e7\u00e3o y 140 but2 : colorOn: Escolher uma posi\u00e7\u00e3o y 240 o que n\u00e3o foi definido, copiar do bot\u00e3o 0 ( but0 ) Agora exiba os novos bot\u00f5es, e fa\u00e7a com que eles mudem o status quando toque na regi\u00e3o deles na tela! Execute Fa\u00e7a as altera\u00e7\u00f5es no c\u00f3digo crie but1 e but2 exiba os bot\u00f5es e fa\u00e7a eles mudarem o status Programe e teste","title":"Novos bot\u00f5es"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/#detectando-botao","text":"Vamos agora criar uma fun\u00e7\u00e3o que detecta qual bot\u00e3o foi pressionado, para isso, vamos criar um vetor de structs (cada index representa um bot\u00e3o) e passar para essa fun\u00e7\u00e3o o vetor e tamb\u00e9m o valor recebido pela fila do toque referente a x e y . na task_lcd Para criar o vetor de structs: t_but botoes [] = { but0 , but1 , but2 }; Tip Voc\u00ea tem no seu c\u00f3digo algo como isso: draw_button_new(but0); draw_button_new(but1); draw_button_new(but2); Pode mudar para um for varrendo o nosso novo vetor botoes . O c\u00f3digo vai ficar mais clean. Com o vetor criado, vamos criar a fun\u00e7\u00e3o que processa o touch, ela ser\u00e1 chamada de processa_touch e ter\u00e1 a seguinte implementa\u00e7\u00e3o: int process_touch(t_but botoes[], touchData touch, uint32_t n){ } Essa fun\u00e7\u00e3o recebe o vetor de structs e tamb\u00e9m a posi\u00e7\u00e3o na tela de onde ocorreu o toque ( touch.x , touch.y ). A fun\u00e7\u00e3o deve retornar ( int ) um valor ( 0 , 1 , 2 , ...) que indica qual bot\u00e3o que foi pressionado ou -1, indicando que nenhum bot\u00e3o satisfez o toque. n \u00e9 o tamanho do vetor botoes . Warning A fun\u00e7\u00e3o tem que ser gen\u00e9rica, suportando quantidade diferentes de bot\u00f5es e configura\u00e7\u00f5es diferentes de bot\u00f5es! N\u00e3o pode isso: \u200b Tip Abra o terminal uart do atmel, l\u00e1 voc\u00ea consegue ver os dados do touch: Com a fun\u00e7\u00e3o vamos agora alterar somente o status do bot\u00e3o que foi pressionado, para isso, voc\u00eas devem alterar o while(1) da fun\u00e7\u00e3o task_lcd , para chamar a process_touch . Uma sugest\u00e3o de como implementar isso a seguir: if ( xQueueReceive ( xQueueTouch , & ( touch ), ( TickType_t ) 500 / portTICK_PERIOD_MS )) { int b = process_touch ( botoes , touch ); if ( b >= 0 ){ botoes [ b ]. status = ! botoes [ b ]. status ; draw_button_new ( botoes [ b ]); } printf ( \"x:%d y:%d \\n \" , touch . x , touch . y ); } Execute Crie o vetor de bot\u00f5es Declare a fun\u00e7\u00e3o process_touch Implemente a fun\u00e7\u00e3o process_touch Programe e teste S\u00f3 o bot\u00e3o que for tocado deve mudar de status Tip Chegou at\u00e9 aqui? N\u00e3o esque\u00e7a de preencher o forms com a entrega!","title":"Detectando bot\u00e3o"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/#extras-c","text":"Adicione 2 novos bot\u00f5es!","title":"Extras (C+)"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/#extras-b","text":"Que tal que para cada bot\u00e3o associar uma fun\u00e7\u00e3o de callback , toda vez que o bot\u00e3o for encontrado, a fun\u00e7\u00e3o de callback pode ser executada! Modificar struct Criar uma fun\u00e7\u00e3o de callback por bot\u00e3o Modificar inicializa\u00e7\u00e3o associando essa fun\u00e7\u00e3o ponteiro de fun\u00e7\u00e3o Validar Tip Function Pointer in C","title":"Extras (B)"},{"location":"navigation/Labs/Lab_RTOS_LCD/Lab-RTOS-LCD/#extras-a","text":"No lugar dos bot\u00f5es terem cor podemos fazer com que eles tenham uma imagem associada! Que tal fazer isso? Tip SAME70-examples/Screens/RTOS-LCD-maxTouch-Images/","title":"Extras (A)"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/","text":"Lab - Parte 1 LAB Lab8-RTOS-LCD-LVGL Agora vamos come\u00e7ar mexer com o LVGL e criar nossa interface. A ideia \u00e9 recriar uma interface de um termostato inspirado no produto a seguir: KKmoon LCD Touch Screen Termostato Sistema de Aquecimento de Piso El\u00e9trico Aquecimento de \u00c1gua Termorregulador AC85-240 V Controlador de Temperatura Preto https://www.amazon.com.br/KKmoon-Aquecimento-Termorregulador-Controlador-Temperatura/dp/B07X3CDM83 Etapas Quando come\u00e7amos projetar uma interface homem m\u00e1quina (IHM) \u00e9 necess\u00e1rio analisarmos v\u00e1rias frentes: Usabilidade Acessibilidade Branding Implementa\u00e7\u00e3o A usabilidade ir\u00e1 indicar como as fun\u00e7\u00f5es do produto estar\u00e3o dispon\u00edveis e ser\u00e3o exibidas aos usu\u00e1rios, isso deve estar atrelada aos conceitos da marca do produto. O p\u00fablico alvo deve ser analisado e o produto deve ser acess\u00edvel, para isso, muitos testes de usabilidade devem ser feitos para validar o conceito. Muitas vezes o prot\u00f3tipo da interface esbarra em problemas t\u00e9cnicos e de implementa\u00e7\u00e3o, muitas imagens e fontes impactam no tamanho total do firmware que pode impossibilitar a implementa\u00e7\u00e3o da interface proposta, ou necessitar a adi\u00e7\u00e3o de formas alternativas de armazenamento de dados. Microcontroladores de forma geral n\u00e3o possuem GPU (alguns sim, exemplo: STM32MP157 ) e isso impacta na performance da interface e muito provavelmente no gasto energ\u00e9tico. Implementando Tip Vamos usar muito a documenta\u00e7\u00e3o do lvgl \u00e9 importante que voc\u00ea tenha o site aberto e a consulte sempre: https://docs.lvgl.io/8/ O LVGL possui vasta documenta\u00e7\u00e3o e muitos bons exemplos (testamos v\u00e1rios e todos funcionaram no embarcado), neste laborat\u00f3rio iremos usar alguns widgets do LVGL e aos poucos vamos customizando eles. Preparando firmware Vamos criar uma nova fun\u00e7\u00e3o chamada de void lv_termostato(void){ } onde iremos fazer a implementa\u00e7\u00e3o da interface do termostato. Al\u00e9m de criarmos esta fun\u00e7\u00e3o, teremos que modificar a task_lcd para chamar a nova fun\u00e7\u00e3o. Tarefa Modifique o fimrware original incluindo a fun\u00e7\u00e3o lv_termostato e modificando a task_lcd : +void lv_termostato(void) { + lv_obj_t * labelBtn1; + lv_obj_t * btn1 = lv_btn_create(lv_scr_act()); + lv_obj_add_event_cb(btn1, event_handler, LV_EVENT_ALL, NULL); + lv_obj_align(btn1, LV_ALIGN_CENTER, 0, -40); + labelBtn1 = lv_label_create(btn1); + lv_label_set_text(labelBtn1, \"Teste\"); + lv_obj_center(labelBtn1); + +} static void task_lcd(void *pvParameters) { - lv_ex_btn_1(); + lv_termostato(); .... .... } Progress Conclua as tarefas antes de prosseguir. Background Notem que a interface a ser recriada possui fundo preto, para atingirmos tal objetivo com o LVGL iremos modificar a configura\u00e7\u00e3o padr\u00e3o do LVGL que est\u00e1 localizada em config/lv_conf.h . Neste arquivo procure pelo define LV_THEME_DEFAULT_DARK e modifique para 1. Tarefa Modifique o define LV_THEME_DEFAULT_DARK de 0 para 1 Teste no uC Agora deve estar mostrando um fundo preto. Progress Conclua as tarefas antes de prosseguir. Tamanho da fonte Voc\u00eas notaram que a fonte padr\u00e3o do LCD est\u00e1 meio pequena? Conseguimos ajustar isso no LVGL escolhendo uma fonte maior. O LVGL disponibiliza alguns tamanhos de fonte de uma mesma classe (MontSerrat). A lista de fontes est\u00e1 no arquivo de configura\u00e7\u00e3o src/config/lv_conf.h . Neste arquivo voc\u00ea deve encontrar algo como: 289 290 291 292 293 294 295 296 297 298 299 300 /*Montserrat fonts with ASCII range and some symbols using bpp = 4 *https://fonts.google.com/specimen/Montserrat*/ #define LV_FONT_MONTSERRAT_8 0 #define LV_FONT_MONTSERRAT_10 0 #define LV_FONT_MONTSERRAT_12 0 #define LV_FONT_MONTSERRAT_14 1 #define LV_FONT_MONTSERRAT_16 0 #define LV_FONT_MONTSERRAT_18 0 #define LV_FONT_MONTSERRAT_20 0 #define LV_FONT_MONTSERRAT_22 0 #define LV_FONT_MONTSERRAT_24 0 ... Para recriar a interface iremos usar um tamanho de fonte um pouco maior que o padr\u00e3o (14) do LVGL, para isso iremos utilizar a fonte de tamanho 24. Isso \u00e9 feito em duas etapas: Ativando a fonte no arquivo de configura\u00e7\u00e3o Configurando a nova fonte como padr\u00e3o Sistemas Embarcados O LVGL n\u00e3o inclui todas as fontes por padr\u00e3o (para o c\u00f3digo n\u00e3o ficar muito grande). Sistemas embarcados sofrem com falta de mem\u00f3ria. Fonte padr\u00e3o Program Memory Usage 14 Program Memory Usage : 235852 bytes 11,2 % Full 24 Program Memory Usage : 250904 bytes 12,0 % Full O LVGL n\u00e3o lida com fontes de forma avan\u00e7ada, cada letra da fonte \u00e9 uma matriz que cont\u00e9m os pixels a serem associados. Quanto maior a fonte maior precisa ser essa matriz e mais mem\u00f3ria de programa utiliza. Parece pouca diferen\u00e7a n\u00e9? Mas n\u00e3o \u00e9! Vamos sofrer um pouco com isso na nossa pr\u00f3xima APS. Tarefa Modifique o arquivo lv_conf.h para: Incluir a fonte tamanho 24 no projeto #define LV_FONT_MONTSERRAT_12 0 #define LV_FONT_MONTSERRAT_14 0 ... +#define LV_FONT_MONTSERRAT_24 1 Torne a fonte tamanho 24 padr\u00e3o /*Always set a default font*/ +#define LV_FONT_DEFAULT &lv_font_montserrat_24 Teste no uC. Progress Conclua as tarefas antes de prosseguir. Identificando widgets A primeira etapa ap\u00f3s ter a interface definida \u00e9 identificar quais widgets podem ser utilizados para montar a interface. Exercise Identifique quais widgets voc\u00ea usaria para reconstruir a imagem a seguir: Tip Acesse a p\u00e1gina do LVGL e de uma explorada nos widths que est\u00e3o dispon\u00edveis: https://docs.lvgl.io/master/widgets/core/index.html Answer Podemos construir a tela toda usando apenas Bot\u00f5es e Labels. (a): lv_label (b): lv_button Os bot\u00f5es que incluem uma imagem, como o de power, mem\u00f3ria, ...., podem ser bot\u00f5es com \"s\u00edmbolos\" no lugar do texto. Progress Click para continuar.... Bot\u00f5es https://docs.lvgl.io/master/widgets/btn.html O lv_button permite que criemos um ou mais bot\u00f5es, os bot\u00f5es podem ou n\u00e3o ter um label associado a ele. Podemos associar para cada bot\u00e3o uma fun\u00e7\u00e3o de handler que ser\u00e1 chamada assim que um evento neste bot\u00e3o for detectado, a seguir alguns eventos que podem ser gerados por um objeto: LV_EVENT_PRESSED An object has been pressed LV_EVENT_PRESSING An object is being pressed (called continuously while pressing) LV_EVENT_PRESS_LOST An object is still being pressed but slid cursor/finger off of the object LV_EVENT_SHORT_CLICKED An object was pressed for a short period of time, then released. Not called if scrolled. LV_EVENT_LONG_PRESSED An object has been pressed for at least the long_press_time specified in the input device driver. Not called if scrolled. A lista completa pode ser acessada na p\u00e1gina de Events: https://docs.lvgl.io/master/overview/event.html O exemplo fornecido na fun\u00e7\u00e3o ( lv_ex_btn_1 ) cria um bot\u00e3o chamado btn1 e o alinha no centro da tela, a fun\u00e7\u00e3o event_handler foi associada como callback deste widget, assim que um evento ocorrer a mesma ser\u00e1 executada. lv_obj_t * btn1 = lv_btn_create ( lv_scr_act ()); lv_obj_add_event_cb ( btn1 , event_handler , LV_EVENT_ALL , NULL ); lv_obj_align ( btn1 , LV_ALIGN_CENTER , 0 , -40 ); Depois cria um label e o associa ao bot\u00e3o: label = lv_label_create ( btn1 ); lv_label_set_text ( label , \"Teste\" ); lv_obj_center ( label ); Conforme a documenta\u00e7\u00e3o do lvgl para objetos Podemos alinhar um objeto em v\u00e1rios locais diferentes na tela. Isso \u00e9 feito pela fun\u00e7\u00e3o lv_obj_align(obj, obj_ref, LV_ALIGN_________, x_ofs, y_ofs) que recebe como par\u00e2metro: obj is the object to align. obj_ref is a reference object. obj will be aligned to it. If obj_ref = NULL , then the parent of obj will be used. The third argument is the type of alignment. These are the possible options: Extra\u00eddo da documenta\u00e7\u00e3o. Progress Click para continuar.... Bot\u00e3o de power Agora vamos criar os bot\u00f5es da interface proposta, primeiro iremos criar o bot\u00e3o de power modificando o bot\u00e3o atual de teste. 1. Posi\u00e7\u00e3o Na primeira etapa iremos alinhar o bot\u00e3o no canto inferior esquerdo conforme figura a seguir: Um objeto pode ser alinhado com rela\u00e7\u00e3o a um screen ou a um outro objetivo de refer\u00eancia. Nesse caso vamos usar o bot\u00e3o de power alinhado ao canto inferior da tela. Para alinhar com rela\u00e7\u00e3o a tela usar: lv_obj_align(obj, align, x, y); Para alinhar com rela\u00e7\u00e3o a outro objeto usar: lv_obj_align_to(obj_to_align, reference_obj, align, x, y); Os par\u00e2metros X e Y s\u00e3o um deslocamento do alinhamento e o argumento aling pode ser qualquer uma dos itens a seguir: Interno Utilizando a refer\u00eancia interna de um objeto: LV_ALIGN_TOP_LEFT LV_ALIGN_TOP_MID LV_ALIGN_TOP_RIGHT LV_ALIGN_BOTTOM_LEFT LV_ALIGN_BOTTOM_MID LV_ALIGN_BOTTOM_RIGHT LV_ALIGN_LEFT_MID LV_ALIGN_RIGHT_MID LV_ALIGN_CENTER Externo Utilizando a refer\u00eancia externa de um objeto: LV_ALIGN_OUT_TOP_LEFT LV_ALIGN_OUT_TOP_MID LV_ALIGN_OUT_TOP_RIGHT LV_ALIGN_OUT_BOTTOM_LEFT LV_ALIGN_OUT_BOTTOM_MID LV_ALIGN_OUT_BOTTOM_RIGHT LV_ALIGN_OUT_LEFT_TOP LV_ALIGN_OUT_LEFT_MID LV_ALIGN_OUT_LEFT_BOTTOM LV_ALIGN_OUT_RIGHT_TOP LV_ALIGN_OUT_RIGHT_MID LV_ALIGN_OUT_RIGHT_BOTTOM Pergunta Supondo dois objetos como ilustrado a seguir. Qual deve ser a fun\u00e7\u00e3o para alinharmos o obj2 ao lado do obj1? A ideia \u00e9 usar o btn1 como refer\u00eancia. +-------++-------+ | btn1 || btn2 | | || | +-------++-------+ lv_obj_align_to(btn1, btn2, LV_ALIGN_BOTTOM_RIGHT, 0, 0); lv_obj_align_to(btn2, btn1, LV_ALIGN_BOTTOM_RIGHT, 0, 0); lv_obj_align_to(btn2, btn1, LV_ALIGN_RIGHT, 0, 0); lv_obj_align_to(btn1, btn2, LV_ALIGN_RIGHT, 0, 0); Answer O primeiro parametro \u00e9 o obj a ser alinhado: obj2 O segundo o obj a ser usado de refer\u00eancia: obj1 Queremos alinhas a direita e no meio. Queremos o bot\u00e3o 2 \"colado\" no bot\u00e3o 1 Exercise Supondo dois objetos como ilustrado a seguir. Qual deve ser a fun\u00e7\u00e3o para alinharmos o obj2 ao lado do obj1? A ideia \u00e9 usar o btn1 como refer\u00eancia. +-------+ | btn1 | | | +-------+ +-------+ | btn2 | | | +-------+ lv_obj_align_to(btn1, btn2, LV_ALIGN_BOTTOM_RIGHT, 0, 0); lv_obj_align_to(btn2, btn1, LV_ALIGN_BOTTOM_RIGHT, 0, 0); lv_obj_align_to(btn2, btn1, LV_ALIGN_RIGHT, 0, 0); lv_obj_align_to(btn2, btn1, LV_ALIGN_RIGHT, 0, 0); Answer Agora o truque \u00e9 que queremos alinhar com o \"Bottom\" do bot\u00e3o 1. Por isso usamos o LV_ALIGN_BOTTOM_RIGHT Progress Click para continuar.... Exercise Alinhe o bot\u00e3o btn1 da fun\u00e7\u00e3o lv_termostato para o canto esquerdo inferior da tela. Use a func\u00e3o lv_obj_align (a refer\u00eancia vai ser a tela). Notem que o bot\u00e3o original da figura est\u00e1 um pouco deslocado para direita e para cima. Modifiquem o X e o Y da func\u00e3o para obterem esse comportamento. Teste no uC Progress Click para continuar.... 2. Label/ S\u00edmbolo No nosso c\u00f3digo colocamos um \"Label\" dentro do objeto do bot\u00e3o, \u00e9 por isso que aparecer o texto \"Teste\" no bot\u00e3o: labelBtn1 = lv_label_create ( btn1 ); lv_label_set_text ( labelBtn1 , \"[ \" LV_SYMBOL_POWER ); lv_obj_center ( labelBtn1 ); Notem que utilizamos o lv_lavel_create e passamos o btn1 para a func\u00e3o. Isso faz com que o label perten\u0107a ao objeto btn1. Agora vamos trocar o label do btn1 para ser mais condizente com o do nosso modelo de refer\u00eancia. No LVGL podemos utilizar alguns s\u00edmbolos j\u00e1 pr\u00e9 definidos, os detalhes est\u00e3o na documenta\u00e7\u00e3o de fonts e listados aqui: Notem que podemos usar o s\u00edmbolo LV_SYMBOL_POWER para recriar o bot\u00e3o da interface planejada, para isso \u00e9 necess\u00e1rio alterar a linha que estamos escrevendo Teste para usar o s\u00edmbolo em quest\u00e3o. Por exemplo, para adicionarmos o [ seguido do s\u00edmbolo de power: lv_label_set_text ( labelBtn1 , \"[ \" LV_SYMBOL_POWER ); Voc\u00eas podem definir o label como vari\u00e1vel global, permitindo assim que outra parte do c\u00f3digo altera o valor escrito. // global static lv_obj_t * labelBtn1 ; Task Altere o label para ser global Modifique o label do bot\u00e3o para mostrar o [ \u23fb Teste na placa Tip O truque aqui foi juntar o [ e o power no mesmo bot\u00e3o, +--------+ | | | [ \u23fb | | | +--------+ ^ | Bot\u00e3o Poder\u00edamos ter feito diferente: +-------++-------+ | || | | [ || \u23fb | | || | +-------++-------+ ^ ^ | | Bot\u00e3o | Apenas um label Progress Click para continuar.... 3. Formatando Iremos agora criar um estilo pr\u00f3prio e aplicar no bot\u00e3o, um estilo pode conter v\u00e1rias configura\u00e7\u00f5es de Tema para um objeto (ou para v\u00e1rios). O exemplo a seguir cria um style com um fundo ROXO e uma borda VERDE. void lv_termostato ( void ) { static lv_style_t style ; lv_style_init ( & style ); lv_style_set_bg_color ( & style , lv_palette_main ( LV_PALETTE_PURPLE )); lv_style_set_border_color ( & style , lv_palette_main ( LV_PALETTE_GREEN )); lv_style_set_border_width ( & style , 5 ); E ent\u00e3o aplicamos o novo estilo ao bot\u00e3o: lv_obj_t * btn1 = lv_btn_create(lv_scr_act()); lv_obj_add_event_cb(btn1, event_handler, LV_EVENT_ALL, NULL); lv_obj_align(btn1, LV_ALIGN_BOTTOM_LEFT, 0, 0); + lv_obj_add_style(btn1, &style, 0); Tamb\u00e9m podemos mudar o tamanho de um objeto, como no exemplo a seguir: lv_obj_set_width(btn1, 60); lv_obj_set_height(btn1, 60); Cores Existem cores pr\u00e9 definidas no LVGL e para cada cor uma plate entre no link a seguir para acessar a paleta: https://docs.lvgl.io/master/overview/color.html#palette Para usar branco ou preto existe uma fun\u00e7\u00e3o: lv_color_white() lv_color_black() Se quiser, pode formatar a sua pr\u00f3pria cor em RGB, usando: lv_color_make(red, green, blue); Task Crie um novo tema para o bot\u00e3o faca sentido para o nosso termostato. Precisamos de fundo preto e sem borda! Crie o novo estilo Aplique ao bot\u00e3o Teste e verifique o resultado Progress Click para continuar.... Demais bot\u00f5es Tarefa: Demais bot\u00f5es Agora voc\u00ea \u00e9 capaz de recriar os demais bot\u00f5es da interface, para cada bot\u00e3o crie uma fun\u00e7\u00e3o de callback (similar ao event_handler ). Implemente: M ( btnMenu / menu_handler ): Menu Clock ( btnClk / clk_handler ): Rel\u00f3gio ^ ( btnUp / up_handler ): Aumentar (temperatura/ alarme): v ( btnDown / down_handler ): Baixar (temperatura/ alarme) Lembre de testar na placa! Vai precisar de ajustes. Tip Handlers: Crie um handler diferente por bot\u00e3o. Alinhamento: Pense em como usar o alinhamento a seu favor. S\u00edmbolos: Rel\u00f3gio: Voc\u00ea pode usar um outro s\u00edmbolo no lugar. v, ^: Tem s\u00edmbolos prontos para isso Resultado esperado: O seu pode ficar diferente, mas lembre que a ideia \u00e9 chegar o mais perto do que da nossa referencia! Meu Referencia","title":"Lab - Parte 1"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/#lab-parte-1","text":"LAB Lab8-RTOS-LCD-LVGL Agora vamos come\u00e7ar mexer com o LVGL e criar nossa interface. A ideia \u00e9 recriar uma interface de um termostato inspirado no produto a seguir: KKmoon LCD Touch Screen Termostato Sistema de Aquecimento de Piso El\u00e9trico Aquecimento de \u00c1gua Termorregulador AC85-240 V Controlador de Temperatura Preto https://www.amazon.com.br/KKmoon-Aquecimento-Termorregulador-Controlador-Temperatura/dp/B07X3CDM83","title":"Lab - Parte 1"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/#etapas","text":"Quando come\u00e7amos projetar uma interface homem m\u00e1quina (IHM) \u00e9 necess\u00e1rio analisarmos v\u00e1rias frentes: Usabilidade Acessibilidade Branding Implementa\u00e7\u00e3o A usabilidade ir\u00e1 indicar como as fun\u00e7\u00f5es do produto estar\u00e3o dispon\u00edveis e ser\u00e3o exibidas aos usu\u00e1rios, isso deve estar atrelada aos conceitos da marca do produto. O p\u00fablico alvo deve ser analisado e o produto deve ser acess\u00edvel, para isso, muitos testes de usabilidade devem ser feitos para validar o conceito. Muitas vezes o prot\u00f3tipo da interface esbarra em problemas t\u00e9cnicos e de implementa\u00e7\u00e3o, muitas imagens e fontes impactam no tamanho total do firmware que pode impossibilitar a implementa\u00e7\u00e3o da interface proposta, ou necessitar a adi\u00e7\u00e3o de formas alternativas de armazenamento de dados. Microcontroladores de forma geral n\u00e3o possuem GPU (alguns sim, exemplo: STM32MP157 ) e isso impacta na performance da interface e muito provavelmente no gasto energ\u00e9tico.","title":"Etapas"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/#implementando","text":"Tip Vamos usar muito a documenta\u00e7\u00e3o do lvgl \u00e9 importante que voc\u00ea tenha o site aberto e a consulte sempre: https://docs.lvgl.io/8/ O LVGL possui vasta documenta\u00e7\u00e3o e muitos bons exemplos (testamos v\u00e1rios e todos funcionaram no embarcado), neste laborat\u00f3rio iremos usar alguns widgets do LVGL e aos poucos vamos customizando eles.","title":"Implementando"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/#preparando-firmware","text":"Vamos criar uma nova fun\u00e7\u00e3o chamada de void lv_termostato(void){ } onde iremos fazer a implementa\u00e7\u00e3o da interface do termostato. Al\u00e9m de criarmos esta fun\u00e7\u00e3o, teremos que modificar a task_lcd para chamar a nova fun\u00e7\u00e3o. Tarefa Modifique o fimrware original incluindo a fun\u00e7\u00e3o lv_termostato e modificando a task_lcd : +void lv_termostato(void) { + lv_obj_t * labelBtn1; + lv_obj_t * btn1 = lv_btn_create(lv_scr_act()); + lv_obj_add_event_cb(btn1, event_handler, LV_EVENT_ALL, NULL); + lv_obj_align(btn1, LV_ALIGN_CENTER, 0, -40); + labelBtn1 = lv_label_create(btn1); + lv_label_set_text(labelBtn1, \"Teste\"); + lv_obj_center(labelBtn1); + +} static void task_lcd(void *pvParameters) { - lv_ex_btn_1(); + lv_termostato(); .... .... } Progress Conclua as tarefas antes de prosseguir.","title":"Preparando firmware"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/#background","text":"Notem que a interface a ser recriada possui fundo preto, para atingirmos tal objetivo com o LVGL iremos modificar a configura\u00e7\u00e3o padr\u00e3o do LVGL que est\u00e1 localizada em config/lv_conf.h . Neste arquivo procure pelo define LV_THEME_DEFAULT_DARK e modifique para 1. Tarefa Modifique o define LV_THEME_DEFAULT_DARK de 0 para 1 Teste no uC Agora deve estar mostrando um fundo preto. Progress Conclua as tarefas antes de prosseguir.","title":"Background"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/#tamanho-da-fonte","text":"Voc\u00eas notaram que a fonte padr\u00e3o do LCD est\u00e1 meio pequena? Conseguimos ajustar isso no LVGL escolhendo uma fonte maior. O LVGL disponibiliza alguns tamanhos de fonte de uma mesma classe (MontSerrat). A lista de fontes est\u00e1 no arquivo de configura\u00e7\u00e3o src/config/lv_conf.h . Neste arquivo voc\u00ea deve encontrar algo como: 289 290 291 292 293 294 295 296 297 298 299 300 /*Montserrat fonts with ASCII range and some symbols using bpp = 4 *https://fonts.google.com/specimen/Montserrat*/ #define LV_FONT_MONTSERRAT_8 0 #define LV_FONT_MONTSERRAT_10 0 #define LV_FONT_MONTSERRAT_12 0 #define LV_FONT_MONTSERRAT_14 1 #define LV_FONT_MONTSERRAT_16 0 #define LV_FONT_MONTSERRAT_18 0 #define LV_FONT_MONTSERRAT_20 0 #define LV_FONT_MONTSERRAT_22 0 #define LV_FONT_MONTSERRAT_24 0 ... Para recriar a interface iremos usar um tamanho de fonte um pouco maior que o padr\u00e3o (14) do LVGL, para isso iremos utilizar a fonte de tamanho 24. Isso \u00e9 feito em duas etapas: Ativando a fonte no arquivo de configura\u00e7\u00e3o Configurando a nova fonte como padr\u00e3o Sistemas Embarcados O LVGL n\u00e3o inclui todas as fontes por padr\u00e3o (para o c\u00f3digo n\u00e3o ficar muito grande). Sistemas embarcados sofrem com falta de mem\u00f3ria. Fonte padr\u00e3o Program Memory Usage 14 Program Memory Usage : 235852 bytes 11,2 % Full 24 Program Memory Usage : 250904 bytes 12,0 % Full O LVGL n\u00e3o lida com fontes de forma avan\u00e7ada, cada letra da fonte \u00e9 uma matriz que cont\u00e9m os pixels a serem associados. Quanto maior a fonte maior precisa ser essa matriz e mais mem\u00f3ria de programa utiliza. Parece pouca diferen\u00e7a n\u00e9? Mas n\u00e3o \u00e9! Vamos sofrer um pouco com isso na nossa pr\u00f3xima APS. Tarefa Modifique o arquivo lv_conf.h para: Incluir a fonte tamanho 24 no projeto #define LV_FONT_MONTSERRAT_12 0 #define LV_FONT_MONTSERRAT_14 0 ... +#define LV_FONT_MONTSERRAT_24 1 Torne a fonte tamanho 24 padr\u00e3o /*Always set a default font*/ +#define LV_FONT_DEFAULT &lv_font_montserrat_24 Teste no uC. Progress Conclua as tarefas antes de prosseguir.","title":"Tamanho da fonte"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/#identificando-widgets","text":"A primeira etapa ap\u00f3s ter a interface definida \u00e9 identificar quais widgets podem ser utilizados para montar a interface. Exercise Identifique quais widgets voc\u00ea usaria para reconstruir a imagem a seguir: Tip Acesse a p\u00e1gina do LVGL e de uma explorada nos widths que est\u00e3o dispon\u00edveis: https://docs.lvgl.io/master/widgets/core/index.html Answer Podemos construir a tela toda usando apenas Bot\u00f5es e Labels. (a): lv_label (b): lv_button Os bot\u00f5es que incluem uma imagem, como o de power, mem\u00f3ria, ...., podem ser bot\u00f5es com \"s\u00edmbolos\" no lugar do texto. Progress Click para continuar....","title":"Identificando widgets"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/#botoes","text":"https://docs.lvgl.io/master/widgets/btn.html O lv_button permite que criemos um ou mais bot\u00f5es, os bot\u00f5es podem ou n\u00e3o ter um label associado a ele. Podemos associar para cada bot\u00e3o uma fun\u00e7\u00e3o de handler que ser\u00e1 chamada assim que um evento neste bot\u00e3o for detectado, a seguir alguns eventos que podem ser gerados por um objeto: LV_EVENT_PRESSED An object has been pressed LV_EVENT_PRESSING An object is being pressed (called continuously while pressing) LV_EVENT_PRESS_LOST An object is still being pressed but slid cursor/finger off of the object LV_EVENT_SHORT_CLICKED An object was pressed for a short period of time, then released. Not called if scrolled. LV_EVENT_LONG_PRESSED An object has been pressed for at least the long_press_time specified in the input device driver. Not called if scrolled. A lista completa pode ser acessada na p\u00e1gina de Events: https://docs.lvgl.io/master/overview/event.html O exemplo fornecido na fun\u00e7\u00e3o ( lv_ex_btn_1 ) cria um bot\u00e3o chamado btn1 e o alinha no centro da tela, a fun\u00e7\u00e3o event_handler foi associada como callback deste widget, assim que um evento ocorrer a mesma ser\u00e1 executada. lv_obj_t * btn1 = lv_btn_create ( lv_scr_act ()); lv_obj_add_event_cb ( btn1 , event_handler , LV_EVENT_ALL , NULL ); lv_obj_align ( btn1 , LV_ALIGN_CENTER , 0 , -40 ); Depois cria um label e o associa ao bot\u00e3o: label = lv_label_create ( btn1 ); lv_label_set_text ( label , \"Teste\" ); lv_obj_center ( label ); Conforme a documenta\u00e7\u00e3o do lvgl para objetos Podemos alinhar um objeto em v\u00e1rios locais diferentes na tela. Isso \u00e9 feito pela fun\u00e7\u00e3o lv_obj_align(obj, obj_ref, LV_ALIGN_________, x_ofs, y_ofs) que recebe como par\u00e2metro: obj is the object to align. obj_ref is a reference object. obj will be aligned to it. If obj_ref = NULL , then the parent of obj will be used. The third argument is the type of alignment. These are the possible options: Extra\u00eddo da documenta\u00e7\u00e3o. Progress Click para continuar....","title":"Bot\u00f5es"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/#botao-de-power","text":"Agora vamos criar os bot\u00f5es da interface proposta, primeiro iremos criar o bot\u00e3o de power modificando o bot\u00e3o atual de teste.","title":"Bot\u00e3o de power"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/#1-posicao","text":"Na primeira etapa iremos alinhar o bot\u00e3o no canto inferior esquerdo conforme figura a seguir: Um objeto pode ser alinhado com rela\u00e7\u00e3o a um screen ou a um outro objetivo de refer\u00eancia. Nesse caso vamos usar o bot\u00e3o de power alinhado ao canto inferior da tela. Para alinhar com rela\u00e7\u00e3o a tela usar: lv_obj_align(obj, align, x, y); Para alinhar com rela\u00e7\u00e3o a outro objeto usar: lv_obj_align_to(obj_to_align, reference_obj, align, x, y); Os par\u00e2metros X e Y s\u00e3o um deslocamento do alinhamento e o argumento aling pode ser qualquer uma dos itens a seguir: Interno Utilizando a refer\u00eancia interna de um objeto: LV_ALIGN_TOP_LEFT LV_ALIGN_TOP_MID LV_ALIGN_TOP_RIGHT LV_ALIGN_BOTTOM_LEFT LV_ALIGN_BOTTOM_MID LV_ALIGN_BOTTOM_RIGHT LV_ALIGN_LEFT_MID LV_ALIGN_RIGHT_MID LV_ALIGN_CENTER Externo Utilizando a refer\u00eancia externa de um objeto: LV_ALIGN_OUT_TOP_LEFT LV_ALIGN_OUT_TOP_MID LV_ALIGN_OUT_TOP_RIGHT LV_ALIGN_OUT_BOTTOM_LEFT LV_ALIGN_OUT_BOTTOM_MID LV_ALIGN_OUT_BOTTOM_RIGHT LV_ALIGN_OUT_LEFT_TOP LV_ALIGN_OUT_LEFT_MID LV_ALIGN_OUT_LEFT_BOTTOM LV_ALIGN_OUT_RIGHT_TOP LV_ALIGN_OUT_RIGHT_MID LV_ALIGN_OUT_RIGHT_BOTTOM Pergunta Supondo dois objetos como ilustrado a seguir. Qual deve ser a fun\u00e7\u00e3o para alinharmos o obj2 ao lado do obj1? A ideia \u00e9 usar o btn1 como refer\u00eancia. +-------++-------+ | btn1 || btn2 | | || | +-------++-------+ lv_obj_align_to(btn1, btn2, LV_ALIGN_BOTTOM_RIGHT, 0, 0); lv_obj_align_to(btn2, btn1, LV_ALIGN_BOTTOM_RIGHT, 0, 0); lv_obj_align_to(btn2, btn1, LV_ALIGN_RIGHT, 0, 0); lv_obj_align_to(btn1, btn2, LV_ALIGN_RIGHT, 0, 0); Answer O primeiro parametro \u00e9 o obj a ser alinhado: obj2 O segundo o obj a ser usado de refer\u00eancia: obj1 Queremos alinhas a direita e no meio. Queremos o bot\u00e3o 2 \"colado\" no bot\u00e3o 1 Exercise Supondo dois objetos como ilustrado a seguir. Qual deve ser a fun\u00e7\u00e3o para alinharmos o obj2 ao lado do obj1? A ideia \u00e9 usar o btn1 como refer\u00eancia. +-------+ | btn1 | | | +-------+ +-------+ | btn2 | | | +-------+ lv_obj_align_to(btn1, btn2, LV_ALIGN_BOTTOM_RIGHT, 0, 0); lv_obj_align_to(btn2, btn1, LV_ALIGN_BOTTOM_RIGHT, 0, 0); lv_obj_align_to(btn2, btn1, LV_ALIGN_RIGHT, 0, 0); lv_obj_align_to(btn2, btn1, LV_ALIGN_RIGHT, 0, 0); Answer Agora o truque \u00e9 que queremos alinhar com o \"Bottom\" do bot\u00e3o 1. Por isso usamos o LV_ALIGN_BOTTOM_RIGHT Progress Click para continuar.... Exercise Alinhe o bot\u00e3o btn1 da fun\u00e7\u00e3o lv_termostato para o canto esquerdo inferior da tela. Use a func\u00e3o lv_obj_align (a refer\u00eancia vai ser a tela). Notem que o bot\u00e3o original da figura est\u00e1 um pouco deslocado para direita e para cima. Modifiquem o X e o Y da func\u00e3o para obterem esse comportamento. Teste no uC Progress Click para continuar....","title":"1. Posi\u00e7\u00e3o"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/#2-label-simbolo","text":"No nosso c\u00f3digo colocamos um \"Label\" dentro do objeto do bot\u00e3o, \u00e9 por isso que aparecer o texto \"Teste\" no bot\u00e3o: labelBtn1 = lv_label_create ( btn1 ); lv_label_set_text ( labelBtn1 , \"[ \" LV_SYMBOL_POWER ); lv_obj_center ( labelBtn1 ); Notem que utilizamos o lv_lavel_create e passamos o btn1 para a func\u00e3o. Isso faz com que o label perten\u0107a ao objeto btn1. Agora vamos trocar o label do btn1 para ser mais condizente com o do nosso modelo de refer\u00eancia. No LVGL podemos utilizar alguns s\u00edmbolos j\u00e1 pr\u00e9 definidos, os detalhes est\u00e3o na documenta\u00e7\u00e3o de fonts e listados aqui: Notem que podemos usar o s\u00edmbolo LV_SYMBOL_POWER para recriar o bot\u00e3o da interface planejada, para isso \u00e9 necess\u00e1rio alterar a linha que estamos escrevendo Teste para usar o s\u00edmbolo em quest\u00e3o. Por exemplo, para adicionarmos o [ seguido do s\u00edmbolo de power: lv_label_set_text ( labelBtn1 , \"[ \" LV_SYMBOL_POWER ); Voc\u00eas podem definir o label como vari\u00e1vel global, permitindo assim que outra parte do c\u00f3digo altera o valor escrito. // global static lv_obj_t * labelBtn1 ; Task Altere o label para ser global Modifique o label do bot\u00e3o para mostrar o [ \u23fb Teste na placa Tip O truque aqui foi juntar o [ e o power no mesmo bot\u00e3o, +--------+ | | | [ \u23fb | | | +--------+ ^ | Bot\u00e3o Poder\u00edamos ter feito diferente: +-------++-------+ | || | | [ || \u23fb | | || | +-------++-------+ ^ ^ | | Bot\u00e3o | Apenas um label Progress Click para continuar....","title":"2. Label/ S\u00edmbolo"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/#3-formatando","text":"Iremos agora criar um estilo pr\u00f3prio e aplicar no bot\u00e3o, um estilo pode conter v\u00e1rias configura\u00e7\u00f5es de Tema para um objeto (ou para v\u00e1rios). O exemplo a seguir cria um style com um fundo ROXO e uma borda VERDE. void lv_termostato ( void ) { static lv_style_t style ; lv_style_init ( & style ); lv_style_set_bg_color ( & style , lv_palette_main ( LV_PALETTE_PURPLE )); lv_style_set_border_color ( & style , lv_palette_main ( LV_PALETTE_GREEN )); lv_style_set_border_width ( & style , 5 ); E ent\u00e3o aplicamos o novo estilo ao bot\u00e3o: lv_obj_t * btn1 = lv_btn_create(lv_scr_act()); lv_obj_add_event_cb(btn1, event_handler, LV_EVENT_ALL, NULL); lv_obj_align(btn1, LV_ALIGN_BOTTOM_LEFT, 0, 0); + lv_obj_add_style(btn1, &style, 0); Tamb\u00e9m podemos mudar o tamanho de um objeto, como no exemplo a seguir: lv_obj_set_width(btn1, 60); lv_obj_set_height(btn1, 60); Cores Existem cores pr\u00e9 definidas no LVGL e para cada cor uma plate entre no link a seguir para acessar a paleta: https://docs.lvgl.io/master/overview/color.html#palette Para usar branco ou preto existe uma fun\u00e7\u00e3o: lv_color_white() lv_color_black() Se quiser, pode formatar a sua pr\u00f3pria cor em RGB, usando: lv_color_make(red, green, blue); Task Crie um novo tema para o bot\u00e3o faca sentido para o nosso termostato. Precisamos de fundo preto e sem borda! Crie o novo estilo Aplique ao bot\u00e3o Teste e verifique o resultado Progress Click para continuar....","title":"3. Formatando"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB/#demais-botoes","text":"Tarefa: Demais bot\u00f5es Agora voc\u00ea \u00e9 capaz de recriar os demais bot\u00f5es da interface, para cada bot\u00e3o crie uma fun\u00e7\u00e3o de callback (similar ao event_handler ). Implemente: M ( btnMenu / menu_handler ): Menu Clock ( btnClk / clk_handler ): Rel\u00f3gio ^ ( btnUp / up_handler ): Aumentar (temperatura/ alarme): v ( btnDown / down_handler ): Baixar (temperatura/ alarme) Lembre de testar na placa! Vai precisar de ajustes. Tip Handlers: Crie um handler diferente por bot\u00e3o. Alinhamento: Pense em como usar o alinhamento a seu favor. S\u00edmbolos: Rel\u00f3gio: Voc\u00ea pode usar um outro s\u00edmbolo no lugar. v, ^: Tem s\u00edmbolos prontos para isso Resultado esperado: O seu pode ficar diferente, mas lembre que a ideia \u00e9 chegar o mais perto do que da nossa referencia! Meu Referencia","title":"Demais bot\u00f5es"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB2/","text":"Lab - Parte 2 Info N\u00e3o podemos esquecer nossa referencia! Vamos implementar os itens que s\u00e3o apenas \"Labels (a)\": Temperatura atual, rel\u00f3rio, set-point. Mas antes ser\u00e1 preciso escolhermos a fonte que iremos usar na interface, o lvgl possui algumas fontes dispon\u00edveis por padr\u00e3o, mas nem sempre atendem a necessidade da interface. As fontes padr\u00f5es do LVGL est\u00e3o no link a seguir: https://docs.lvgl.io/master/overview/font.html Info Lembre que para usar as fontes padr\u00f5es do LVGL \u00e9 necess\u00e1rio editar o arquivo: config/lv_conf.h Para a interface proposta sugiro usarmos a fonte DSEG (open source) e que lembra um display de sete segmentos: https://github.com/keshikan/DSEG Tarefa Baixe a fonte para o seu computador https://github.com/keshikan/DSEG/releases/download/v0.46/fonts-DSEG_v046.zip Extrai a pasta Progress Click para continuar.... Floor Temp Vamos agora implementar o label da temperatura atual do piso, e iremos seguir os passos a seguir: Converter fonte para uso no lvgl Adicionar no lvgl/ Microchip studio Criando label e usando fonte 1. Convertendo Com a fonte escolhida precisamos agora converter para o formato que o LVGL consegue interpretar (bitmap), para isso usaremos a ferramenta online do LVGL. Acesse o site: https://lvgl.io/tools/fontconverter Vamos criar uma fonte de tamanho 70 -> DSEG7-Modern/DSEG7Modern-Regular.ttf , esse arquivo ser\u00e1 usada no site e foi extra\u00eddo na etapa anterior. Configure a interface como no exemplo a seguir: Name: dseg70 Size: 70 Bpp: 1 bit-per-pixel TTF: DSEG7-Modern/DSEG7Modern-Regular.ttf Symbols: -./0123456789 : (o espa\u00e7o \u00e9 necess\u00e1rio pq ele \u00e9 um car\u00e1ter) Symbols A fonte gerada ter\u00e1 somente esses s\u00edmbolos, se voc\u00ea quiser usar por exemplo a letra C n\u00e3o vai poder. Gerar somente os s\u00edmbolos que vai usar \u00e9 importante porque o uC possui pouca mem\u00f3ria e n\u00e3o seria poss\u00edvel ter v\u00e1rias fontes diferentes com todos os s\u00edmbolos. O site ir\u00e1 gerar um arquivo dseg70.c salve o mesmo dentro da pasta src/ do projeto (a mesma que cont\u00e9m o arquivo main.c) que estamos trabalhando. Progress Click para continuar.... 2. Adicionando no Microchip Studio Agora \u00e9 necess\u00e1rio adicionar o arquivo ao MS: Clique com o bot\u00e3o direito em src e clique em Add > Existing Item... Encontre o arquivo dseg120.c que foi baixado e clique em Add Verifique se o arquivo dseg120.c foi adicionado Info O exemplo foi feito para a fonte de tamanho 120, mas depois resolvemos trocar por uma menor, note que onde na imagem tem dseg120 voc\u00ea deve colocar a dseg70. Progress Click para continuar.... 3. Criando label e usando fonte Agora podemos utilizar a nova fonte no nosso projeto, ainda dentro da lv_termostato vamos criar um novo label que ir\u00e1 exibir o valor da temperatura atual. Fazemos isso similar ao bot\u00e3o, por\u00e9m agora iremos associar o label a tela e n\u00e3o ao bot\u00e3o e tamb\u00e9m iremos customizar a fonte para usarmos o dseg70 . Crei a vari\u00e1vel global que ir\u00e1 apontar para o label: lv_obj_t * labelFloor ; E ent\u00e3o modifique a fun\u00e7\u00e3o termostato: void lv_termostato ( void ){ // .... // .... labelFloor = lv_label_create ( lv_scr_act ()); lv_obj_align ( labelFloor , LV_ALIGN_LEFT_MID , 35 , -45 ); lv_obj_set_style_text_font ( labelFloor , & dseg70 , LV_STATE_DEFAULT ); lv_obj_set_style_text_color ( labelFloor , lv_color_white (), LV_STATE_DEFAULT ); lv_label_set_text_fmt ( labelFloor , \"%02d\" , 23 ); } Para usarmos a fonte devemos indicar ao LVGL que a fonte existe, para isso adicione a linha a seguir no topo (ap\u00f3s os #include) do arquivo main.c : LV_FONT_DECLARE ( dseg70 ); Antes de continuar temos que editar o come\u00e7o arquivo da fonte dseg70 , incluindo o define a seguir: +#define LV_LVGL_H_INCLUDE_SIMPLE #ifdef LV_LVGL_H_INCLUDE_SIMPLE #include \"lvgl.h\" #else #include \"lvgl/lvgl.h\" #endif Tarefa Crie o novo label como indicado anteriormente Modifique o arquivo dseg70.h Declare a fonte nova no main.c: LV_FONT_DECLARE(dseg70); Teste na placa Resultado esperado: Progress Click para continuar.... Info Notem que n\u00f3s criamos um label e ent\u00e3o customizamos algumas propriedades dele. O jeito feito neste exemplo \u00e9 diferente do que fizemos com o bot\u00e3o na qual criamos um estilo novo e aplicamos a ele. Voc\u00eas podem escolher qualquer um dos dois jeitos para modificar um objeto. Demais labels Agora voc\u00eas precisam criar os outros dois labels: Rel\u00f3gio e Temperatura configurada, para isso ser\u00e1 necess\u00e1rio gerar outras duas fontes de tamanhos diferentes e criar os labels. Tarefa Crie o label temperatura refer\u00eancia: labelSetValue Crie o label para o rel\u00f3gio: labelClock Para cada label voc\u00ea ter\u00e1 que converter uma nova fonte de tamanho diferente, consulte os passos anteriores. Resultado esperado: Progress Click para continuar.... Handlers At\u00e9 agora est\u00e1vamos apenas criando a interface no LCD, agora precisamos adicionar intelig\u00eancia a ela. Isso ser\u00e1 feito pelos callbacks dos bot\u00f5es. Vamos focar apenas nos bot\u00f5es UP e DOWN que configuram a temperatura de refer\u00eancia (da direita). Vamos implementar o c\u00f3digo para o up_handler , callback do bot\u00e3o de aumento de temperatura. Info Eu dei o nome de up_handler voc\u00ea pode ter dado outro nome, precisa ficar atento a isso. up_handler Existem v\u00e1rias maneiras de fazermos com que o handler altera o valor do label, eu sugiro o c\u00f3digo a seguir: static void up_handler ( lv_event_t * e ) { lv_event_code_t code = lv_event_get_code ( e ); char * c ; int temp ; if ( code == LV_EVENT_CLICKED ) { c = lv_label_get_text ( labelSetValue ); temp = atoi ( c ); lv_label_set_text_fmt ( labelSetValue , \"%02d\" , temp + 1 ); } } Info A vantagem da implementa\u00e7\u00e3o sugerida \u00e9 que n\u00e3o precisamos de uma vari\u00e1vel global para armazenar o valor da temperatura, n\u00f3s recuperamos o valor lendo o que estava salvo no label e convertendo para inteiro. Tarefa Implemente o handler Teste na placa Aperte o bot\u00e3o de up e verifique se a refer\u00eancia muda. Warning A fonte utilizada tem um problema, o car\u00e1cter vazio (espa\u00e7o: ) n\u00e3o apaga 100% o \u00faltimo valor, por exemplo: Quando o digito muda de 2 para 1 acontece de ficar uma barra em baixo. Depois vemos como resolver isso! Eu ainda n\u00e3o sei como fazer. =/ Progress Click para continuar.... down_handler Agora implemente a a\u00e7\u00e3o do bot\u00e3o down. Tarefa Implemente o down_handler Teste na placa rel\u00f3gio Temos um rel\u00f3gio na interface, vamos fazer ele funcionar? Para isso ter\u00e3o que incluir o RTC no projeto e fazer uso dele. Tarefa Inclua o RTC no projeto e fa\u00e7a o rel\u00f3gio funcionar! O rel\u01f5io deve exibir HH:MM, o : deve piscar uma vez por segundo. Dicas: Incluir RTC Criar task dedicada para atualizar o RTC Inicializar RTC na task Task fica esperando sem\u00e1foro do tick de segundos e atualiza o label do rel\u00f3gio. Progress At\u00e9 aqui \u00e9 C! Extras Temos muito o que fazer na interface, vou sugerir algumas coisas que ir\u00e3o dar nota a mais para voc\u00eas neste lab, cada item \u00e9 meio conceito a mais. Implementar o digito da Temperatura: 23 .4 Dica: use uma das fontes menores para isso O bot\u00e3o de settings deve possibilitar o usu\u00e1rio configurar a hora certa (usando as setas v e ^). Incluir demais labels e logos Gerar um logo para o rel\u00f3gio e usar no lugar do de settings Implementar o bot\u00e3o de Power que desliga a tela Colocar um potenci\u00f4metro que altera o valor da temperatura atual. Preencher ao finalizar o lab Carregando\u2026","title":"Lab - Parte 2"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB2/#lab-parte-2","text":"Info N\u00e3o podemos esquecer nossa referencia! Vamos implementar os itens que s\u00e3o apenas \"Labels (a)\": Temperatura atual, rel\u00f3rio, set-point. Mas antes ser\u00e1 preciso escolhermos a fonte que iremos usar na interface, o lvgl possui algumas fontes dispon\u00edveis por padr\u00e3o, mas nem sempre atendem a necessidade da interface. As fontes padr\u00f5es do LVGL est\u00e3o no link a seguir: https://docs.lvgl.io/master/overview/font.html Info Lembre que para usar as fontes padr\u00f5es do LVGL \u00e9 necess\u00e1rio editar o arquivo: config/lv_conf.h Para a interface proposta sugiro usarmos a fonte DSEG (open source) e que lembra um display de sete segmentos: https://github.com/keshikan/DSEG Tarefa Baixe a fonte para o seu computador https://github.com/keshikan/DSEG/releases/download/v0.46/fonts-DSEG_v046.zip Extrai a pasta Progress Click para continuar....","title":"Lab - Parte 2"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB2/#floor-temp","text":"Vamos agora implementar o label da temperatura atual do piso, e iremos seguir os passos a seguir: Converter fonte para uso no lvgl Adicionar no lvgl/ Microchip studio Criando label e usando fonte","title":"Floor Temp"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB2/#1-convertendo","text":"Com a fonte escolhida precisamos agora converter para o formato que o LVGL consegue interpretar (bitmap), para isso usaremos a ferramenta online do LVGL. Acesse o site: https://lvgl.io/tools/fontconverter Vamos criar uma fonte de tamanho 70 -> DSEG7-Modern/DSEG7Modern-Regular.ttf , esse arquivo ser\u00e1 usada no site e foi extra\u00eddo na etapa anterior. Configure a interface como no exemplo a seguir: Name: dseg70 Size: 70 Bpp: 1 bit-per-pixel TTF: DSEG7-Modern/DSEG7Modern-Regular.ttf Symbols: -./0123456789 : (o espa\u00e7o \u00e9 necess\u00e1rio pq ele \u00e9 um car\u00e1ter) Symbols A fonte gerada ter\u00e1 somente esses s\u00edmbolos, se voc\u00ea quiser usar por exemplo a letra C n\u00e3o vai poder. Gerar somente os s\u00edmbolos que vai usar \u00e9 importante porque o uC possui pouca mem\u00f3ria e n\u00e3o seria poss\u00edvel ter v\u00e1rias fontes diferentes com todos os s\u00edmbolos. O site ir\u00e1 gerar um arquivo dseg70.c salve o mesmo dentro da pasta src/ do projeto (a mesma que cont\u00e9m o arquivo main.c) que estamos trabalhando. Progress Click para continuar....","title":"1. Convertendo"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB2/#2-adicionando-no-microchip-studio","text":"Agora \u00e9 necess\u00e1rio adicionar o arquivo ao MS: Clique com o bot\u00e3o direito em src e clique em Add > Existing Item... Encontre o arquivo dseg120.c que foi baixado e clique em Add Verifique se o arquivo dseg120.c foi adicionado Info O exemplo foi feito para a fonte de tamanho 120, mas depois resolvemos trocar por uma menor, note que onde na imagem tem dseg120 voc\u00ea deve colocar a dseg70. Progress Click para continuar....","title":"2. Adicionando no Microchip Studio"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB2/#3-criando-label-e-usando-fonte","text":"Agora podemos utilizar a nova fonte no nosso projeto, ainda dentro da lv_termostato vamos criar um novo label que ir\u00e1 exibir o valor da temperatura atual. Fazemos isso similar ao bot\u00e3o, por\u00e9m agora iremos associar o label a tela e n\u00e3o ao bot\u00e3o e tamb\u00e9m iremos customizar a fonte para usarmos o dseg70 . Crei a vari\u00e1vel global que ir\u00e1 apontar para o label: lv_obj_t * labelFloor ; E ent\u00e3o modifique a fun\u00e7\u00e3o termostato: void lv_termostato ( void ){ // .... // .... labelFloor = lv_label_create ( lv_scr_act ()); lv_obj_align ( labelFloor , LV_ALIGN_LEFT_MID , 35 , -45 ); lv_obj_set_style_text_font ( labelFloor , & dseg70 , LV_STATE_DEFAULT ); lv_obj_set_style_text_color ( labelFloor , lv_color_white (), LV_STATE_DEFAULT ); lv_label_set_text_fmt ( labelFloor , \"%02d\" , 23 ); } Para usarmos a fonte devemos indicar ao LVGL que a fonte existe, para isso adicione a linha a seguir no topo (ap\u00f3s os #include) do arquivo main.c : LV_FONT_DECLARE ( dseg70 ); Antes de continuar temos que editar o come\u00e7o arquivo da fonte dseg70 , incluindo o define a seguir: +#define LV_LVGL_H_INCLUDE_SIMPLE #ifdef LV_LVGL_H_INCLUDE_SIMPLE #include \"lvgl.h\" #else #include \"lvgl/lvgl.h\" #endif Tarefa Crie o novo label como indicado anteriormente Modifique o arquivo dseg70.h Declare a fonte nova no main.c: LV_FONT_DECLARE(dseg70); Teste na placa Resultado esperado: Progress Click para continuar.... Info Notem que n\u00f3s criamos um label e ent\u00e3o customizamos algumas propriedades dele. O jeito feito neste exemplo \u00e9 diferente do que fizemos com o bot\u00e3o na qual criamos um estilo novo e aplicamos a ele. Voc\u00eas podem escolher qualquer um dos dois jeitos para modificar um objeto.","title":"3. Criando label e usando fonte"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB2/#demais-labels","text":"Agora voc\u00eas precisam criar os outros dois labels: Rel\u00f3gio e Temperatura configurada, para isso ser\u00e1 necess\u00e1rio gerar outras duas fontes de tamanhos diferentes e criar os labels. Tarefa Crie o label temperatura refer\u00eancia: labelSetValue Crie o label para o rel\u00f3gio: labelClock Para cada label voc\u00ea ter\u00e1 que converter uma nova fonte de tamanho diferente, consulte os passos anteriores. Resultado esperado: Progress Click para continuar....","title":"Demais labels"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB2/#handlers","text":"At\u00e9 agora est\u00e1vamos apenas criando a interface no LCD, agora precisamos adicionar intelig\u00eancia a ela. Isso ser\u00e1 feito pelos callbacks dos bot\u00f5es. Vamos focar apenas nos bot\u00f5es UP e DOWN que configuram a temperatura de refer\u00eancia (da direita). Vamos implementar o c\u00f3digo para o up_handler , callback do bot\u00e3o de aumento de temperatura. Info Eu dei o nome de up_handler voc\u00ea pode ter dado outro nome, precisa ficar atento a isso.","title":"Handlers"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB2/#up_handler","text":"Existem v\u00e1rias maneiras de fazermos com que o handler altera o valor do label, eu sugiro o c\u00f3digo a seguir: static void up_handler ( lv_event_t * e ) { lv_event_code_t code = lv_event_get_code ( e ); char * c ; int temp ; if ( code == LV_EVENT_CLICKED ) { c = lv_label_get_text ( labelSetValue ); temp = atoi ( c ); lv_label_set_text_fmt ( labelSetValue , \"%02d\" , temp + 1 ); } } Info A vantagem da implementa\u00e7\u00e3o sugerida \u00e9 que n\u00e3o precisamos de uma vari\u00e1vel global para armazenar o valor da temperatura, n\u00f3s recuperamos o valor lendo o que estava salvo no label e convertendo para inteiro. Tarefa Implemente o handler Teste na placa Aperte o bot\u00e3o de up e verifique se a refer\u00eancia muda. Warning A fonte utilizada tem um problema, o car\u00e1cter vazio (espa\u00e7o: ) n\u00e3o apaga 100% o \u00faltimo valor, por exemplo: Quando o digito muda de 2 para 1 acontece de ficar uma barra em baixo. Depois vemos como resolver isso! Eu ainda n\u00e3o sei como fazer. =/ Progress Click para continuar....","title":"up_handler"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB2/#down_handler","text":"Agora implemente a a\u00e7\u00e3o do bot\u00e3o down. Tarefa Implemente o down_handler Teste na placa","title":"down_handler"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB2/#relogio","text":"Temos um rel\u00f3gio na interface, vamos fazer ele funcionar? Para isso ter\u00e3o que incluir o RTC no projeto e fazer uso dele. Tarefa Inclua o RTC no projeto e fa\u00e7a o rel\u00f3gio funcionar! O rel\u01f5io deve exibir HH:MM, o : deve piscar uma vez por segundo. Dicas: Incluir RTC Criar task dedicada para atualizar o RTC Inicializar RTC na task Task fica esperando sem\u00e1foro do tick de segundos e atualiza o label do rel\u00f3gio. Progress At\u00e9 aqui \u00e9 C!","title":"rel\u00f3gio"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-LAB2/#extras","text":"Temos muito o que fazer na interface, vou sugerir algumas coisas que ir\u00e3o dar nota a mais para voc\u00eas neste lab, cada item \u00e9 meio conceito a mais. Implementar o digito da Temperatura: 23 .4 Dica: use uma das fontes menores para isso O bot\u00e3o de settings deve possibilitar o usu\u00e1rio configurar a hora certa (usando as setas v e ^). Incluir demais labels e logos Gerar um logo para o rel\u00f3gio e usar no lugar do de settings Implementar o bot\u00e3o de Power que desliga a tela Colocar um potenci\u00f4metro que altera o valor da temperatura atual. Preencher ao finalizar o lab Carregando\u2026","title":"Extras"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-START/","text":"Come\u00e7ando Nesse lab iremos trabalhar com o uso de um sistema operacional de tempo real (RTOS) para gerenciar o LCD max Touch. Warning Atualizem o reposit\u00f3rio SAME70-Examples antes de continuar LAB Lab7-RTOS-LCD-LVGL Neste laborat\u00f3rio iremos: Conectar o LCD no kit de desenvolvimento Executar e modificar o exemplo do lvgl In\u00edcio Antes de come\u00e7armos ser\u00e1 necess\u00e1rio realizarmos a conex\u00e3o do LCD no kit e ent\u00e3o validarmos a conex\u00e3o do LCD e depois do touch. Conectando LCD Primeiro fa\u00e7a as liga\u00e7\u00f5es como indicado no README a seguir: Plugue o LCD max Touch no EXT2 seguindo as instru\u00e7\u00f5es em: SAME70-examples/Screens/2.8-TFT-LCD-ILI9341-Hardware/ Depois valide: Copie o c\u00f3digo exemplo SAME70-examples/Screens/RTOS-TFT-LCD-ILI9341-LVGL/ para a pasta da entrega do seu reposit\u00f3rio: Lab7-RTOS-LCD-LVGL Execute o c\u00f3digo, voc\u00ea deve visualizar dois bot\u00f5es e eles devem ser interativos. Terminal O segundo exemplo faz uso da comunica\u00e7\u00e3o UART para debug de c\u00f3digo (via printf), para acessar o terminal no atmel est\u00fadio clique em: View Terminal Window Configure o terminal para a porta que (COM) correta (verificar no windiows) e para operar com um BaudRate de 115200. Progress Execute os exemplos antes de continuar! LCD O LCD que iremos usar nas pr\u00f3ximas atividades da disciplina \u00e9 fabricado pela adafruit com o nome de: 2.8\" TFT LCD with Touchscreen Breakout Board w/MicroSD Socket - ILI9341 ele possui um LCD de 240x320 pixels operando em RGB e com uma sensor touch resistivo. O LCD \u00e9 controlado por um controlador chamado de ILI9341 ele \u00e9 respons\u00e1vel por atualizar e exibir as informa\u00e7\u00f5es na tela. ILI9341 O LCD utiliza o circuito integrado ILI9341 como controlador do display, este CI \u00e9 respons\u00e1vel por toda parte de baixo n\u00edvel de acesso ao LCD, este chip possui duas formas de interface com o uC: Paralelo e SPI. Iremos utilizar ele operando via SPI como ilustrado a seguir: x---------x x---------x | | | | | uc | | LCD | | ------| spi |------- | | | spi | <---/---> | ili | | x---------x x---------x Note Para realizar a interface com o LCD portei o c\u00f3digo de refer\u00eancia da ATMEL ILI9341 Display Controller Component Driver para o SAME70. ILI9341 a-Si TFT LCD Single Chip Driver 240RGBx320 Resolution and 262K color LI9341 is a 262,144-color single-chip SOC driver for a-TFT liquid crystal display with resolution of 240RGBx320 dots, comprising a 720-channel source driver, a 320-channel gate driver, 172,800 bytes GRAM for graphic display data of 240RGBx320 dots, and power supply circuit. ILI9341 supports parallel 8-/9-/16-/18-bit data bus MCU interface, 6-/16-/18-bit data bus RGB interface and 3-/4-line serial peripheral interface (SPI). The moving picture area can be specified in internal GRAM by window address function. The specified window area can be updated selectively, so that moving picture can be displayed simultaneously independent of still picture area. ILI9341 can operate with 1.65V ~ 3.3V I/O interface voltage and an incorporated voltage follower circuit to generate voltage levels for driving an LCD. ILI9341 supports full color, 8-color display mode and sleep mode for precise power control by software and these features make the ILI9341 an ideal LCD driver for medium or small size portable products such as digital cellular phones, smart phone, MP3 and PMP where long battery life is a major concern. Extra\u00eddo do manual. Touch O LCD possui um \"pel\u00edcula\" de touchscreen resistivo que possibilita detectarmos toques na tela. A pel\u00edcula fornece dois valores de resist\u00eancia: X e Y e via duas leituras anal\u00f3gicas conseguimos estimar onde aconteceu o toque na tela, e inclusive a press\u00e3o do toque. Fonte das figuras: https://www.ti.com/lit/an/slyt209a/slyt209a.pdf A Conex\u00e3o do touch resistivo com o uC acontece da seguinte maneira: x---------x x----------- x | dx | -------> | t | LCD | | uc dy | -------> | o | | | AFEC | <------- | u | | | AFEC | <------- | c | | x---------x x-----------x Note Para realizar a leitura do touch resistivo portei o c\u00f3digo da adafruit TouchScreen para o SAME70. Tip Telas resistivas n\u00e3o s\u00e3o t\u00e3o boas quanto as capacitivas que apenas com o toque na tela o contato j\u00e1 \u00e9 detectado, nas resistivas \u00e9 necess\u00e1rio um pouco mais de press\u00e3o. LVGL Uma coisa \u00e9 conseguir acessar o LCD e transmitir pixels outra \u00e9 ter uma biblioteca capaz de desenhar coisas no LCD (bot\u00f5es, imagens, textos, gr\u00e1ficos, ...). Existem v\u00e1rias bibliotecas gr\u00e1ficas para sistemas embarcados, o site a seguir possui uma lista e um comparativo entre elas: https://itnext.io/top-five-libraries-for-creating-gui-on-embedded-linux-5ce03903be32 N\u00f3s iremos usar o LVGL - LVGL - Light and Versatile Graphics Library , uma biblioteca livre liberada na licen\u00e7a MIT feita para sistemas embarcados, 100% em C, bastante customiz\u00e1vel de boa documenta\u00e7\u00e3o e com suporte a v\u00e1rios tipos de displays e interface com usu\u00e1rio (touch screen, mouse, ...). Com esse software seremos capazes de desenvolver interfaces similares ao exemplo a seguir: Base Iremos trabalhar com o c\u00f3digo base: RTOS-TFT-LCD-ILI9341-LVGL que j\u00e1 possui configurado: FreeRTOS v8 Driver ili9341 Driver Touch resistivo lvgl Progress Antes de come\u00e7armos a mexer com o LVGL vamos entender um pouco o c\u00f3digo de exemplo e como o lvgl trabalha. Porting lvgl O site do LVGL descreve o passo a passo de como incorporar a biblioteca em um novo projeto/ microcontrolador, al\u00e9m de criar um arquivo de configura\u00e7\u00e3o lv_conf.h com as propriedades do LCD e com configura\u00e7\u00f5es de como a biblioteca ir\u00e1 trabalhar, temos que implementar duas fun\u00e7\u00f5es: my_flush_cb : Fun\u00e7\u00e3o chamada pelo lvgl sempre que necessita atualizar a tela Depende do driver ili9341 my_input_read : Fun\u00e7\u00e3o chamada pelo lvgl sempre que quer ler uma informa\u00e7\u00e3o de touch Depende do driver do touch resistivo my_flush_cp Note que o LVGL apenas atualiza no LCD a regi\u00e3o que sofreu altera\u00e7\u00e3o. void my_flush_cb ( lv_disp_drv_t * disp_drv , const lv_area_t * area , lv_color_t * color_p ) { ili9341_set_top_left_limit ( area -> x1 , area -> y1 ); ili9341_set_bottom_right_limit ( area -> x2 , area -> y2 ); ili9341_copy_pixels_to_screen ( color_p , ( area -> x2 - area -> x1 ) * ( area -> y2 - area -> y1 )); /* IMPORTANT!!! * Inform the graphics library that you are ready with the flushing*/ lv_disp_flush_ready ( disp_drv ); } my_input_read \u200b Esta fun\u00e7\u00e3o retorna no *data se um toque foi encontrado e o valor X Y lido. bool my_input_read ( lv_indev_drv_t * drv , lv_indev_data_t * data ) { int px , py , pressed ; if ( readPoint ( & px , & py )) { data -> state = LV_INDEV_STATE_PR ; } else { data -> state = LV_INDEV_STATE_REL ; } data -> point . x = px ; data -> point . y = py ; return false ; /*No buffering now so no more data read*/ } E isso \u00e9 tudo o que deve ser feito para incorporar o lvgl em um novo projeto. Info Eu devo ter demorado umas 10h de trabalho para sair de um projeto zerado e conseguir fazer o exemplo que voc\u00eas ir\u00e3o utilizar hoje. Foram necess\u00e1rias v\u00e1rias etapas: Escolher LCD Entender conex\u00e3o de hardware Implementar driver ili9341 Implementar driver touch Entender LVGL e como porta Executar LVGL framebuffer O LVGL opera com no m\u00ednimo um framebuffer, framebuffer \u00e9 uma regi\u00e3o cont\u00ednua de mem\u00f3ria usada para armazenar a imagem que ser\u00e1 exibida na tela, essa tecnologia \u00e9 usado em v\u00e1rios lugares, inclusive no linux . Em alguns casos \u00e9 necess\u00e1rio dois framebuffers operando no modo ping pong buffer No LVGL devemos declarar esse frame buffer como global ou est\u00e1tico: /*Static or global buffer(s). The second buffer is optional*/ static lv_color_t buf_1 [ LV_HOR_RES_MAX * LV_VER_RES_MAX ]; O LVGL ir\u00e1 ent\u00e3o manter uma c\u00f3pia do que ser\u00e1 exibido no LCD nesta regi\u00e3o continua de mem\u00f3ria e de tempos em tempos atualizar o LCD chamando a fun\u00e7\u00e3o my_flush_cb . Fun\u00e7\u00e3o main Agora com tudo configurado devemos realizar as seguintes inicializa\u00e7\u00f5es antes de podemos usar o lvgl controlando o display: Info Tudo isso j\u00e1 est\u00e1 no c\u00f3digo exemplo, voc\u00ea n\u00e3o precisa modificar nada. passos Board e Sysclock LCD e driver ili9341 Touch lvgl buffer e display lvgl input C\u00f3digo /* board and sys init */ board_init (); sysclk_init (); configure_console (); /* LCd int */ configure_lcd (); ili9341_init (); configure_touch (); ili9341_backlight_on (); /*LittlevGL init*/ lv_init (); lv_disp_drv_t disp_drv ; /*A variable to hold the drivers. Can be local variable*/ lv_disp_drv_init ( & disp_drv ); /*Basic initialization*/ lv_disp_buf_init ( & disp_buf , buf_1 , NULL , LV_HOR_RES_MAX * LV_VER_RES_MAX ); /*Initialize `disp_buf` with the buffer(s) */ disp_drv . buffer = & disp_buf ; /*Set an initialized buffer*/ disp_drv . flush_cb = my_flush_cb ; /*Set a flush callback to draw to the display*/ lv_disp_t * disp ; disp = lv_disp_drv_register ( & disp_drv ); /*Register the driver and save the created display objects*/ /* Init input on LVGL */ lv_indev_drv_t indev_drv ; lv_indev_drv_init ( & indev_drv ); /*Basic initialization*/ indev_drv . type = LV_INDEV_TYPE_POINTER ; indev_drv . read_cb = my_input_read ; /*Register the driver in LVGL and save the created input device object*/ lv_indev_t * my_indev = lv_indev_drv_register ( & indev_drv ); task_lcd Com o lvlg configurado devemos chamar periodicamente a fun\u00e7\u00e3o que atualiza o lvgl ( lv_task_handler ), no exemplo criamos uma task dedicada a isso: static void task_lcd ( void * pvParameters ) { lv_ex_btn_1 (); for (;;) { lv_tick_inc ( 50 ); lv_task_handler (); vTaskDelay ( 50 ); } } Criando tela Note que na task_lcd chamamos a fun\u00e7\u00e3o lv_ex_btn_1() est\u00e1 fun\u00e7\u00e3o cria os widgets no LCD, os widgets est\u00e3o listados na p\u00e1gina: https://docs.lvgl.io/master/widgets/index.html Podemos listar alguns aqui como exemplo: Widget Example Button ( lv_btn ) LED ( lv_led ) Roller ( lv_roller ) Bar ( lv_bar ) O exemplo fornecido cria dois tipos de bot\u00f5es diferentes um do push button e outro do tipo toggle, notem que tudo \u00e9 realizado pela API do lvgl. Podemos associar um handler ( event_handler ) ao bot\u00e3o, este handler sera chamado (pela lv_task_handler ) sempre que acontecer um evento neste widget (bot\u00e3o aprtado, bot\u00e3o liberado, ...). lv_ex_btn_1 void lv_ex_btn_1 ( void ) { lv_obj_t * label ; lv_obj_t * btn1 = lv_btn_create ( lv_scr_act (), NULL ); lv_obj_set_event_cb ( btn1 , event_handler ); lv_obj_align ( btn1 , NULL , LV_ALIGN_CENTER , 0 , -40 ); label = lv_label_create ( btn1 , NULL ); lv_label_set_text ( label , \"Button\" ); lv_obj_t * btn2 = lv_btn_create ( lv_scr_act (), NULL ); lv_obj_set_event_cb ( btn2 , event_handler ); lv_obj_align ( btn2 , NULL , LV_ALIGN_CENTER , 0 , 40 ); lv_btn_set_checkable ( btn2 , true ); lv_btn_toggle ( btn2 ); lv_btn_set_fit2 ( btn2 , LV_FIT_NONE , LV_FIT_TIGHT ); label = lv_label_create ( btn2 , NULL ); lv_label_set_text ( label , \"Toggled\" ); } event_handler(...) static void event_handler ( lv_obj_t * obj , lv_event_t event ) { if ( event == LV_EVENT_CLICKED ) { printf ( \"Clicked \\n \" ); } else if ( event == LV_EVENT_VALUE_CHANGED ) { printf ( \"Toggled \\n \" ); } }","title":"Come\u00e7ando"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-START/#comecando","text":"Nesse lab iremos trabalhar com o uso de um sistema operacional de tempo real (RTOS) para gerenciar o LCD max Touch. Warning Atualizem o reposit\u00f3rio SAME70-Examples antes de continuar LAB Lab7-RTOS-LCD-LVGL Neste laborat\u00f3rio iremos: Conectar o LCD no kit de desenvolvimento Executar e modificar o exemplo do lvgl","title":"Come\u00e7ando"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-START/#inicio","text":"Antes de come\u00e7armos ser\u00e1 necess\u00e1rio realizarmos a conex\u00e3o do LCD no kit e ent\u00e3o validarmos a conex\u00e3o do LCD e depois do touch. Conectando LCD Primeiro fa\u00e7a as liga\u00e7\u00f5es como indicado no README a seguir: Plugue o LCD max Touch no EXT2 seguindo as instru\u00e7\u00f5es em: SAME70-examples/Screens/2.8-TFT-LCD-ILI9341-Hardware/ Depois valide: Copie o c\u00f3digo exemplo SAME70-examples/Screens/RTOS-TFT-LCD-ILI9341-LVGL/ para a pasta da entrega do seu reposit\u00f3rio: Lab7-RTOS-LCD-LVGL Execute o c\u00f3digo, voc\u00ea deve visualizar dois bot\u00f5es e eles devem ser interativos. Terminal O segundo exemplo faz uso da comunica\u00e7\u00e3o UART para debug de c\u00f3digo (via printf), para acessar o terminal no atmel est\u00fadio clique em: View Terminal Window Configure o terminal para a porta que (COM) correta (verificar no windiows) e para operar com um BaudRate de 115200. Progress Execute os exemplos antes de continuar!","title":"In\u00edcio"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-START/#lcd","text":"O LCD que iremos usar nas pr\u00f3ximas atividades da disciplina \u00e9 fabricado pela adafruit com o nome de: 2.8\" TFT LCD with Touchscreen Breakout Board w/MicroSD Socket - ILI9341 ele possui um LCD de 240x320 pixels operando em RGB e com uma sensor touch resistivo. O LCD \u00e9 controlado por um controlador chamado de ILI9341 ele \u00e9 respons\u00e1vel por atualizar e exibir as informa\u00e7\u00f5es na tela.","title":"LCD"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-START/#ili9341","text":"O LCD utiliza o circuito integrado ILI9341 como controlador do display, este CI \u00e9 respons\u00e1vel por toda parte de baixo n\u00edvel de acesso ao LCD, este chip possui duas formas de interface com o uC: Paralelo e SPI. Iremos utilizar ele operando via SPI como ilustrado a seguir: x---------x x---------x | | | | | uc | | LCD | | ------| spi |------- | | | spi | <---/---> | ili | | x---------x x---------x Note Para realizar a interface com o LCD portei o c\u00f3digo de refer\u00eancia da ATMEL ILI9341 Display Controller Component Driver para o SAME70. ILI9341 a-Si TFT LCD Single Chip Driver 240RGBx320 Resolution and 262K color LI9341 is a 262,144-color single-chip SOC driver for a-TFT liquid crystal display with resolution of 240RGBx320 dots, comprising a 720-channel source driver, a 320-channel gate driver, 172,800 bytes GRAM for graphic display data of 240RGBx320 dots, and power supply circuit. ILI9341 supports parallel 8-/9-/16-/18-bit data bus MCU interface, 6-/16-/18-bit data bus RGB interface and 3-/4-line serial peripheral interface (SPI). The moving picture area can be specified in internal GRAM by window address function. The specified window area can be updated selectively, so that moving picture can be displayed simultaneously independent of still picture area. ILI9341 can operate with 1.65V ~ 3.3V I/O interface voltage and an incorporated voltage follower circuit to generate voltage levels for driving an LCD. ILI9341 supports full color, 8-color display mode and sleep mode for precise power control by software and these features make the ILI9341 an ideal LCD driver for medium or small size portable products such as digital cellular phones, smart phone, MP3 and PMP where long battery life is a major concern. Extra\u00eddo do manual.","title":"ILI9341"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-START/#touch","text":"O LCD possui um \"pel\u00edcula\" de touchscreen resistivo que possibilita detectarmos toques na tela. A pel\u00edcula fornece dois valores de resist\u00eancia: X e Y e via duas leituras anal\u00f3gicas conseguimos estimar onde aconteceu o toque na tela, e inclusive a press\u00e3o do toque. Fonte das figuras: https://www.ti.com/lit/an/slyt209a/slyt209a.pdf A Conex\u00e3o do touch resistivo com o uC acontece da seguinte maneira: x---------x x----------- x | dx | -------> | t | LCD | | uc dy | -------> | o | | | AFEC | <------- | u | | | AFEC | <------- | c | | x---------x x-----------x Note Para realizar a leitura do touch resistivo portei o c\u00f3digo da adafruit TouchScreen para o SAME70. Tip Telas resistivas n\u00e3o s\u00e3o t\u00e3o boas quanto as capacitivas que apenas com o toque na tela o contato j\u00e1 \u00e9 detectado, nas resistivas \u00e9 necess\u00e1rio um pouco mais de press\u00e3o.","title":"Touch"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-START/#lvgl","text":"Uma coisa \u00e9 conseguir acessar o LCD e transmitir pixels outra \u00e9 ter uma biblioteca capaz de desenhar coisas no LCD (bot\u00f5es, imagens, textos, gr\u00e1ficos, ...). Existem v\u00e1rias bibliotecas gr\u00e1ficas para sistemas embarcados, o site a seguir possui uma lista e um comparativo entre elas: https://itnext.io/top-five-libraries-for-creating-gui-on-embedded-linux-5ce03903be32 N\u00f3s iremos usar o LVGL - LVGL - Light and Versatile Graphics Library , uma biblioteca livre liberada na licen\u00e7a MIT feita para sistemas embarcados, 100% em C, bastante customiz\u00e1vel de boa documenta\u00e7\u00e3o e com suporte a v\u00e1rios tipos de displays e interface com usu\u00e1rio (touch screen, mouse, ...). Com esse software seremos capazes de desenvolver interfaces similares ao exemplo a seguir:","title":"LVGL"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-START/#base","text":"Iremos trabalhar com o c\u00f3digo base: RTOS-TFT-LCD-ILI9341-LVGL que j\u00e1 possui configurado: FreeRTOS v8 Driver ili9341 Driver Touch resistivo lvgl Progress Antes de come\u00e7armos a mexer com o LVGL vamos entender um pouco o c\u00f3digo de exemplo e como o lvgl trabalha.","title":"Base"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-START/#porting-lvgl","text":"O site do LVGL descreve o passo a passo de como incorporar a biblioteca em um novo projeto/ microcontrolador, al\u00e9m de criar um arquivo de configura\u00e7\u00e3o lv_conf.h com as propriedades do LCD e com configura\u00e7\u00f5es de como a biblioteca ir\u00e1 trabalhar, temos que implementar duas fun\u00e7\u00f5es: my_flush_cb : Fun\u00e7\u00e3o chamada pelo lvgl sempre que necessita atualizar a tela Depende do driver ili9341 my_input_read : Fun\u00e7\u00e3o chamada pelo lvgl sempre que quer ler uma informa\u00e7\u00e3o de touch Depende do driver do touch resistivo my_flush_cp Note que o LVGL apenas atualiza no LCD a regi\u00e3o que sofreu altera\u00e7\u00e3o. void my_flush_cb ( lv_disp_drv_t * disp_drv , const lv_area_t * area , lv_color_t * color_p ) { ili9341_set_top_left_limit ( area -> x1 , area -> y1 ); ili9341_set_bottom_right_limit ( area -> x2 , area -> y2 ); ili9341_copy_pixels_to_screen ( color_p , ( area -> x2 - area -> x1 ) * ( area -> y2 - area -> y1 )); /* IMPORTANT!!! * Inform the graphics library that you are ready with the flushing*/ lv_disp_flush_ready ( disp_drv ); } my_input_read \u200b Esta fun\u00e7\u00e3o retorna no *data se um toque foi encontrado e o valor X Y lido. bool my_input_read ( lv_indev_drv_t * drv , lv_indev_data_t * data ) { int px , py , pressed ; if ( readPoint ( & px , & py )) { data -> state = LV_INDEV_STATE_PR ; } else { data -> state = LV_INDEV_STATE_REL ; } data -> point . x = px ; data -> point . y = py ; return false ; /*No buffering now so no more data read*/ } E isso \u00e9 tudo o que deve ser feito para incorporar o lvgl em um novo projeto. Info Eu devo ter demorado umas 10h de trabalho para sair de um projeto zerado e conseguir fazer o exemplo que voc\u00eas ir\u00e3o utilizar hoje. Foram necess\u00e1rias v\u00e1rias etapas: Escolher LCD Entender conex\u00e3o de hardware Implementar driver ili9341 Implementar driver touch Entender LVGL e como porta Executar LVGL","title":"Porting lvgl"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-START/#framebuffer","text":"O LVGL opera com no m\u00ednimo um framebuffer, framebuffer \u00e9 uma regi\u00e3o cont\u00ednua de mem\u00f3ria usada para armazenar a imagem que ser\u00e1 exibida na tela, essa tecnologia \u00e9 usado em v\u00e1rios lugares, inclusive no linux . Em alguns casos \u00e9 necess\u00e1rio dois framebuffers operando no modo ping pong buffer No LVGL devemos declarar esse frame buffer como global ou est\u00e1tico: /*Static or global buffer(s). The second buffer is optional*/ static lv_color_t buf_1 [ LV_HOR_RES_MAX * LV_VER_RES_MAX ]; O LVGL ir\u00e1 ent\u00e3o manter uma c\u00f3pia do que ser\u00e1 exibido no LCD nesta regi\u00e3o continua de mem\u00f3ria e de tempos em tempos atualizar o LCD chamando a fun\u00e7\u00e3o my_flush_cb .","title":"framebuffer"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-START/#funcao-main","text":"Agora com tudo configurado devemos realizar as seguintes inicializa\u00e7\u00f5es antes de podemos usar o lvgl controlando o display: Info Tudo isso j\u00e1 est\u00e1 no c\u00f3digo exemplo, voc\u00ea n\u00e3o precisa modificar nada. passos Board e Sysclock LCD e driver ili9341 Touch lvgl buffer e display lvgl input C\u00f3digo /* board and sys init */ board_init (); sysclk_init (); configure_console (); /* LCd int */ configure_lcd (); ili9341_init (); configure_touch (); ili9341_backlight_on (); /*LittlevGL init*/ lv_init (); lv_disp_drv_t disp_drv ; /*A variable to hold the drivers. Can be local variable*/ lv_disp_drv_init ( & disp_drv ); /*Basic initialization*/ lv_disp_buf_init ( & disp_buf , buf_1 , NULL , LV_HOR_RES_MAX * LV_VER_RES_MAX ); /*Initialize `disp_buf` with the buffer(s) */ disp_drv . buffer = & disp_buf ; /*Set an initialized buffer*/ disp_drv . flush_cb = my_flush_cb ; /*Set a flush callback to draw to the display*/ lv_disp_t * disp ; disp = lv_disp_drv_register ( & disp_drv ); /*Register the driver and save the created display objects*/ /* Init input on LVGL */ lv_indev_drv_t indev_drv ; lv_indev_drv_init ( & indev_drv ); /*Basic initialization*/ indev_drv . type = LV_INDEV_TYPE_POINTER ; indev_drv . read_cb = my_input_read ; /*Register the driver in LVGL and save the created input device object*/ lv_indev_t * my_indev = lv_indev_drv_register ( & indev_drv );","title":"Fun\u00e7\u00e3o main"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-START/#task_lcd","text":"Com o lvlg configurado devemos chamar periodicamente a fun\u00e7\u00e3o que atualiza o lvgl ( lv_task_handler ), no exemplo criamos uma task dedicada a isso: static void task_lcd ( void * pvParameters ) { lv_ex_btn_1 (); for (;;) { lv_tick_inc ( 50 ); lv_task_handler (); vTaskDelay ( 50 ); } }","title":"task_lcd"},{"location":"navigation/Labs/Lab_RTOS_LCD_LVGL/Lab-RTOS-LCD-LVGL-START/#criando-tela","text":"Note que na task_lcd chamamos a fun\u00e7\u00e3o lv_ex_btn_1() est\u00e1 fun\u00e7\u00e3o cria os widgets no LCD, os widgets est\u00e3o listados na p\u00e1gina: https://docs.lvgl.io/master/widgets/index.html Podemos listar alguns aqui como exemplo: Widget Example Button ( lv_btn ) LED ( lv_led ) Roller ( lv_roller ) Bar ( lv_bar ) O exemplo fornecido cria dois tipos de bot\u00f5es diferentes um do push button e outro do tipo toggle, notem que tudo \u00e9 realizado pela API do lvgl. Podemos associar um handler ( event_handler ) ao bot\u00e3o, este handler sera chamado (pela lv_task_handler ) sempre que acontecer um evento neste widget (bot\u00e3o aprtado, bot\u00e3o liberado, ...). lv_ex_btn_1 void lv_ex_btn_1 ( void ) { lv_obj_t * label ; lv_obj_t * btn1 = lv_btn_create ( lv_scr_act (), NULL ); lv_obj_set_event_cb ( btn1 , event_handler ); lv_obj_align ( btn1 , NULL , LV_ALIGN_CENTER , 0 , -40 ); label = lv_label_create ( btn1 , NULL ); lv_label_set_text ( label , \"Button\" ); lv_obj_t * btn2 = lv_btn_create ( lv_scr_act (), NULL ); lv_obj_set_event_cb ( btn2 , event_handler ); lv_obj_align ( btn2 , NULL , LV_ALIGN_CENTER , 0 , 40 ); lv_btn_set_checkable ( btn2 , true ); lv_btn_toggle ( btn2 ); lv_btn_set_fit2 ( btn2 , LV_FIT_NONE , LV_FIT_TIGHT ); label = lv_label_create ( btn2 , NULL ); lv_label_set_text ( label , \"Toggled\" ); } event_handler(...) static void event_handler ( lv_obj_t * obj , lv_event_t event ) { if ( event == LV_EVENT_CLICKED ) { printf ( \"Clicked \\n \" ); } else if ( event == LV_EVENT_VALUE_CHANGED ) { printf ( \"Toggled \\n \" ); } }","title":"Criando tela"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/","text":"RTOS - UART Nesse lab iremos trabalhar com comunica\u00e7\u00e3o UART (aquela do terminal / printf). Praticando RTOS (queue) Preencher ao finalizar o lab Carregando\u2026 Lab LAB Labs/8-RTOS-UART In\u00edcio C\u00f3digo exemplo Vamos modificar o seu lab lab-RTOS (aquele dos leds e bot\u00f5es), fa\u00e7a uma c\u00f3pia do seu lab para a nova pasta no seu seu reposit\u00f3rio Labs/8-RTOS-UART O projeto j\u00e1 modificado do lab! Terminal Esse exemplo faz uso da comunica\u00e7\u00e3o UART para debug de c\u00f3digo (via printf), para acessar o terminal no atmel est\u00fadio clique em: View Terminal Window Configure o terminal para a porta que (COM) correta (verificar no windiows) e para operar com um BaudRate de 115200 . Esse c\u00f3digo exemplo j\u00e1 possui a comunica\u00e7\u00e3o UART configurada pela fun\u00e7\u00e3o ( configure_console ), essa fun\u00e7\u00e3o configura a utiliza\u00e7\u00e3o do perif\u00e9rico USART1 operando em modo de comunica\u00e7\u00e3o serial ass\u00edncrona. Os pinos TX e RX da comunica\u00e7\u00e3o serial s\u00e3o conectados ao EDGB, chip respons\u00e1vel pela grava\u00e7\u00e3o e debug do kit de desenvolvimento SAME70-XPLD. A comunica\u00e7\u00e3o UART \u00e9 um protocolo de comunica\u00e7\u00e3o muito utilizado para comunica\u00e7\u00e3o entre dois dispositivos ( Machine-to-Machine , \u00e9 utilizado por exemplo no arduino para a grava\u00e7\u00e3o e debug (print), \u00e9 utilizado por diversos equipamentos para comunica\u00e7\u00e3o e configura\u00e7\u00e3o (impressoras t\u00e9rmicas, m\u00e1quinas de cart\u00e3o de cr\u00e9dito, GPP, sensores de biometria, ...). Note No nosso microcontrolador, temos dois perif\u00e9ricos capazes de realizar comunica\u00e7\u00e3o serial o UART e USART , nesse exemplo, utilizamos o USART . Essa fun\u00e7\u00e3o configura o perif\u00e9rico USART1 para operar como stdio do nosso c\u00f3digo C, toda vez que invocamos a fun\u00e7\u00e3o printf a sa\u00edda dos caracteres \u00e9 enviada para o perif\u00e9rico e \u00e9 serializado por ele. Info Para mais detalhes de como o stdio faz o mapeamento para o perif\u00e9rico em quest\u00e3o, analise o include src/ASF/common/utils/stdio/stdio_serial/stdio_serial.h Vamos adicionar uma nova fun\u00e7\u00e3o ( USART1_init ) que faz praticamente a mesma coisa, por\u00e9m configura a interrup\u00e7\u00e3o desse perif\u00e9rico. A interrup\u00e7\u00e3o ativada \u00e9 para o recebimento de dados pela serial ( US_IER_RXRDY ), toda vez que um novo dado \u00e9 recebido pela serial, o handler USART1_Handler \u00e9 chamado. Outras interrup\u00e7\u00f5es do USART1 Outras interrup\u00e7\u00f5es suportadas pelo USART1: RXRDY: RXRDY Interrupt Enable TXRDY: TXRDY Interrupt Enable OVRE: Overrun Error Interrupt Enable FRAME: Framing Error Interrupt Enable PARE: Parity Error Interrupt Enable TIMEOUT: Time-out Interrupt Enable TXEMPTY: TXEMPTY Interrupt Enable Preparando exemplo Adicione as fun\u00e7\u00f5es USART1_init , usart1_puts e o handler USART1_Handler ao exemplo. USART1_init static void USART1_init ( void ){ /* Configura USART1 Pinos */ sysclk_enable_peripheral_clock ( ID_PIOB ); sysclk_enable_peripheral_clock ( ID_PIOA ); pio_set_peripheral ( PIOB , PIO_PERIPH_D , PIO_PB4 ); // RX pio_set_peripheral ( PIOA , PIO_PERIPH_A , PIO_PA21 ); // TX MATRIX -> CCFG_SYSIO |= CCFG_SYSIO_SYSIO4 ; /* Configura opcoes USART */ const sam_usart_opt_t usart_settings = { . baudrate = 115200 , . char_length = US_MR_CHRL_8_BIT , . parity_type = US_MR_PAR_NO , . stop_bits = US_MR_NBSTOP_1_BIT , . channel_mode = US_MR_CHMODE_NORMAL }; /* Ativa Clock periferico USART0 */ sysclk_enable_peripheral_clock ( ID_USART1 ); stdio_serial_init ( CONF_UART , & usart_settings ); /* Enable the receiver and transmitter. */ usart_enable_tx ( USART1 ); usart_enable_rx ( USART1 ); /* map printf to usart */ ptr_put = ( int ( * )( void volatile * , char )) & usart_serial_putchar ; ptr_get = ( void ( * )( void volatile * , char * )) & usart_serial_getchar ; /* ativando interrupcao */ usart_enable_interrupt ( USART1 , US_IER_RXRDY ); NVIC_SetPriority ( ID_USART1 , 4 ); NVIC_EnableIRQ ( ID_USART1 ); } USART1_Handler void USART1_Handler ( void ){ uint32_t ret = usart_get_status ( USART1 ); BaseType_t xHigherPriorityTaskWoken = pdTRUE ; char c ; // Verifica por qual motivo entrou na interrup\u00e7cao? // RXRDY ou TXRDY // Dados dispon\u00edvel para leitura if ( ret & US_IER_RXRDY ){ usart_serial_getchar ( USART1 , & c ); printf ( \"%c\" , c ); // - Transmissoa finalizada } else if ( ret & US_IER_TXRDY ){ } } A fun\u00e7\u00e3o usart1_puts envia uma string para a serial pelo perif\u00e9rico USART1. usart1_puts uint32_t usart1_puts ( uint8_t * pstring ){ uint32_t i ; while ( * ( pstring + i )) if ( uart_is_tx_empty ( USART1 )) usart_serial_putchar ( USART1 , * ( pstring + i ++ )); } Edite o main para chamarmos a fun\u00e7\u00e3o USART1_init no lugar do configure_console : int main(void) { /* Initialize the SAM system */ sysclk_init(); board_init(); /* Initialize the console uart */ - configure_console(); + USART1_init(); Modifique Inclua USART1_init Inclua USART1_Handler Inclua usart1_puts Substitua configure_console por USART1_init Lab Agora com o exemplo preparado vamos implementar o firmware que foi desenvolvido em aula. diagrama feito em sala, enviado no teams O usu\u00e1rio pode modificar os LEDs (recurso) de duas maneiras diferentes: enviando uma mensagem pela UART (terminal) ou apertando os bot\u00f5es da placa. Os bot\u00f5es e a UART servem como 'produtores' de comandos que ser\u00e3o processados por uma tarefa espec\u00edfica. A vantagem desse formato \u00e9: a flexibilidade de cria\u00e7\u00e3o de novos produtores (\u00e9 f\u00e1cil adicionar por exemplo uma segunda uart, ou uma outra comunica\u00e7\u00e3o), basta enviar os dados na fila de comandos; o isolamento entre diferentes partes do firmware. Dicas A seguir algumas dicas de como fazer o seu c\u00f3digo. xQueueChar Deve ser uma fila de caracteres, especificar um tamanho que caiba os comandos. Tip Criar logo antes de chamar a fun\u00e7\u00e3o usart1_init no main! int main ( void ){ /* Initialize the SAM system */ sysclk_init (); board_init (); // Criar a fila aqui! // | // v USART1_init (); USART1_handler Ir\u00e1 receber um caracter da uart e colocar ele na fila xQueueChar Tip No USART1_Handler a fun\u00e7\u00e3o usart_serial_getchar pega um char da serial e salva em c . Voc\u00ea deve enviar esse dado na dila xQueueChar // Dados dispon\u00edvel para leitura if ( ret & US_IER_RXRDY ){ usart_serial_getchar ( USART1 , & c ); printf ( \"%c\" , c ); task_uartRX Ficar\u00e1 lendo a fila xQueueChar e montando uma string interna, quando detectado um \\n envia a string para a fila xQueueCommand . Tip Criar um buffer de chars Ficar fazendo a leitura da fila xQueueChar e alimentando esse buffer Encontrado \\n ? Coloca NULL e envia o buffer para a fila xQueueCommand Come\u00e7a tudo de novo xQueueCommand Uma fila de strings que representam comandos, voc\u00ea deve criar o seu protocolo de comandos. O comando deve ser capaz de inverter o valor dos leds. led 3 toggle : Inverte led 3 led 1 toggle : Inverte led 1 Tip Criar na task_execute task_execute Tarefa que fica lendo a fila de comandos xQueueCommand e realizando os comandos que s\u00e3o enviados por ela. task_led1, task_led2 Tarefas que controlam individualmente cada LED da placa OLED Como validar tudo? Envie um comando pela UART e veja o LED mudar de status Aperte o bot\u00e3o da placa OLED e veja o LED mudar de status B Diagrama do firmware de como seria esse c\u00f3digo caso a parte do LCD touch ( task_lcd e task_mxt ) fosse inserida nele, entrando como um novo produtor. A Comandos: led x on e led x off led 1 on : Acende led 1 led 2 off : Apaga led 2","title":"RTOS - UART"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#rtos-uart","text":"Nesse lab iremos trabalhar com comunica\u00e7\u00e3o UART (aquela do terminal / printf). Praticando RTOS (queue) Preencher ao finalizar o lab Carregando\u2026","title":"RTOS - UART"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#lab","text":"LAB Labs/8-RTOS-UART","title":"Lab"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#inicio","text":"C\u00f3digo exemplo Vamos modificar o seu lab lab-RTOS (aquele dos leds e bot\u00f5es), fa\u00e7a uma c\u00f3pia do seu lab para a nova pasta no seu seu reposit\u00f3rio Labs/8-RTOS-UART O projeto j\u00e1 modificado do lab! Terminal Esse exemplo faz uso da comunica\u00e7\u00e3o UART para debug de c\u00f3digo (via printf), para acessar o terminal no atmel est\u00fadio clique em: View Terminal Window Configure o terminal para a porta que (COM) correta (verificar no windiows) e para operar com um BaudRate de 115200 . Esse c\u00f3digo exemplo j\u00e1 possui a comunica\u00e7\u00e3o UART configurada pela fun\u00e7\u00e3o ( configure_console ), essa fun\u00e7\u00e3o configura a utiliza\u00e7\u00e3o do perif\u00e9rico USART1 operando em modo de comunica\u00e7\u00e3o serial ass\u00edncrona. Os pinos TX e RX da comunica\u00e7\u00e3o serial s\u00e3o conectados ao EDGB, chip respons\u00e1vel pela grava\u00e7\u00e3o e debug do kit de desenvolvimento SAME70-XPLD. A comunica\u00e7\u00e3o UART \u00e9 um protocolo de comunica\u00e7\u00e3o muito utilizado para comunica\u00e7\u00e3o entre dois dispositivos ( Machine-to-Machine , \u00e9 utilizado por exemplo no arduino para a grava\u00e7\u00e3o e debug (print), \u00e9 utilizado por diversos equipamentos para comunica\u00e7\u00e3o e configura\u00e7\u00e3o (impressoras t\u00e9rmicas, m\u00e1quinas de cart\u00e3o de cr\u00e9dito, GPP, sensores de biometria, ...). Note No nosso microcontrolador, temos dois perif\u00e9ricos capazes de realizar comunica\u00e7\u00e3o serial o UART e USART , nesse exemplo, utilizamos o USART . Essa fun\u00e7\u00e3o configura o perif\u00e9rico USART1 para operar como stdio do nosso c\u00f3digo C, toda vez que invocamos a fun\u00e7\u00e3o printf a sa\u00edda dos caracteres \u00e9 enviada para o perif\u00e9rico e \u00e9 serializado por ele. Info Para mais detalhes de como o stdio faz o mapeamento para o perif\u00e9rico em quest\u00e3o, analise o include src/ASF/common/utils/stdio/stdio_serial/stdio_serial.h Vamos adicionar uma nova fun\u00e7\u00e3o ( USART1_init ) que faz praticamente a mesma coisa, por\u00e9m configura a interrup\u00e7\u00e3o desse perif\u00e9rico. A interrup\u00e7\u00e3o ativada \u00e9 para o recebimento de dados pela serial ( US_IER_RXRDY ), toda vez que um novo dado \u00e9 recebido pela serial, o handler USART1_Handler \u00e9 chamado. Outras interrup\u00e7\u00f5es do USART1 Outras interrup\u00e7\u00f5es suportadas pelo USART1: RXRDY: RXRDY Interrupt Enable TXRDY: TXRDY Interrupt Enable OVRE: Overrun Error Interrupt Enable FRAME: Framing Error Interrupt Enable PARE: Parity Error Interrupt Enable TIMEOUT: Time-out Interrupt Enable TXEMPTY: TXEMPTY Interrupt Enable","title":"In\u00edcio"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#preparando-exemplo","text":"Adicione as fun\u00e7\u00f5es USART1_init , usart1_puts e o handler USART1_Handler ao exemplo. USART1_init static void USART1_init ( void ){ /* Configura USART1 Pinos */ sysclk_enable_peripheral_clock ( ID_PIOB ); sysclk_enable_peripheral_clock ( ID_PIOA ); pio_set_peripheral ( PIOB , PIO_PERIPH_D , PIO_PB4 ); // RX pio_set_peripheral ( PIOA , PIO_PERIPH_A , PIO_PA21 ); // TX MATRIX -> CCFG_SYSIO |= CCFG_SYSIO_SYSIO4 ; /* Configura opcoes USART */ const sam_usart_opt_t usart_settings = { . baudrate = 115200 , . char_length = US_MR_CHRL_8_BIT , . parity_type = US_MR_PAR_NO , . stop_bits = US_MR_NBSTOP_1_BIT , . channel_mode = US_MR_CHMODE_NORMAL }; /* Ativa Clock periferico USART0 */ sysclk_enable_peripheral_clock ( ID_USART1 ); stdio_serial_init ( CONF_UART , & usart_settings ); /* Enable the receiver and transmitter. */ usart_enable_tx ( USART1 ); usart_enable_rx ( USART1 ); /* map printf to usart */ ptr_put = ( int ( * )( void volatile * , char )) & usart_serial_putchar ; ptr_get = ( void ( * )( void volatile * , char * )) & usart_serial_getchar ; /* ativando interrupcao */ usart_enable_interrupt ( USART1 , US_IER_RXRDY ); NVIC_SetPriority ( ID_USART1 , 4 ); NVIC_EnableIRQ ( ID_USART1 ); } USART1_Handler void USART1_Handler ( void ){ uint32_t ret = usart_get_status ( USART1 ); BaseType_t xHigherPriorityTaskWoken = pdTRUE ; char c ; // Verifica por qual motivo entrou na interrup\u00e7cao? // RXRDY ou TXRDY // Dados dispon\u00edvel para leitura if ( ret & US_IER_RXRDY ){ usart_serial_getchar ( USART1 , & c ); printf ( \"%c\" , c ); // - Transmissoa finalizada } else if ( ret & US_IER_TXRDY ){ } } A fun\u00e7\u00e3o usart1_puts envia uma string para a serial pelo perif\u00e9rico USART1. usart1_puts uint32_t usart1_puts ( uint8_t * pstring ){ uint32_t i ; while ( * ( pstring + i )) if ( uart_is_tx_empty ( USART1 )) usart_serial_putchar ( USART1 , * ( pstring + i ++ )); } Edite o main para chamarmos a fun\u00e7\u00e3o USART1_init no lugar do configure_console : int main(void) { /* Initialize the SAM system */ sysclk_init(); board_init(); /* Initialize the console uart */ - configure_console(); + USART1_init(); Modifique Inclua USART1_init Inclua USART1_Handler Inclua usart1_puts Substitua configure_console por USART1_init","title":"Preparando exemplo"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#lab_1","text":"Agora com o exemplo preparado vamos implementar o firmware que foi desenvolvido em aula. diagrama feito em sala, enviado no teams O usu\u00e1rio pode modificar os LEDs (recurso) de duas maneiras diferentes: enviando uma mensagem pela UART (terminal) ou apertando os bot\u00f5es da placa. Os bot\u00f5es e a UART servem como 'produtores' de comandos que ser\u00e3o processados por uma tarefa espec\u00edfica. A vantagem desse formato \u00e9: a flexibilidade de cria\u00e7\u00e3o de novos produtores (\u00e9 f\u00e1cil adicionar por exemplo uma segunda uart, ou uma outra comunica\u00e7\u00e3o), basta enviar os dados na fila de comandos; o isolamento entre diferentes partes do firmware.","title":"Lab"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#dicas","text":"A seguir algumas dicas de como fazer o seu c\u00f3digo.","title":"Dicas"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#xqueuechar","text":"Deve ser uma fila de caracteres, especificar um tamanho que caiba os comandos. Tip Criar logo antes de chamar a fun\u00e7\u00e3o usart1_init no main! int main ( void ){ /* Initialize the SAM system */ sysclk_init (); board_init (); // Criar a fila aqui! // | // v USART1_init ();","title":"xQueueChar"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#usart1_handler","text":"Ir\u00e1 receber um caracter da uart e colocar ele na fila xQueueChar Tip No USART1_Handler a fun\u00e7\u00e3o usart_serial_getchar pega um char da serial e salva em c . Voc\u00ea deve enviar esse dado na dila xQueueChar // Dados dispon\u00edvel para leitura if ( ret & US_IER_RXRDY ){ usart_serial_getchar ( USART1 , & c ); printf ( \"%c\" , c );","title":"USART1_handler"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#task_uartrx","text":"Ficar\u00e1 lendo a fila xQueueChar e montando uma string interna, quando detectado um \\n envia a string para a fila xQueueCommand . Tip Criar um buffer de chars Ficar fazendo a leitura da fila xQueueChar e alimentando esse buffer Encontrado \\n ? Coloca NULL e envia o buffer para a fila xQueueCommand Come\u00e7a tudo de novo","title":"task_uartRX"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#xqueuecommand","text":"Uma fila de strings que representam comandos, voc\u00ea deve criar o seu protocolo de comandos. O comando deve ser capaz de inverter o valor dos leds. led 3 toggle : Inverte led 3 led 1 toggle : Inverte led 1 Tip Criar na task_execute","title":"xQueueCommand"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#task_execute","text":"Tarefa que fica lendo a fila de comandos xQueueCommand e realizando os comandos que s\u00e3o enviados por ela.","title":"task_execute"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#task_led1-task_led2","text":"Tarefas que controlam individualmente cada LED da placa OLED Como validar tudo? Envie um comando pela UART e veja o LED mudar de status Aperte o bot\u00e3o da placa OLED e veja o LED mudar de status","title":"task_led1, task_led2"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#b","text":"Diagrama do firmware de como seria esse c\u00f3digo caso a parte do LCD touch ( task_lcd e task_mxt ) fosse inserida nele, entrando como um novo produtor.","title":"B"},{"location":"navigation/Labs/Lab_RTOS_UART/Lab-RTOS-UART/#a","text":"Comandos: led x on e led x off led 1 on : Acende led 1 led 2 off : Apaga led 2","title":"A"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/","text":"LAB - RTOS - WIFI Neste laborat\u00f3rio iremos modificar o exemplo RTOS-WIFI, que realiza uma requisi\u00e7\u00e3o GET em um webserver (Flask) rodando em seu computador, onde o mesmo ap\u00f3s receber essa requisi\u00e7\u00e3o retorna um dado JSON . Lab Exemplo base LAB SAME70-examples/Comunicacao/RTOS-WIFI-WINC1500-get-EXT1 Lab-10-RTOS-WIFI C\u00f3digo exemplo Atualizar o reposit\u00f3rio do SAME70-Examples Vamos modificar o c\u00f3digo exemplo Comunicacao/RTOS-WIFI-WINC1500-get-RTOS-EXT1 , fa\u00e7a uma c\u00f3pia do seu lab para a nova pasta no seu reposit\u00f3rio Lab-9-RTOS-WIFI IoT IoT (Internet of Things) \u00e9 um conceito que tem como objetivo a conex\u00e3o entre objetos e a internet, ela faz parte da revolu\u00e7\u00e3o da Industria 4.0 e est\u00e1 cada vez mais presentes em nossas vidas. Desenvolver sistemas embarcados muitas vezes envolvem conectar esses sistemas na internet, e isso pode se dar atr\u00e1ves de diversos meios: Cabo de rede (Ethernet) Conex\u00e3o WIFI 3G/4G/GSM Sistemas de comunica\u00e7\u00e3o de baixa energia: LoRa/ ... Sistema de comunica\u00e7\u00e3o propriet\u00e1rio AM/FM/... Para cada aplica\u00e7\u00e3o existe uma forma de comunica\u00e7\u00e3o ideal, e voc\u00eas como engenheiros de computa\u00e7\u00e3o devem estar cientes dessas formas e saber interagir com elas. Nesse laborat\u00f3rio iremos explorar um pouco a comunica\u00e7\u00e3o WIFI em sistemas embarcados, para isso iremos conectar um m\u00f3dulo externo a nossa placa que servir\u00e1 como 'placa de rede' do nosso microcontrolador, esse m\u00f3dulo \u00e9 o WINC 1500. Warning Ao desenvolver sistemas IoT voc\u00ea \u00e9 respons\u00e1vel pela seguran\u00e7a dos dados que est\u00e3o sendo enviados/recebidos. E n\u00e3o s\u00f3 na ponta do embarcado, como tamb\u00e9m no armazenamento de dados no servidor. https://www.iotforall.com/5-worst-iot-hacking-vulnerabilities/ https://observer.com/2015/07/eight-internet-of-things-security-fails/ https://medium.com/iot-security-review/5-internet-of-things-security-fails-fae2fb2bb871 https://securityintelligence.com/organizations-continue-to-fail-at-iot-security-and-the-consequences-are-growing/ WINC1500 Existem in\u00fameros m\u00f3dulos WIFI para serem utilizados em sistemas embarcados, voc\u00ea pode comprar microcontroladores que possuem toda a parte WIFI integrada no chip (exemplo: STM32 ), nesses casos n\u00e3o \u00e9 necess\u00e1rio conectar um m\u00f3dulo externo, tudo est\u00e1 integrado no chip (tirando a antena)! O m\u00f3dulo que iremos utilizar \u00e9 desenvolvido pela Microchip e chama Winc1500 Esse m\u00f3dulo possui comunica\u00e7\u00e3o SPI (similar a UART, por\u00e9m desenvolvida para comunica\u00e7\u00e3o entre chips) que ser\u00e1 usada como interface de controle do uC para enviar/ receber um dado wifi, temos que nos comunicar com esse m\u00f3dulo. Essa parte est\u00e1 feita nos exemplos fornecidos, e \u00e9 chamada de comunica\u00e7\u00e3o M2M: Machine-to-Machine . Exemplo Esse laborat\u00f3rio faz uso do exemplo dispon\u00edvel no reposit\u00f3rio SAME70-Examples/RTOS/WIFI-WINC1500-get-RTOS-EXT1 que possui duas partes: python-server : servidor em flask que possui um forms e uma p\u00e1gina de status que retorna um valor em json WIFI-RTOS-get : firmware a ser executado na nossa placa. python-server Acesse a pasta python-server que cont\u00e9m o script server.py , instale o flask via pip e execute o programa: pip install -r requirements.txt --user python server.py --host = 0 .0.0.0 O resultado esperado deve ser o seguinte: \u279c python-server git: ( master ) \u2717 python server.py * Serving Flask app \"server\" ( lazy loading ) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on * Running on http://0.0.0.0:5000/ ( Press CTRL+C to quit ) * Restarting with stat * Debugger is active! * Debugger PIN: 278 -674-158 O servidor em Flask \u00e9 simples e permite que alteremos uma vari\u00e1vel led via um form e lermos o status via um get: http://localhost:5000 http://localhost:5000/status Preparando o WebServer Para validar, conecte seu celular na mesma rede WIFi e acesse o ip da sua m\u00e1quina na porta 5000 e valide se o webserver est\u00e1 funcionando. Info Deixe o servidor rodando, vamos fazer o embarcado se conectar nele. Tip Para descobrir seu IP abra outro terminal e execute o comando ipconfig , nos exemplos iremos usar: http://192.168.0.138:5000 , mas voc\u00ea deve adequar o IP ao seu . Anote o seu IP, iremos usar mais para frente Se n\u00e3o funcionar, talvez seja necess\u00e1rio desativar o firewall do windows: https://support.microsoft.com/en-us/windows/turn-microsoft-defender-firewall-on-or-off-ec0844f7-aebd-0583-67fe-601ecf5d774f Lembre de ativar novamente ap\u00f3s a atividade. Tarefas Instalar requirements.txt Subir o servidor Flask Validar local ( http://localhost:5000 ) Validar de outro dispositivo (exemplo: http://192.168.0.138:5000 ) isso testa se o seu Windows est\u00e1 permitindo acesso externo ao seu server, precisamos disso j\u00e1 que queremos que o embarcado se conecte a esse servidor. Mantenha o servidor em execu\u00e7\u00e3o. N\u00c3O SIGA SEM QUE TODOS OS PASSOS ANTERIORES ESTIVEREM FUNCIONANDO WIFI-RTOS-get Vamos agora explorar e executar o nosso firmware. Conectando o hardware Conecte o m\u00f3dulo WINC1500 no EXT-1 do kit de desenvolvimento. Diagrama Conex\u00e3o Entendendo o firmware Vamos relembrar um pouco de camada f\u00edsica e Tecweb agora, toda vez que voc\u00ea acessa uma p\u00e1gina da internet um socket \u00e9 criado, este socket \u00e9 um canal de comunica\u00e7\u00e3o TCP/UDP entre dois pontos via comunica\u00e7\u00e3o internet. Uma vez estabelecido o socket o client (no nosso caso o embarcado) pode fazer uma requisi\u00e7\u00e3o (get) ou um envio de informa\u00e7\u00e3o (post). Nesse exemplo iremos fazer um get no servidor que est\u00e1 rodando no seu computador. Nosso firmware ir\u00e1 seguindo os seguintes passos a seguir: WIFI (camadas: network access e internet ) Conecta no roteador Busca IP no DCHP Socket (camadas: application e transport ) Cria novo socket Realiza get L\u00ea ack L\u00ea mensagem tasks O firmware exemplo possui duas tarefas: task_wifi e task_process , a primeira \u00e9 respons\u00e1vel por realizar toda a comunica\u00e7\u00e3o com o m\u00f3dulo WINC1500 e fazer a inicializa\u00e7\u00e3o da comunica\u00e7\u00e3o socket com o webserver em Python, a segunda \u00e9 respons\u00e1vel por gerenciar as mensagens que ser\u00e3o enviadas para o servidor. A task_wifi gerencia alguns callbacks de software, que s\u00e3o eventos gerados do m\u00f3dulo WIFI, existem v\u00e1rios callbacks que podem ser utilizados, nesse exemplo usamos: wifi_cb : callback de eventos relacionado a camada f\u00edsica do WIFI ( conex\u00e3o, ssid list, ...) resolve_cb : callback relacionado a resolu\u00e7\u00e3o de nome no DNS, se quisermos acessar um HOST_NAME e n\u00e3o um ip (google.com -> 10.21.3.12). socket_cb : eventos de socket (conex\u00e3o/ nova mensagem/ erro/ ...) A task_process aguarda um socket ter sido criado na task_wifi e quando isso for verdadeiro faz um envio de um comando do tipo get e aguarda por dois pacotes de retorno, o ack e a msg , que cont\u00e9m o payload requisitado (no nosso caso um json). Essa tarefa foi implementada com a m\u00e1quina de estados a seguir em mente, usando o operador switch case enum states { WAIT = 0 , GET , ACK , MSG , TIMEOUT , DONE , }; Lab Info Abra o projeto no Atmel Studio Vamos agora come\u00e7ar o lab para valer, primeiro vamos executar o exemplo. Mas para isso \u00e9 necess\u00e1rios configurarmos o m\u00f3dulo WIFI para acessar a rede que est\u00e1 dispon\u00edvel da sua casa. Preparando o firmware Devemos configurar o main.h do exemplo adicionando as informa\u00e7\u00f5es do roteador na qual ele deve se conectar, edite o arquivo com as configura\u00e7\u00f5es da sua rede: A configura\u00e7\u00e3o da rede: /** Wi-Fi Settings */ #define MAIN_WLAN_SSID \"LabArqComp\" /**< Destination SSID */ #define MAIN_WLAN_PSK \"s4m370xpld\" /**< Password for Destination SSID */ IP e porta do servidor (seu computador): #define MAIN_SERVER_PORT 5000 #define MAIN_SERVER_NAME \"192.168.42.42\" Warning O sistema embarcado e o webserver devem estar na mesma rede! O modulo winc1500 s\u00f3 se conecta em rede de 2.4Ghz Sugest\u00e3o: fa\u00e7a seu celular virar um acesspoint, conecte o embarcado e o computador nele! Tarefa Conecte o WINC1500 no EXT1 Adicione informa\u00e7\u00f5es do SSID da sua rede Modifique o IP do servidor com o IP da sua m\u00e1quina Programe o uC Resultados esperados Terminal Window (Atmel Studio): Terminal do flask: 192 .168.0.107 - - [ 26 /May/2020 16 :51:07 ] \"GET /status HTTP/1.1\" 200 - 192 .168.0.107 - - [ 26 /May/2020 16 :51:17 ] \"GET /status HTTP/1.1\" 200 - Breve descri\u00e7\u00e3o do funcionamento Nosso embarcado envia uma requisi\u00e7\u00e3o GET atrav\u00e9s do MAIN_PREFIX_BUFFER definido dentro do main.h : /** Send buffer of TCP socket. */ #define MAIN_PREFIX_BUFFER \"GET /status HTTP/1.1\\r\\n Accept: */*\\r\\n\\r\\n\" Nosso webserver (Flask) recebe essa requisi\u00e7\u00e3o e verifica o que foi recebido, nesse caso ele recebe o \"/status\" ap\u00f3s o GET e responde com o seguinte JSON {led' : '1'} : @app . route ( '/status' , methods = [ 'POST' , 'GET' ]) def status (): global led if request . method == 'POST' : status = request . form led = status [ 'LED' ] return render_template ( \"status.html\" , status = status ) else : return jsonify ({ 'led' : led }), 200 Acionando LED conforme led:status Vamos agora acionar o LED da placa conforme o status recebido no comando get , se valor igual a 0 apagamos o LED da placa e se valor igual a 1 acendemos o LED da placa. Warning Voc\u00ea deve inicializar o pino do LED da placa como sa\u00edda! Isso n\u00e3o est\u00e1 feito. Para isso, ser\u00e1 necess\u00e1rio realizar o parse da mensagem HTML que \u00e9 enviada pelo servidor, isso deve ser feito dentro da task_process . Lembre que nessa tarefa implementamos uma m\u00e1quina de estados, e \u00e9 no estado msg que possu\u00edmos a mensagem com o status do nosso LED. case msg case MSG : printf ( \"STATE: MSG \\n \" ); memset ( g_receivedBuffer , 0 , MAIN_WIFI_M2M_BUFFER_SIZE ); recv ( tcp_client_socket , & g_receivedBuffer [ 0 ], MAIN_WIFI_M2M_BUFFER_SIZE , 0 ); if ( xQueueReceive ( xQueueMsg , & p_recvMsg , 5000 ) == pdTRUE ){ printf ( STRING_LINE ); printf ( p_recvMsg -> pu8Buffer ); printf ( STRING_EOL ); printf ( STRING_LINE ); state = DONE ; } else { state = TIMEOUT ; }; break ; A mensagem com o conte\u00fado (head + json) \u00e9 salva no buffer p_recvMsg->pu8Buffer) . Exemplo do conte\u00fado do buffer Content-Type: application/json Content-Length: 15 Server: Werkzeug/1.0.1 Python/3.6.9 Date: Tue, 26 May 2020 20:23:04 GMT { \"led\": 0 } \u00c9 necess\u00e1rio processar esse buffer e encontrar o valor que est\u00e1 associado ao led . A forma mais 'f\u00e1cil' de se fazer isso com C \u00e9 utilizando a fun\u00e7\u00e3o strstr , que retorna um ponteiro para o local de onde foi encontrado a substring. The C library function char *strstr(const char *haystack, const char *needle) function finds the first occurrence of the substring needle in the string haystack. The terminating '\\0' characters are not compared. Fonte: https://www.tutorialspoint.com/c_standard_library/c_function_strstr.htm Tip Busque no buffer a substring \"led\": . Tarefas Inicialize o led da placa como sa\u00edda Modificar o estado MSG para encontrar o valor do led modifique O led para: status = 1: acende status = 0: apaga Progress At\u00e9 aqui \u00e9 C B - melhorando o firmware Vamos alterar como o get \u00e9 realizado, da forma atual temos um chamado de #define MAIN_PREFIX_BUFFER que define a string da mensagem que ser\u00e1 enviada no get , que \u00e9 copiada para o buffer global g_sendBuffer : case GET: printf(\"STATE: GET \\n\"); sprintf((char *)g_sendBuffer, MAIN_PREFIX_BUFFER); send(tcp_client_socket, g_sendBuffer, strlen((char *)g_sendBuffer), 0); state = ACK; break; Muito melhor seria termos uma fun\u00e7\u00e3o que recebe como par\u00e2metro o g_sendBuffer e o path do commando get ( /status ). Tarefa Crie uma fun\u00e7\u00e3o que formate o comando get Use a fun\u00e7\u00e3o no estado GET Teste! Tip Mude o valor no servidor flask e veja o led mudando o status http://localhost:5000 Tem muito atraso? Quanto tempo leva essa atualiza\u00e7\u00e3o? pq? A Podemos melhorar v\u00e1rias coisas nesse projeto, mas vamos por partes. A primeira coisa que podemos fazer \u00e9 adicionar o bot\u00e3o da placa e fazer ele tamb\u00e9m controlar o LED. Tarefa Adicione o bot\u00e3o da placa -> callback -> sem\u00e1foro O LED \u00e9 controlado ou pelo bot\u00e3o da placa ou pelo servidor flask Preencher ao finalizar o lab Carregando\u2026","title":"LAB - RTOS - WIFI"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#lab-rtos-wifi","text":"Neste laborat\u00f3rio iremos modificar o exemplo RTOS-WIFI, que realiza uma requisi\u00e7\u00e3o GET em um webserver (Flask) rodando em seu computador, onde o mesmo ap\u00f3s receber essa requisi\u00e7\u00e3o retorna um dado JSON .","title":"LAB - RTOS - WIFI"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#lab","text":"Exemplo base LAB SAME70-examples/Comunicacao/RTOS-WIFI-WINC1500-get-EXT1 Lab-10-RTOS-WIFI C\u00f3digo exemplo Atualizar o reposit\u00f3rio do SAME70-Examples Vamos modificar o c\u00f3digo exemplo Comunicacao/RTOS-WIFI-WINC1500-get-RTOS-EXT1 , fa\u00e7a uma c\u00f3pia do seu lab para a nova pasta no seu reposit\u00f3rio Lab-9-RTOS-WIFI","title":"Lab"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#iot","text":"IoT (Internet of Things) \u00e9 um conceito que tem como objetivo a conex\u00e3o entre objetos e a internet, ela faz parte da revolu\u00e7\u00e3o da Industria 4.0 e est\u00e1 cada vez mais presentes em nossas vidas. Desenvolver sistemas embarcados muitas vezes envolvem conectar esses sistemas na internet, e isso pode se dar atr\u00e1ves de diversos meios: Cabo de rede (Ethernet) Conex\u00e3o WIFI 3G/4G/GSM Sistemas de comunica\u00e7\u00e3o de baixa energia: LoRa/ ... Sistema de comunica\u00e7\u00e3o propriet\u00e1rio AM/FM/... Para cada aplica\u00e7\u00e3o existe uma forma de comunica\u00e7\u00e3o ideal, e voc\u00eas como engenheiros de computa\u00e7\u00e3o devem estar cientes dessas formas e saber interagir com elas. Nesse laborat\u00f3rio iremos explorar um pouco a comunica\u00e7\u00e3o WIFI em sistemas embarcados, para isso iremos conectar um m\u00f3dulo externo a nossa placa que servir\u00e1 como 'placa de rede' do nosso microcontrolador, esse m\u00f3dulo \u00e9 o WINC 1500. Warning Ao desenvolver sistemas IoT voc\u00ea \u00e9 respons\u00e1vel pela seguran\u00e7a dos dados que est\u00e3o sendo enviados/recebidos. E n\u00e3o s\u00f3 na ponta do embarcado, como tamb\u00e9m no armazenamento de dados no servidor. https://www.iotforall.com/5-worst-iot-hacking-vulnerabilities/ https://observer.com/2015/07/eight-internet-of-things-security-fails/ https://medium.com/iot-security-review/5-internet-of-things-security-fails-fae2fb2bb871 https://securityintelligence.com/organizations-continue-to-fail-at-iot-security-and-the-consequences-are-growing/","title":"IoT"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#winc1500","text":"Existem in\u00fameros m\u00f3dulos WIFI para serem utilizados em sistemas embarcados, voc\u00ea pode comprar microcontroladores que possuem toda a parte WIFI integrada no chip (exemplo: STM32 ), nesses casos n\u00e3o \u00e9 necess\u00e1rio conectar um m\u00f3dulo externo, tudo est\u00e1 integrado no chip (tirando a antena)! O m\u00f3dulo que iremos utilizar \u00e9 desenvolvido pela Microchip e chama Winc1500 Esse m\u00f3dulo possui comunica\u00e7\u00e3o SPI (similar a UART, por\u00e9m desenvolvida para comunica\u00e7\u00e3o entre chips) que ser\u00e1 usada como interface de controle do uC para enviar/ receber um dado wifi, temos que nos comunicar com esse m\u00f3dulo. Essa parte est\u00e1 feita nos exemplos fornecidos, e \u00e9 chamada de comunica\u00e7\u00e3o M2M: Machine-to-Machine .","title":"WINC1500"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#exemplo","text":"Esse laborat\u00f3rio faz uso do exemplo dispon\u00edvel no reposit\u00f3rio SAME70-Examples/RTOS/WIFI-WINC1500-get-RTOS-EXT1 que possui duas partes: python-server : servidor em flask que possui um forms e uma p\u00e1gina de status que retorna um valor em json WIFI-RTOS-get : firmware a ser executado na nossa placa.","title":"Exemplo"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#python-server","text":"Acesse a pasta python-server que cont\u00e9m o script server.py , instale o flask via pip e execute o programa: pip install -r requirements.txt --user python server.py --host = 0 .0.0.0 O resultado esperado deve ser o seguinte: \u279c python-server git: ( master ) \u2717 python server.py * Serving Flask app \"server\" ( lazy loading ) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on * Running on http://0.0.0.0:5000/ ( Press CTRL+C to quit ) * Restarting with stat * Debugger is active! * Debugger PIN: 278 -674-158 O servidor em Flask \u00e9 simples e permite que alteremos uma vari\u00e1vel led via um form e lermos o status via um get: http://localhost:5000 http://localhost:5000/status","title":"python-server"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#preparando-o-webserver","text":"Para validar, conecte seu celular na mesma rede WIFi e acesse o ip da sua m\u00e1quina na porta 5000 e valide se o webserver est\u00e1 funcionando. Info Deixe o servidor rodando, vamos fazer o embarcado se conectar nele. Tip Para descobrir seu IP abra outro terminal e execute o comando ipconfig , nos exemplos iremos usar: http://192.168.0.138:5000 , mas voc\u00ea deve adequar o IP ao seu . Anote o seu IP, iremos usar mais para frente Se n\u00e3o funcionar, talvez seja necess\u00e1rio desativar o firewall do windows: https://support.microsoft.com/en-us/windows/turn-microsoft-defender-firewall-on-or-off-ec0844f7-aebd-0583-67fe-601ecf5d774f Lembre de ativar novamente ap\u00f3s a atividade. Tarefas Instalar requirements.txt Subir o servidor Flask Validar local ( http://localhost:5000 ) Validar de outro dispositivo (exemplo: http://192.168.0.138:5000 ) isso testa se o seu Windows est\u00e1 permitindo acesso externo ao seu server, precisamos disso j\u00e1 que queremos que o embarcado se conecte a esse servidor. Mantenha o servidor em execu\u00e7\u00e3o. N\u00c3O SIGA SEM QUE TODOS OS PASSOS ANTERIORES ESTIVEREM FUNCIONANDO","title":"Preparando o WebServer"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#wifi-rtos-get","text":"Vamos agora explorar e executar o nosso firmware.","title":"WIFI-RTOS-get"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#conectando-o-hardware","text":"Conecte o m\u00f3dulo WINC1500 no EXT-1 do kit de desenvolvimento. Diagrama Conex\u00e3o","title":"Conectando o hardware"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#entendendo-o-firmware","text":"Vamos relembrar um pouco de camada f\u00edsica e Tecweb agora, toda vez que voc\u00ea acessa uma p\u00e1gina da internet um socket \u00e9 criado, este socket \u00e9 um canal de comunica\u00e7\u00e3o TCP/UDP entre dois pontos via comunica\u00e7\u00e3o internet. Uma vez estabelecido o socket o client (no nosso caso o embarcado) pode fazer uma requisi\u00e7\u00e3o (get) ou um envio de informa\u00e7\u00e3o (post). Nesse exemplo iremos fazer um get no servidor que est\u00e1 rodando no seu computador. Nosso firmware ir\u00e1 seguindo os seguintes passos a seguir: WIFI (camadas: network access e internet ) Conecta no roteador Busca IP no DCHP Socket (camadas: application e transport ) Cria novo socket Realiza get L\u00ea ack L\u00ea mensagem","title":"Entendendo o firmware"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#tasks","text":"O firmware exemplo possui duas tarefas: task_wifi e task_process , a primeira \u00e9 respons\u00e1vel por realizar toda a comunica\u00e7\u00e3o com o m\u00f3dulo WINC1500 e fazer a inicializa\u00e7\u00e3o da comunica\u00e7\u00e3o socket com o webserver em Python, a segunda \u00e9 respons\u00e1vel por gerenciar as mensagens que ser\u00e3o enviadas para o servidor. A task_wifi gerencia alguns callbacks de software, que s\u00e3o eventos gerados do m\u00f3dulo WIFI, existem v\u00e1rios callbacks que podem ser utilizados, nesse exemplo usamos: wifi_cb : callback de eventos relacionado a camada f\u00edsica do WIFI ( conex\u00e3o, ssid list, ...) resolve_cb : callback relacionado a resolu\u00e7\u00e3o de nome no DNS, se quisermos acessar um HOST_NAME e n\u00e3o um ip (google.com -> 10.21.3.12). socket_cb : eventos de socket (conex\u00e3o/ nova mensagem/ erro/ ...) A task_process aguarda um socket ter sido criado na task_wifi e quando isso for verdadeiro faz um envio de um comando do tipo get e aguarda por dois pacotes de retorno, o ack e a msg , que cont\u00e9m o payload requisitado (no nosso caso um json). Essa tarefa foi implementada com a m\u00e1quina de estados a seguir em mente, usando o operador switch case enum states { WAIT = 0 , GET , ACK , MSG , TIMEOUT , DONE , };","title":"tasks"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#lab_1","text":"Info Abra o projeto no Atmel Studio Vamos agora come\u00e7ar o lab para valer, primeiro vamos executar o exemplo. Mas para isso \u00e9 necess\u00e1rios configurarmos o m\u00f3dulo WIFI para acessar a rede que est\u00e1 dispon\u00edvel da sua casa.","title":"Lab"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#preparando-o-firmware","text":"Devemos configurar o main.h do exemplo adicionando as informa\u00e7\u00f5es do roteador na qual ele deve se conectar, edite o arquivo com as configura\u00e7\u00f5es da sua rede: A configura\u00e7\u00e3o da rede: /** Wi-Fi Settings */ #define MAIN_WLAN_SSID \"LabArqComp\" /**< Destination SSID */ #define MAIN_WLAN_PSK \"s4m370xpld\" /**< Password for Destination SSID */ IP e porta do servidor (seu computador): #define MAIN_SERVER_PORT 5000 #define MAIN_SERVER_NAME \"192.168.42.42\" Warning O sistema embarcado e o webserver devem estar na mesma rede! O modulo winc1500 s\u00f3 se conecta em rede de 2.4Ghz Sugest\u00e3o: fa\u00e7a seu celular virar um acesspoint, conecte o embarcado e o computador nele! Tarefa Conecte o WINC1500 no EXT1 Adicione informa\u00e7\u00f5es do SSID da sua rede Modifique o IP do servidor com o IP da sua m\u00e1quina Programe o uC","title":"Preparando o firmware"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#resultados-esperados","text":"Terminal Window (Atmel Studio): Terminal do flask: 192 .168.0.107 - - [ 26 /May/2020 16 :51:07 ] \"GET /status HTTP/1.1\" 200 - 192 .168.0.107 - - [ 26 /May/2020 16 :51:17 ] \"GET /status HTTP/1.1\" 200 - Breve descri\u00e7\u00e3o do funcionamento Nosso embarcado envia uma requisi\u00e7\u00e3o GET atrav\u00e9s do MAIN_PREFIX_BUFFER definido dentro do main.h : /** Send buffer of TCP socket. */ #define MAIN_PREFIX_BUFFER \"GET /status HTTP/1.1\\r\\n Accept: */*\\r\\n\\r\\n\" Nosso webserver (Flask) recebe essa requisi\u00e7\u00e3o e verifica o que foi recebido, nesse caso ele recebe o \"/status\" ap\u00f3s o GET e responde com o seguinte JSON {led' : '1'} : @app . route ( '/status' , methods = [ 'POST' , 'GET' ]) def status (): global led if request . method == 'POST' : status = request . form led = status [ 'LED' ] return render_template ( \"status.html\" , status = status ) else : return jsonify ({ 'led' : led }), 200","title":"Resultados esperados"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#acionando-led-conforme-ledstatus","text":"Vamos agora acionar o LED da placa conforme o status recebido no comando get , se valor igual a 0 apagamos o LED da placa e se valor igual a 1 acendemos o LED da placa. Warning Voc\u00ea deve inicializar o pino do LED da placa como sa\u00edda! Isso n\u00e3o est\u00e1 feito. Para isso, ser\u00e1 necess\u00e1rio realizar o parse da mensagem HTML que \u00e9 enviada pelo servidor, isso deve ser feito dentro da task_process . Lembre que nessa tarefa implementamos uma m\u00e1quina de estados, e \u00e9 no estado msg que possu\u00edmos a mensagem com o status do nosso LED. case msg case MSG : printf ( \"STATE: MSG \\n \" ); memset ( g_receivedBuffer , 0 , MAIN_WIFI_M2M_BUFFER_SIZE ); recv ( tcp_client_socket , & g_receivedBuffer [ 0 ], MAIN_WIFI_M2M_BUFFER_SIZE , 0 ); if ( xQueueReceive ( xQueueMsg , & p_recvMsg , 5000 ) == pdTRUE ){ printf ( STRING_LINE ); printf ( p_recvMsg -> pu8Buffer ); printf ( STRING_EOL ); printf ( STRING_LINE ); state = DONE ; } else { state = TIMEOUT ; }; break ; A mensagem com o conte\u00fado (head + json) \u00e9 salva no buffer p_recvMsg->pu8Buffer) . Exemplo do conte\u00fado do buffer Content-Type: application/json Content-Length: 15 Server: Werkzeug/1.0.1 Python/3.6.9 Date: Tue, 26 May 2020 20:23:04 GMT { \"led\": 0 } \u00c9 necess\u00e1rio processar esse buffer e encontrar o valor que est\u00e1 associado ao led . A forma mais 'f\u00e1cil' de se fazer isso com C \u00e9 utilizando a fun\u00e7\u00e3o strstr , que retorna um ponteiro para o local de onde foi encontrado a substring. The C library function char *strstr(const char *haystack, const char *needle) function finds the first occurrence of the substring needle in the string haystack. The terminating '\\0' characters are not compared. Fonte: https://www.tutorialspoint.com/c_standard_library/c_function_strstr.htm Tip Busque no buffer a substring \"led\": . Tarefas Inicialize o led da placa como sa\u00edda Modificar o estado MSG para encontrar o valor do led modifique O led para: status = 1: acende status = 0: apaga Progress At\u00e9 aqui \u00e9 C","title":"Acionando LED conforme led:status"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#b-melhorando-o-firmware","text":"Vamos alterar como o get \u00e9 realizado, da forma atual temos um chamado de #define MAIN_PREFIX_BUFFER que define a string da mensagem que ser\u00e1 enviada no get , que \u00e9 copiada para o buffer global g_sendBuffer : case GET: printf(\"STATE: GET \\n\"); sprintf((char *)g_sendBuffer, MAIN_PREFIX_BUFFER); send(tcp_client_socket, g_sendBuffer, strlen((char *)g_sendBuffer), 0); state = ACK; break; Muito melhor seria termos uma fun\u00e7\u00e3o que recebe como par\u00e2metro o g_sendBuffer e o path do commando get ( /status ). Tarefa Crie uma fun\u00e7\u00e3o que formate o comando get Use a fun\u00e7\u00e3o no estado GET Teste! Tip Mude o valor no servidor flask e veja o led mudando o status http://localhost:5000 Tem muito atraso? Quanto tempo leva essa atualiza\u00e7\u00e3o? pq?","title":"B - melhorando o firmware"},{"location":"navigation/Labs/Lab_RTOS_WIFI/Lab-RTOS-WIFI/#a","text":"Podemos melhorar v\u00e1rias coisas nesse projeto, mas vamos por partes. A primeira coisa que podemos fazer \u00e9 adicionar o bot\u00e3o da placa e fazer ele tamb\u00e9m controlar o LED. Tarefa Adicione o bot\u00e3o da placa -> callback -> sem\u00e1foro O LED \u00e9 controlado ou pelo bot\u00e3o da placa ou pelo servidor flask Preencher ao finalizar o lab Carregando\u2026","title":"A"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/","text":"LAB - RTOS - IMU Pasta Lab6-RTOS-IMU Neste laborat\u00f3rio iremos realizar uma comunica\u00e7\u00e3o I2C com um sensor inercial, e aplicar um processamento de fus\u00e3o de dados para obtermos a localiza\u00e7\u00e3o no espa\u00e7o do sensor. Info Usar como base o c\u00f3digo do OLED com RTOS. Teoria I2C ( eye-squared-C ) \u00e9 um protocolo de comunica\u00e7\u00e3o do tipo Machine-to-machine muito utilizado para comunica\u00e7\u00e3o entre microcontrolador e um dispositivo (sensor ou atuador) externo, criado pela Philips Semiconductor em 1982 e liberado para uso sem licen\u00e7a em 2006 . O i2c \u00e9 uma comunica\u00e7\u00e3o s\u00edncrona e utiliza duas vias: serial data line (SDA) e serial clock line (SCL), a comunica\u00e7\u00e3o \u00e9 sempre inicializada pelo Controlador (o microcontrolador) e respondida pelo Target (componente). A imagem a seguir \u00e9 um exemplo de como utilizar o i2c para conectar m\u00faltiplos dispositivos em um controlador: Tip Cuidado, usaremos o termo perif\u00e9rico n\u00e3o s\u00f3 para referenciar os componentes do microcontrolador, da placa, mas agora tamb\u00e9m novos componentes plugados no kit. Existem no mercado v\u00e1rios sensores que possuem comunica\u00e7\u00e3o i2c, no lab temos v\u00e1rios: IMU C\u00e2mera temperatura press\u00e3o batimento card\u00edaco D\u00ea uma olhada nos sensores da adafruit i2c: https://www.adafruit.com/?q=i2c+sensor&sort=BestMatch Protocolo Info Apenas uma breve apresenta\u00e7\u00e3o, o I2C \u00e9 um protocolo mais complicado do que aparenta ser: https://learn.sparkfun.com/tutorials/i2c/all https://www.i2c-bus.org/i2c-primer/common-problems/ A comunicac\u00e3o i2c faz uso de dois sinais: clk e data, o clock \u00e9 sempre gerado pelo controlador, diferente da UART (a de camada f\u00edsica, e a que usamos para o m\u00f3dulo bluetooth) o i2c usa um tipo de sinal chamado de open drain , que significa que o sinal na linha \u00e9 sempre positivo ( vcc ) e os dispositivos quando querem enviar o valor zero, apenas aterram a linha, notem que para isso \u00e9 necess\u00e1rio um pull-up na linha. Info A ideia do dreno aberto \u00e9 permitir que mais de um dispositivo controle a linha, como o controle \u00e9 apenas aterrando o sinal, n\u00e3o h\u00e1 risco de queimar o pino. O protocolo do I2C \u00e9 mais complexo que a da UART (o de camada f\u00edsica, e o usado para comunica\u00e7\u00e3o com o m\u00f3dulo bluetooth), no I2C cada dispositivo possui um endere\u00e7o que deve ser enviado no come\u00e7o da comunica\u00e7\u00e3o, a cada envio de dado pelo controlador, o dispositivo responde com um sinal de ACK (um bit no final do pacote). O controlador pode executar duas tarefas diferente: Requisitar um dado Enviar um dado As tarefas s\u00e3o definidas pelo \u00faltimo bit no pacote de endere\u00e7o. Info O envio de dado pode ser utilizado para a configura\u00e7\u00e3o de um sensor, uma vez configurado, podemos requisitar dados. Ap\u00f3s o envio do endere\u00e7o, o controlador come\u00e7a enviar o pacote de dados, o envio s\u00f3 termina quando um STOP \u00e9 enviado. A seguir uma vis\u00e3o geral bem simplificada da comunica\u00e7\u00e3o Informa\u00e7\u00f5es importantes: O i2c pode operar com pacotes de 8 ou 10 bits O controlador deve enviar o endere\u00e7o do perif\u00e9rico no in\u00edcio da comunica\u00e7\u00e3o O controlador deve definir se ir\u00e1 ler ou escrever no perif\u00e9rico (W/R) Tanto na leitura quanto na escrita quem gera o clock \u00e9 o controlador Ao final de cada pacote um ACK deve ser gerado Uma comunica\u00e7\u00e3o pode transmitir um ou mais pacotes O fim de uma comunica\u00e7\u00e3o \u00e9 definido pelo STOP bit Two-wire Interface (TWIHS) O nosso microcontrolador possui um perif\u00e9rico chamado de TWIHS que implementa a comunica\u00e7\u00e3o i2c, notem que o perif\u00e9rico precisa controlar os pinos do PIO (para gerar o clock, escrever no pino, ler um valor), o diagrama extra\u00eddo do manual mostra como o perif\u00e9rico interfaceia com o PIO: No nosso uC possu\u00edmos um total de 3 TWIHS e cada um possui pino do PIO pr\u00e9 definido: Warning Na placa que utilizamos (SAME70-XPLD), nem todos os pinos do uC que tem acesso ao per\u00edfico TWIHS est\u00e3o dispon\u00edveis. Na coluna XPLD-CONN da tabela acima est\u00e1 indicado quais e onde os pinos est\u00e3o dispon\u00edveis. MPU-6050 Todo Arnaldo (um par\u00e1grafo por item) o que \u00e9 IMU e como ela funciona a onde \u00e9 usado MEMS Explicar um pouco o sensor accelerometro e para que serve imu e para que serve bussola e para que serve talvez uma ou duas perguntas para eles terem que abrir o manual e buscar informacoes. fus\u00e3o de dados? M\u00f3dulo GY-521 Para termos acesso ao MPU6050 iremos usar um m\u00f3dulo GY-521, no Brasil \u00e9 poss\u00edvel achar por R$25 . Um m\u00f3dulo com maior precis\u00e3o pode ser comprado e importado pela sparkfun : \"Our breakout board for the MPU-6050 makes this tiny QFN package easy to work into your project. Every pin you need to get up and running is broken out to 0.1\" headers, including the auxiliary master I2C bus which allows the MPU-6050 to access external magnetometers and other sensors.\" LAB Agora que j\u00e1 vimos um pouco sobre o I2C e sobre o chip que iremos interagir, podemos come\u00e7ar o lab. Lab usar apenas printf conectar sensor placa i2c wizard configurar pio mux configurar TWIHS ler manual do MPU6050 e achar endere\u00e7o I2C usar valor para ler MPU6050_RA_WHO_AM_I explicar dar c\u00f3digo pronto que configura e l\u00ea giro e accel importar c\u00f3digo fus\u00e3o de dados implementar fus\u00e3o de dados manual: https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf task imu Vamos criar uma task para realizar a leitura da IMU. Exercise Crie uma task chamada de task_imu , lembre de: Inicializar na main Task devem possuir while(1) e nunca retornar TWIHS Para fazermos uso perif\u00e9rico TWIHS ser\u00e1 necess\u00e1rio adicionarmos ele no asf wizard: Exercise Adicione o TWIHS no ASF Wizard Com a biblioteca adicionada agora devemos criar uma fun\u00e7\u00e3o para configurar o perif\u00e9rico: Ativar o clock do PMC Operar como controlador Definir a frequ\u00eancia de opera\u00e7\u00e3o Permitir que o TWIHS controle os pinos do PIO Exercise Adicione a fun\u00e7\u00e3o a seguir no c\u00f3digo: void mcu6050_i2c_bus_init ( void ) { twihs_options_t mcu6050_option ; pmc_enable_periph_clk ( TWIHS_MCU6050_ID ); /* Configure the options of TWI driver */ mcu6050_option . master_clk = sysclk_get_cpu_hz (); mcu6050_option . speed = 40000 ; twihs_master_init ( TWIHS_MCU6050 , & mcu6050_option ); } Exercise Agora temos que configurar para que o PIO permita que o TWIHS acesse os pinos, adicione as duas linhas de c\u00f3digo a seguir na fun\u00e7\u00e3o mcu6050_i2c_bus_init ioport_set_pin_peripheral_mode ( TWIHS0_DATA_GPIO , TWIHS0_DATA_FLAGS ); ioport_set_pin_peripheral_mode ( TWIHS0_CLK_GPIO , TWIHS0_CLK_FLAGS ); Exercise Chame a fun\u00e7\u00e3o mcu6050_i2c_bus_init na task_imu task_imu ( void * pvParameters ) { mcu6050_i2c_bus_init(); Biblioteca MCU6050 Para facilitar o controle da IMU iremos importar um arquivo mcu6050.h que possui dados extra\u00eddos do manual e que ir\u00e1 facilitar o acesso ao sensor: Exercise Inclua o arquivo mcu6050.h no projeto: Fa\u00e7a o download de muc6050.h para a pasta Downloads Arraste o arquivo para dentro do src/ Abra e de uma olhada no arquivo Lembre de incluir no main.c #include mcu6050.h Fun\u00e7\u00f5es auxiliares Iremos declarar duas fun\u00e7\u00f5es que ir\u00e3o facilitar a escrita e leitura do I2C: int8_t mcu6050_i2c_bus_write(uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint8_t cnt) int8_t mcu6050_i2c_bus_read(uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint8_t cnt) Onde: dev_addr : Endere\u00e7o do dispositivo que pretendemos manipular reg_addr : Endere\u00e7o do registrador que pretendemos escrever/ler reg_data : Vetor com os valores que ser\u00e3o escritos/lidos cnt : Quantidade de dados que ser\u00e3o escritos/lidos Exercise Declare as fun\u00e7\u00f5es a seguir no c\u00f3digo, lembre de fazer os prot\u00f3tipos das fun\u00e7\u00f5es para evitar erros de compila\u00e7\u00e3o. int8_t mcu6050_i2c_bus_write ( uint8_t dev_addr , uint8_t reg_addr , uint8_t * reg_data , uint8_t cnt ) { int32_t ierror = 0x00 ; twihs_packet_t p_packet ; p_packet . chip = dev_addr ; p_packet . addr [ 0 ] = reg_addr ; p_packet . addr_length = 1 ; p_packet . buffer = reg_data ; p_packet . length = cnt ; ierror = twihs_master_write ( TWIHS_MCU6050 , & p_packet ); return ( int8_t ) ierror ; } int8_t mcu6050_i2c_bus_read ( uint8_t dev_addr , uint8_t reg_addr , uint8_t * reg_data , uint8_t cnt ) { int32_t ierror = 0x00 ; twihs_packet_t p_packet ; p_packet . chip = dev_addr ; p_packet . addr [ 0 ] = reg_addr ; p_packet . addr_length = 1 ; p_packet . buffer = reg_data ; p_packet . length = cnt ; // TODO: Algum problema no SPI faz com que devemos ler duas vezes o registrador para // conseguirmos pegar o valor correto. ierror = twihs_master_read ( TWIHS_MCU6050 , & p_packet ); ierror = twihs_master_read ( TWIHS_MCU6050 , & p_packet ); return ( int8_t ) ierror ; } Para usar as fun\u00e7\u00f5es ser\u00e1 necess\u00e1rio utilizarmos dois buffers (um para recebimento e outro para envio de dados) al\u00e9m de uma vari\u00e1vel para armazenarmos o valor do retorno da fun\u00e7\u00e3o, que informa se o comando no i2c foi bem sucedido ou n\u00e3o. Exercise Declare os buffers a seguir na task_imu /* buffer para recebimento de dados */ uint8_t bufferRX [ 10 ]; uint8_t bufferTX [ 10 ]; /* resultado da fun\u00e7\u00e3o */ uint8_t rtn ; Lendo ID sensor A maioria dos m\u00f3dulos que operam por algum tipo de comunica\u00e7\u00e3o (uart, i2c, spi) possuem um registrador que tem um ID \u00fanico que referencia o m\u00f3dulo, a ideia deste registrador \u00e9 a de: Confirmar que a comunica\u00e7\u00e3o i2c est\u00e1 funcionando Garantir que o controlador est\u00e1 acessando o perif\u00e9rico certo Exercise Acesse o documento que descreve os registradores do IMU e procure pelo endere\u00e7o do registrador WHO_AM_I , e responda: Qual endere\u00e7o deve ser lido Qual valor esperado da leitura Answer Endere\u00e7o: x75 Valor: 110 100 bits[6..1] Para facilitar a nossa vida, importamos o arquivo mcu6050.h no nosso projeto, se derem uma olhada nele v\u00e3o encontrar as seguintes informa\u00e7\u00f5es: #define MPU6050_ADDRESS_AD0_LOW 0x68 // address pin low (GND), default for InvenSense evaluation board #define MPU6050_DEFAULT_ADDRESS MPU6050_ADDRESS_AD0_LOW ... #define MPU6050_RA_WHO_AM_I 0x75 Com isso conseguirmos usar a fun\u00e7\u00e3o que realiza uma leitura no I2C ( mcu6050_i2c_bus_read ) e validar a comunica\u00e7\u00e3o. Exercise Na task_imu fa\u00e7a a leitura do registrador WHO_AM_I : // L\u00ea registrador WHO AM I rtn = mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_WHO_AM_I , bufferRX , 1 ); if ( rtn != TWIHS_SUCCESS ){ printf ( \"[ERRO] [i2c] [read] \\n \" ); } else { printf ( \"[DADO] [i2c] %x:%x\" , MPU6050_RA_WHO_AM_I , bufferRX [ 0 ]); } while ( 1 ) { } Vamos analisar os par\u00e2metros do comando anterior: MPU6050_DEFAULT_ADDRESS : Endere\u00e7o do IMU no i2c MPU6050_RA_WHO_AM_I : Endere\u00e7o do registrador WHO_AM_I bufferRX : Buffer para armazenar o resultado da leitura 1 : Quantidade de bytes a serem lido no I2C Exercise Execute o c\u00f3digo e no terminal analise o resultado da leitura i2c. Se obter a sa\u00edda [ERRO], an\u00e1lise novamente a conex\u00e3o da placa e o c\u00f3digo Com a leitura realizada, agora temos que analisar o conte\u00fado do buffer RX e verificar se estamos lendo a coisa certa. Exercise Escreva um c\u00f3digo que verifica o conte\u00fado do bufferRX e verifica se o valor lido \u00e9 o correto (dado extra\u00eddo do manual). Se for incorreto, exiba uma msg de erro Se for correto, exiba uma msg de sucesso Configurando IMU e lendo informa\u00e7\u00f5es Agora temos que configurar a IMU para fornecer as informa\u00e7\u00f5es necess\u00e1rias: Girosc\u00f3pio e Aceler\u00f4metro , isso tudo est\u00e1 na documenta\u00e7\u00e3o do sensor. O c\u00f3digo configura o aceler\u00f4metro para operar com escala m\u00e1xima de 2G (o que \u00e9 ok para nossa aplica\u00e7\u00e3o, mas se estivessem desenvolvendo alguma aplica\u00e7\u00e3o para uma montanha russa, um carro ou um m\u00edssil poderia n\u00e3o funcionar.), mas tamb\u00e9m poderiamos escolher entre: \u00b1 2G, \u00b1 4G, \u00b1 8G e \u00b1 16G . Tip Ler a documenta\u00e7\u00e3o pode ser muito dif\u00edcil e trabalhoso, uma outra op\u00e7\u00e3o \u00e9 a de ver como outras pessoas usam o sensor, e uma boa referencia s\u00e3o c\u00f3digos de arduino ou bibliotecas de fabricantes de placa de desenvolvimento. Exercise Inclua o c\u00f3digo a seguir na task_imu ainda fora do while , mas apenas depois de ter validado a comunicac\u00e3o com o sensor: // Set Clock source bufferTX [ 0 ] = MPU6050_CLOCK_PLL_XGYRO ; rtn = mcu6050_i2c_bus_write ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_PWR_MGMT_1 , bufferTX , 1 ); if ( rtn != TWIHS_SUCCESS ) printf ( \"[ERRO] [i2c] [write] \\n \" ); // Aceletromtro em 2G bufferTX [ 0 ] = MPU6050_ACCEL_FS_2 << MPU6050_ACONFIG_AFS_SEL_BIT ; rtn = mcu6050_i2c_bus_write ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_CONFIG , bufferTX , 1 ); if ( rtn != TWIHS_SUCCESS ) printf ( \"[ERRO] [i2c] [write] \\n \" ); // Configura range giroscopio para operar com 250 \u00b0/s bufferTX [ 0 ] = 0x00 ; // 250 \u00b0/s rtn = mcu6050_i2c_bus_write ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_CONFIG , bufferTX , 1 ); if ( rtn != TWIHS_SUCCESS ) printf ( \"[ERRO] [i2c] [write] \\n \" ); while ( 1 ) { } Agora com tudo configurado podemos fazer a leitura do sensor (aceler\u00f4metro e imu): Exercise Declare as seguintes vari\u00e1veis na task_imu : int16_t raw_acc_x , raw_acc_y , raw_acc_z ; volatile uint8_t raw_acc_xHigh , raw_acc_yHigh , raw_acc_zHigh ; volatile uint8_t raw_acc_xLow , raw_acc_yLow , raw_acc_zLow ; float proc_acc_x , proc_acc_y , proc_acc_z ; int16_t raw_gyr_x , raw_gyr_y , raw_gyr_z ; volatile uint8_t raw_gyr_xHigh , raw_gyr_yHigh , raw_gyr_zHigh ; volatile uint8_t raw_gyr_xLow , raw_gyr_yLow , raw_gyr_zLow ; float proc_gyr_x , proc_gyr_y , proc_gyr_z ; Exercise Inclua o c\u00f3digo a seguir no while while ( 1 ) { // Le valor do acc X High e Low mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_XOUT_H , & raw_acc_xHigh , 1 ); mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_XOUT_L , & raw_acc_xLow , 1 ); // Le valor do acc y High e Low mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_YOUT_H , & raw_acc_yHigh , 1 ); mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_ZOUT_L , & raw_acc_yLow , 1 ); // Le valor do acc z HIGH e Low mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_ZOUT_H , & raw_acc_zHigh , 1 ); mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_ZOUT_L , & raw_acc_zLow , 1 ); // Dados s\u00e3o do tipo complemento de dois raw_acc_x = ( raw_acc_xHigh << 8 ) | ( raw_acc_xLow << 0 ); raw_acc_y = ( raw_acc_yHigh << 8 ) | ( raw_acc_yLow << 0 ); raw_acc_z = ( raw_acc_zHigh << 8 ) | ( raw_acc_zLow << 0 ); // Le valor do gyr X High e Low mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_XOUT_H , & raw_gyr_xHigh , 1 ); mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_XOUT_L , & raw_gyr_xLow , 1 ); // Le valor do gyr y High e Low mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_YOUT_H , & raw_gyr_yHigh , 1 ); mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_ZOUT_L , & raw_gyr_yLow , 1 ); // Le valor do gyr z HIGH e Low mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_ZOUT_H , & raw_gyr_zHigh , 1 ); mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_ZOUT_L , & raw_gyr_zLow , 1 ); // Dados s\u00e3o do tipo complemento de dois raw_gyr_x = ( raw_gyr_xHigh << 8 ) | ( raw_gyr_xLow << 0 ); raw_gyr_y = ( raw_gyr_yHigh << 8 ) | ( raw_gyr_yLow << 0 ); raw_gyr_z = ( raw_gyr_zHigh << 8 ) | ( raw_gyr_zLow << 0 ); // Dados em escala real proc_acc_x = ( float ) raw_acc_x / 16384 ; proc_acc_y = ( float ) raw_acc_y / 16384 ; proc_acc_z = ( float ) raw_acc_z / 16384 ; proc_gyr_x = ( float ) raw_gyr_x / 131 ; proc_gyr_y = ( float ) raw_gyr_y / 131 ; proc_gyr_z = ( float ) raw_gyr_z / 131 ; // uma amostra a cada 1ms vTaskDelay ( 1 ); } Exercise Voc\u00ea sabia que no nosso terminal n\u00e3o conseguimos imprimir n\u00fameros floats por padr\u00e3o? Mas da para habilitar: https://insper.github.io/ComputacaoEmbarcada/navigation/Dicas/Util-FloatPrint/ HABILITE Exercise S\u00f3 funciona se habilitar a impress\u00e3o de float Imprima os valores da acelera\u00e7\u00e3o ( proc_acc_ ) e girosc\u00f3pio ( proc_gyr_ ). Execute o c\u00f3digo na placa Movimente a placa, os valores mudam? da para entender alguma coisa? Incline a placa, o valor do acc muda? Trabalhando com os dados Legal, teoricamente agora temos tudo pronto e funcionado. Mas como usar esses dados para fazer alguma coisa \u00fatil? Conseguimos estimar a orienta\u00e7\u00e3o da placa no espa\u00e7o? Para isso existem algor\u00edtimos de processamento de sinais, isso foi uma \u00e1rea muito f\u00e9rtil em meados de 2010, quando este tipo de sensor se popularizou, e agora tem ganhado mais estudos sendo utilizado com redes neurais. Exercise Detectando queda Crie uma tarefa task_house_down que possui um sem\u00e1foro, e que quando liberado a task pisca o led da placa Utilizando os dados do aceler\u00f4metro, libere o sem\u00e1foro quando uma queda for detectada. Dica: A IMU sempre mede o valor da gravidade, em uma queda esse valor deve se aproximar de zero (queda anula a gravidade) Voc\u00ea pode calcular o m\u00f3dulo de todos os eixos e verificar a condi\u00e7\u00e3o. Fus\u00e3o de dados Agora vamos fazer algo mais valioso, que inclui realizarmos uma fus\u00e3o de dados e obter a orienta\u00e7\u00e3o no espa\u00e7o 3D do aceler\u00f4metro, para isso iremos utilizar uma biblioteca em C desenvolvida pela https://x-io.co.uk/ chamada de FUSION : https://github.com/xioTechnologies/Fusion A biblioteca implementa o filtro de orienta\u00e7\u00e3o chamado Madgwick , notem que a nossa IMU n\u00e3o possui magnet\u00f4metro, isso atrapalha um pouco a corre\u00e7\u00e3o do girosc\u00f3pio que possui drift no tempo. Tip Existem diversos algoritmos diferentes que fazem isso, se quiserem se aprofundar eu indico a eletiva de Drones do F\u00e1bio Bobrow que trabalha mais a fundo com isso. Exercise Fa\u00e7a o download da \u00faltima vers\u00e3o da biblioteca: https://github.com/xioTechnologies/Fusion/tags Extra\u00eda a pasta Inclua no projeto a pasta Fusion-1.0.6/Fusion (arrastando para dentro da solu\u00e7\u00e3o src/ ) Exercise Inclua o Fusion.h no main : #include \"Fusion/Fusion.h\" E na main antes do loop inicialize a biblioteca de fus\u00e3o: /* Inicializa Fun\u00e7\u00e3o de fus\u00e3o */ FusionAhrs ahrs ; FusionAhrsInitialise ( & ahrs ); Agora que j\u00e1 temos a biblioteca no nosso projeto, temos que preparar o dados para utilizarmos nela. Exercise Adicione o c\u00f3digo a seguir no final da fun\u00e7\u00e3o loop : const FusionVector gyroscope = { proc_gyr_x , proc_gyr_y , proc_gyr_z }; const FusionVector accelerometer = { proc_acc_x , proc_acc_y , proc_acc_z }; Exercise Agora podemos realizar o processamento e obter a orienta\u00e7\u00e3o: // Tempo entre amostras float dT = 0.1 // aplica o algoritmo FusionAhrsUpdateNoMagnetometer ( & ahrs , gyroscope , accelerometer , dT ); // dados em pitch roll e yaw const FusionEuler euler = FusionQuaternionToEuler ( FusionAhrsGetQuaternion ( & ahrs )); printf ( \"Roll %0.1f, Pitch %0.1f, Yaw %0.1f \\n \" , euler . angle . roll , euler . angle . pitch , euler . angle . yaw ); Exercise O que \u00e9 roll, pitch e yaw? Answer Exercise Execute o c\u00f3digo Abra o terminal e analise o resultado Trabalhando com os dados - parte 2 Vamos detectar para onde o sistema est\u00e1 apontando, a ideia \u00e9 acender os LEDs da placa OLED da seguinte maneira: LED1: Apontando para esquerda LED2: Apontando para frente LED3: Apontando para direita Exercise Crie um enum chamado orientacao com os seguintes itens: ESQUERDA, FRENTE, DIREITA Crie uma task ( task_orientacao ) que possui uma fila e que recebe um dado do tipo orientacao e que dependendo do valor recebido, acende o LED conforme descri\u00e7\u00e3o anterior. Na task da IMU, detecta a orienta\u00e7\u00e3o e envie o dado para a fila. A refer\u00eancia da orienta\u00e7\u00e3o \u00e9 a posi\u00e7\u00e3o de quando a placa liga!","title":"Lab 6 - RTOS IMU"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#lab-rtos-imu","text":"Pasta Lab6-RTOS-IMU Neste laborat\u00f3rio iremos realizar uma comunica\u00e7\u00e3o I2C com um sensor inercial, e aplicar um processamento de fus\u00e3o de dados para obtermos a localiza\u00e7\u00e3o no espa\u00e7o do sensor. Info Usar como base o c\u00f3digo do OLED com RTOS.","title":"LAB - RTOS - IMU"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#teoria","text":"I2C ( eye-squared-C ) \u00e9 um protocolo de comunica\u00e7\u00e3o do tipo Machine-to-machine muito utilizado para comunica\u00e7\u00e3o entre microcontrolador e um dispositivo (sensor ou atuador) externo, criado pela Philips Semiconductor em 1982 e liberado para uso sem licen\u00e7a em 2006 . O i2c \u00e9 uma comunica\u00e7\u00e3o s\u00edncrona e utiliza duas vias: serial data line (SDA) e serial clock line (SCL), a comunica\u00e7\u00e3o \u00e9 sempre inicializada pelo Controlador (o microcontrolador) e respondida pelo Target (componente). A imagem a seguir \u00e9 um exemplo de como utilizar o i2c para conectar m\u00faltiplos dispositivos em um controlador: Tip Cuidado, usaremos o termo perif\u00e9rico n\u00e3o s\u00f3 para referenciar os componentes do microcontrolador, da placa, mas agora tamb\u00e9m novos componentes plugados no kit. Existem no mercado v\u00e1rios sensores que possuem comunica\u00e7\u00e3o i2c, no lab temos v\u00e1rios: IMU C\u00e2mera temperatura press\u00e3o batimento card\u00edaco D\u00ea uma olhada nos sensores da adafruit i2c: https://www.adafruit.com/?q=i2c+sensor&sort=BestMatch","title":"Teoria"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#protocolo","text":"Info Apenas uma breve apresenta\u00e7\u00e3o, o I2C \u00e9 um protocolo mais complicado do que aparenta ser: https://learn.sparkfun.com/tutorials/i2c/all https://www.i2c-bus.org/i2c-primer/common-problems/ A comunicac\u00e3o i2c faz uso de dois sinais: clk e data, o clock \u00e9 sempre gerado pelo controlador, diferente da UART (a de camada f\u00edsica, e a que usamos para o m\u00f3dulo bluetooth) o i2c usa um tipo de sinal chamado de open drain , que significa que o sinal na linha \u00e9 sempre positivo ( vcc ) e os dispositivos quando querem enviar o valor zero, apenas aterram a linha, notem que para isso \u00e9 necess\u00e1rio um pull-up na linha. Info A ideia do dreno aberto \u00e9 permitir que mais de um dispositivo controle a linha, como o controle \u00e9 apenas aterrando o sinal, n\u00e3o h\u00e1 risco de queimar o pino. O protocolo do I2C \u00e9 mais complexo que a da UART (o de camada f\u00edsica, e o usado para comunica\u00e7\u00e3o com o m\u00f3dulo bluetooth), no I2C cada dispositivo possui um endere\u00e7o que deve ser enviado no come\u00e7o da comunica\u00e7\u00e3o, a cada envio de dado pelo controlador, o dispositivo responde com um sinal de ACK (um bit no final do pacote). O controlador pode executar duas tarefas diferente: Requisitar um dado Enviar um dado As tarefas s\u00e3o definidas pelo \u00faltimo bit no pacote de endere\u00e7o. Info O envio de dado pode ser utilizado para a configura\u00e7\u00e3o de um sensor, uma vez configurado, podemos requisitar dados. Ap\u00f3s o envio do endere\u00e7o, o controlador come\u00e7a enviar o pacote de dados, o envio s\u00f3 termina quando um STOP \u00e9 enviado. A seguir uma vis\u00e3o geral bem simplificada da comunica\u00e7\u00e3o Informa\u00e7\u00f5es importantes: O i2c pode operar com pacotes de 8 ou 10 bits O controlador deve enviar o endere\u00e7o do perif\u00e9rico no in\u00edcio da comunica\u00e7\u00e3o O controlador deve definir se ir\u00e1 ler ou escrever no perif\u00e9rico (W/R) Tanto na leitura quanto na escrita quem gera o clock \u00e9 o controlador Ao final de cada pacote um ACK deve ser gerado Uma comunica\u00e7\u00e3o pode transmitir um ou mais pacotes O fim de uma comunica\u00e7\u00e3o \u00e9 definido pelo STOP bit","title":"Protocolo"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#two-wire-interface-twihs","text":"O nosso microcontrolador possui um perif\u00e9rico chamado de TWIHS que implementa a comunica\u00e7\u00e3o i2c, notem que o perif\u00e9rico precisa controlar os pinos do PIO (para gerar o clock, escrever no pino, ler um valor), o diagrama extra\u00eddo do manual mostra como o perif\u00e9rico interfaceia com o PIO: No nosso uC possu\u00edmos um total de 3 TWIHS e cada um possui pino do PIO pr\u00e9 definido: Warning Na placa que utilizamos (SAME70-XPLD), nem todos os pinos do uC que tem acesso ao per\u00edfico TWIHS est\u00e3o dispon\u00edveis. Na coluna XPLD-CONN da tabela acima est\u00e1 indicado quais e onde os pinos est\u00e3o dispon\u00edveis.","title":"Two-wire Interface (TWIHS)"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#mpu-6050","text":"Todo Arnaldo (um par\u00e1grafo por item) o que \u00e9 IMU e como ela funciona a onde \u00e9 usado MEMS Explicar um pouco o sensor accelerometro e para que serve imu e para que serve bussola e para que serve talvez uma ou duas perguntas para eles terem que abrir o manual e buscar informacoes. fus\u00e3o de dados?","title":"MPU-6050"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#modulo-gy-521","text":"Para termos acesso ao MPU6050 iremos usar um m\u00f3dulo GY-521, no Brasil \u00e9 poss\u00edvel achar por R$25 . Um m\u00f3dulo com maior precis\u00e3o pode ser comprado e importado pela sparkfun : \"Our breakout board for the MPU-6050 makes this tiny QFN package easy to work into your project. Every pin you need to get up and running is broken out to 0.1\" headers, including the auxiliary master I2C bus which allows the MPU-6050 to access external magnetometers and other sensors.\"","title":"M\u00f3dulo GY-521"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#lab","text":"Agora que j\u00e1 vimos um pouco sobre o I2C e sobre o chip que iremos interagir, podemos come\u00e7ar o lab. Lab usar apenas printf conectar sensor placa i2c wizard configurar pio mux configurar TWIHS ler manual do MPU6050 e achar endere\u00e7o I2C usar valor para ler MPU6050_RA_WHO_AM_I explicar dar c\u00f3digo pronto que configura e l\u00ea giro e accel importar c\u00f3digo fus\u00e3o de dados implementar fus\u00e3o de dados manual: https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf","title":"LAB"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#task-imu","text":"Vamos criar uma task para realizar a leitura da IMU. Exercise Crie uma task chamada de task_imu , lembre de: Inicializar na main Task devem possuir while(1) e nunca retornar","title":"task imu"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#twihs","text":"Para fazermos uso perif\u00e9rico TWIHS ser\u00e1 necess\u00e1rio adicionarmos ele no asf wizard: Exercise Adicione o TWIHS no ASF Wizard Com a biblioteca adicionada agora devemos criar uma fun\u00e7\u00e3o para configurar o perif\u00e9rico: Ativar o clock do PMC Operar como controlador Definir a frequ\u00eancia de opera\u00e7\u00e3o Permitir que o TWIHS controle os pinos do PIO Exercise Adicione a fun\u00e7\u00e3o a seguir no c\u00f3digo: void mcu6050_i2c_bus_init ( void ) { twihs_options_t mcu6050_option ; pmc_enable_periph_clk ( TWIHS_MCU6050_ID ); /* Configure the options of TWI driver */ mcu6050_option . master_clk = sysclk_get_cpu_hz (); mcu6050_option . speed = 40000 ; twihs_master_init ( TWIHS_MCU6050 , & mcu6050_option ); } Exercise Agora temos que configurar para que o PIO permita que o TWIHS acesse os pinos, adicione as duas linhas de c\u00f3digo a seguir na fun\u00e7\u00e3o mcu6050_i2c_bus_init ioport_set_pin_peripheral_mode ( TWIHS0_DATA_GPIO , TWIHS0_DATA_FLAGS ); ioport_set_pin_peripheral_mode ( TWIHS0_CLK_GPIO , TWIHS0_CLK_FLAGS ); Exercise Chame a fun\u00e7\u00e3o mcu6050_i2c_bus_init na task_imu task_imu ( void * pvParameters ) { mcu6050_i2c_bus_init();","title":"TWIHS"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#biblioteca-mcu6050","text":"Para facilitar o controle da IMU iremos importar um arquivo mcu6050.h que possui dados extra\u00eddos do manual e que ir\u00e1 facilitar o acesso ao sensor: Exercise Inclua o arquivo mcu6050.h no projeto: Fa\u00e7a o download de muc6050.h para a pasta Downloads Arraste o arquivo para dentro do src/ Abra e de uma olhada no arquivo Lembre de incluir no main.c #include mcu6050.h","title":"Biblioteca MCU6050"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#funcoes-auxiliares","text":"Iremos declarar duas fun\u00e7\u00f5es que ir\u00e3o facilitar a escrita e leitura do I2C: int8_t mcu6050_i2c_bus_write(uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint8_t cnt) int8_t mcu6050_i2c_bus_read(uint8_t dev_addr, uint8_t reg_addr, uint8_t *reg_data, uint8_t cnt) Onde: dev_addr : Endere\u00e7o do dispositivo que pretendemos manipular reg_addr : Endere\u00e7o do registrador que pretendemos escrever/ler reg_data : Vetor com os valores que ser\u00e3o escritos/lidos cnt : Quantidade de dados que ser\u00e3o escritos/lidos Exercise Declare as fun\u00e7\u00f5es a seguir no c\u00f3digo, lembre de fazer os prot\u00f3tipos das fun\u00e7\u00f5es para evitar erros de compila\u00e7\u00e3o. int8_t mcu6050_i2c_bus_write ( uint8_t dev_addr , uint8_t reg_addr , uint8_t * reg_data , uint8_t cnt ) { int32_t ierror = 0x00 ; twihs_packet_t p_packet ; p_packet . chip = dev_addr ; p_packet . addr [ 0 ] = reg_addr ; p_packet . addr_length = 1 ; p_packet . buffer = reg_data ; p_packet . length = cnt ; ierror = twihs_master_write ( TWIHS_MCU6050 , & p_packet ); return ( int8_t ) ierror ; } int8_t mcu6050_i2c_bus_read ( uint8_t dev_addr , uint8_t reg_addr , uint8_t * reg_data , uint8_t cnt ) { int32_t ierror = 0x00 ; twihs_packet_t p_packet ; p_packet . chip = dev_addr ; p_packet . addr [ 0 ] = reg_addr ; p_packet . addr_length = 1 ; p_packet . buffer = reg_data ; p_packet . length = cnt ; // TODO: Algum problema no SPI faz com que devemos ler duas vezes o registrador para // conseguirmos pegar o valor correto. ierror = twihs_master_read ( TWIHS_MCU6050 , & p_packet ); ierror = twihs_master_read ( TWIHS_MCU6050 , & p_packet ); return ( int8_t ) ierror ; } Para usar as fun\u00e7\u00f5es ser\u00e1 necess\u00e1rio utilizarmos dois buffers (um para recebimento e outro para envio de dados) al\u00e9m de uma vari\u00e1vel para armazenarmos o valor do retorno da fun\u00e7\u00e3o, que informa se o comando no i2c foi bem sucedido ou n\u00e3o. Exercise Declare os buffers a seguir na task_imu /* buffer para recebimento de dados */ uint8_t bufferRX [ 10 ]; uint8_t bufferTX [ 10 ]; /* resultado da fun\u00e7\u00e3o */ uint8_t rtn ;","title":"Fun\u00e7\u00f5es auxiliares"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#lendo-id-sensor","text":"A maioria dos m\u00f3dulos que operam por algum tipo de comunica\u00e7\u00e3o (uart, i2c, spi) possuem um registrador que tem um ID \u00fanico que referencia o m\u00f3dulo, a ideia deste registrador \u00e9 a de: Confirmar que a comunica\u00e7\u00e3o i2c est\u00e1 funcionando Garantir que o controlador est\u00e1 acessando o perif\u00e9rico certo Exercise Acesse o documento que descreve os registradores do IMU e procure pelo endere\u00e7o do registrador WHO_AM_I , e responda: Qual endere\u00e7o deve ser lido Qual valor esperado da leitura Answer Endere\u00e7o: x75 Valor: 110 100 bits[6..1] Para facilitar a nossa vida, importamos o arquivo mcu6050.h no nosso projeto, se derem uma olhada nele v\u00e3o encontrar as seguintes informa\u00e7\u00f5es: #define MPU6050_ADDRESS_AD0_LOW 0x68 // address pin low (GND), default for InvenSense evaluation board #define MPU6050_DEFAULT_ADDRESS MPU6050_ADDRESS_AD0_LOW ... #define MPU6050_RA_WHO_AM_I 0x75 Com isso conseguirmos usar a fun\u00e7\u00e3o que realiza uma leitura no I2C ( mcu6050_i2c_bus_read ) e validar a comunica\u00e7\u00e3o. Exercise Na task_imu fa\u00e7a a leitura do registrador WHO_AM_I : // L\u00ea registrador WHO AM I rtn = mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_WHO_AM_I , bufferRX , 1 ); if ( rtn != TWIHS_SUCCESS ){ printf ( \"[ERRO] [i2c] [read] \\n \" ); } else { printf ( \"[DADO] [i2c] %x:%x\" , MPU6050_RA_WHO_AM_I , bufferRX [ 0 ]); } while ( 1 ) { } Vamos analisar os par\u00e2metros do comando anterior: MPU6050_DEFAULT_ADDRESS : Endere\u00e7o do IMU no i2c MPU6050_RA_WHO_AM_I : Endere\u00e7o do registrador WHO_AM_I bufferRX : Buffer para armazenar o resultado da leitura 1 : Quantidade de bytes a serem lido no I2C Exercise Execute o c\u00f3digo e no terminal analise o resultado da leitura i2c. Se obter a sa\u00edda [ERRO], an\u00e1lise novamente a conex\u00e3o da placa e o c\u00f3digo Com a leitura realizada, agora temos que analisar o conte\u00fado do buffer RX e verificar se estamos lendo a coisa certa. Exercise Escreva um c\u00f3digo que verifica o conte\u00fado do bufferRX e verifica se o valor lido \u00e9 o correto (dado extra\u00eddo do manual). Se for incorreto, exiba uma msg de erro Se for correto, exiba uma msg de sucesso","title":"Lendo ID sensor"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#configurando-imu-e-lendo-informacoes","text":"Agora temos que configurar a IMU para fornecer as informa\u00e7\u00f5es necess\u00e1rias: Girosc\u00f3pio e Aceler\u00f4metro , isso tudo est\u00e1 na documenta\u00e7\u00e3o do sensor. O c\u00f3digo configura o aceler\u00f4metro para operar com escala m\u00e1xima de 2G (o que \u00e9 ok para nossa aplica\u00e7\u00e3o, mas se estivessem desenvolvendo alguma aplica\u00e7\u00e3o para uma montanha russa, um carro ou um m\u00edssil poderia n\u00e3o funcionar.), mas tamb\u00e9m poderiamos escolher entre: \u00b1 2G, \u00b1 4G, \u00b1 8G e \u00b1 16G . Tip Ler a documenta\u00e7\u00e3o pode ser muito dif\u00edcil e trabalhoso, uma outra op\u00e7\u00e3o \u00e9 a de ver como outras pessoas usam o sensor, e uma boa referencia s\u00e3o c\u00f3digos de arduino ou bibliotecas de fabricantes de placa de desenvolvimento. Exercise Inclua o c\u00f3digo a seguir na task_imu ainda fora do while , mas apenas depois de ter validado a comunicac\u00e3o com o sensor: // Set Clock source bufferTX [ 0 ] = MPU6050_CLOCK_PLL_XGYRO ; rtn = mcu6050_i2c_bus_write ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_PWR_MGMT_1 , bufferTX , 1 ); if ( rtn != TWIHS_SUCCESS ) printf ( \"[ERRO] [i2c] [write] \\n \" ); // Aceletromtro em 2G bufferTX [ 0 ] = MPU6050_ACCEL_FS_2 << MPU6050_ACONFIG_AFS_SEL_BIT ; rtn = mcu6050_i2c_bus_write ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_CONFIG , bufferTX , 1 ); if ( rtn != TWIHS_SUCCESS ) printf ( \"[ERRO] [i2c] [write] \\n \" ); // Configura range giroscopio para operar com 250 \u00b0/s bufferTX [ 0 ] = 0x00 ; // 250 \u00b0/s rtn = mcu6050_i2c_bus_write ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_CONFIG , bufferTX , 1 ); if ( rtn != TWIHS_SUCCESS ) printf ( \"[ERRO] [i2c] [write] \\n \" ); while ( 1 ) { } Agora com tudo configurado podemos fazer a leitura do sensor (aceler\u00f4metro e imu): Exercise Declare as seguintes vari\u00e1veis na task_imu : int16_t raw_acc_x , raw_acc_y , raw_acc_z ; volatile uint8_t raw_acc_xHigh , raw_acc_yHigh , raw_acc_zHigh ; volatile uint8_t raw_acc_xLow , raw_acc_yLow , raw_acc_zLow ; float proc_acc_x , proc_acc_y , proc_acc_z ; int16_t raw_gyr_x , raw_gyr_y , raw_gyr_z ; volatile uint8_t raw_gyr_xHigh , raw_gyr_yHigh , raw_gyr_zHigh ; volatile uint8_t raw_gyr_xLow , raw_gyr_yLow , raw_gyr_zLow ; float proc_gyr_x , proc_gyr_y , proc_gyr_z ; Exercise Inclua o c\u00f3digo a seguir no while while ( 1 ) { // Le valor do acc X High e Low mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_XOUT_H , & raw_acc_xHigh , 1 ); mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_XOUT_L , & raw_acc_xLow , 1 ); // Le valor do acc y High e Low mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_YOUT_H , & raw_acc_yHigh , 1 ); mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_ZOUT_L , & raw_acc_yLow , 1 ); // Le valor do acc z HIGH e Low mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_ZOUT_H , & raw_acc_zHigh , 1 ); mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_ACCEL_ZOUT_L , & raw_acc_zLow , 1 ); // Dados s\u00e3o do tipo complemento de dois raw_acc_x = ( raw_acc_xHigh << 8 ) | ( raw_acc_xLow << 0 ); raw_acc_y = ( raw_acc_yHigh << 8 ) | ( raw_acc_yLow << 0 ); raw_acc_z = ( raw_acc_zHigh << 8 ) | ( raw_acc_zLow << 0 ); // Le valor do gyr X High e Low mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_XOUT_H , & raw_gyr_xHigh , 1 ); mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_XOUT_L , & raw_gyr_xLow , 1 ); // Le valor do gyr y High e Low mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_YOUT_H , & raw_gyr_yHigh , 1 ); mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_ZOUT_L , & raw_gyr_yLow , 1 ); // Le valor do gyr z HIGH e Low mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_ZOUT_H , & raw_gyr_zHigh , 1 ); mcu6050_i2c_bus_read ( MPU6050_DEFAULT_ADDRESS , MPU6050_RA_GYRO_ZOUT_L , & raw_gyr_zLow , 1 ); // Dados s\u00e3o do tipo complemento de dois raw_gyr_x = ( raw_gyr_xHigh << 8 ) | ( raw_gyr_xLow << 0 ); raw_gyr_y = ( raw_gyr_yHigh << 8 ) | ( raw_gyr_yLow << 0 ); raw_gyr_z = ( raw_gyr_zHigh << 8 ) | ( raw_gyr_zLow << 0 ); // Dados em escala real proc_acc_x = ( float ) raw_acc_x / 16384 ; proc_acc_y = ( float ) raw_acc_y / 16384 ; proc_acc_z = ( float ) raw_acc_z / 16384 ; proc_gyr_x = ( float ) raw_gyr_x / 131 ; proc_gyr_y = ( float ) raw_gyr_y / 131 ; proc_gyr_z = ( float ) raw_gyr_z / 131 ; // uma amostra a cada 1ms vTaskDelay ( 1 ); } Exercise Voc\u00ea sabia que no nosso terminal n\u00e3o conseguimos imprimir n\u00fameros floats por padr\u00e3o? Mas da para habilitar: https://insper.github.io/ComputacaoEmbarcada/navigation/Dicas/Util-FloatPrint/ HABILITE Exercise S\u00f3 funciona se habilitar a impress\u00e3o de float Imprima os valores da acelera\u00e7\u00e3o ( proc_acc_ ) e girosc\u00f3pio ( proc_gyr_ ). Execute o c\u00f3digo na placa Movimente a placa, os valores mudam? da para entender alguma coisa? Incline a placa, o valor do acc muda?","title":"Configurando IMU e lendo informa\u00e7\u00f5es"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#trabalhando-com-os-dados","text":"Legal, teoricamente agora temos tudo pronto e funcionado. Mas como usar esses dados para fazer alguma coisa \u00fatil? Conseguimos estimar a orienta\u00e7\u00e3o da placa no espa\u00e7o? Para isso existem algor\u00edtimos de processamento de sinais, isso foi uma \u00e1rea muito f\u00e9rtil em meados de 2010, quando este tipo de sensor se popularizou, e agora tem ganhado mais estudos sendo utilizado com redes neurais. Exercise Detectando queda Crie uma tarefa task_house_down que possui um sem\u00e1foro, e que quando liberado a task pisca o led da placa Utilizando os dados do aceler\u00f4metro, libere o sem\u00e1foro quando uma queda for detectada. Dica: A IMU sempre mede o valor da gravidade, em uma queda esse valor deve se aproximar de zero (queda anula a gravidade) Voc\u00ea pode calcular o m\u00f3dulo de todos os eixos e verificar a condi\u00e7\u00e3o.","title":"Trabalhando com os dados"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#fusao-de-dados","text":"Agora vamos fazer algo mais valioso, que inclui realizarmos uma fus\u00e3o de dados e obter a orienta\u00e7\u00e3o no espa\u00e7o 3D do aceler\u00f4metro, para isso iremos utilizar uma biblioteca em C desenvolvida pela https://x-io.co.uk/ chamada de FUSION : https://github.com/xioTechnologies/Fusion A biblioteca implementa o filtro de orienta\u00e7\u00e3o chamado Madgwick , notem que a nossa IMU n\u00e3o possui magnet\u00f4metro, isso atrapalha um pouco a corre\u00e7\u00e3o do girosc\u00f3pio que possui drift no tempo. Tip Existem diversos algoritmos diferentes que fazem isso, se quiserem se aprofundar eu indico a eletiva de Drones do F\u00e1bio Bobrow que trabalha mais a fundo com isso. Exercise Fa\u00e7a o download da \u00faltima vers\u00e3o da biblioteca: https://github.com/xioTechnologies/Fusion/tags Extra\u00eda a pasta Inclua no projeto a pasta Fusion-1.0.6/Fusion (arrastando para dentro da solu\u00e7\u00e3o src/ ) Exercise Inclua o Fusion.h no main : #include \"Fusion/Fusion.h\" E na main antes do loop inicialize a biblioteca de fus\u00e3o: /* Inicializa Fun\u00e7\u00e3o de fus\u00e3o */ FusionAhrs ahrs ; FusionAhrsInitialise ( & ahrs ); Agora que j\u00e1 temos a biblioteca no nosso projeto, temos que preparar o dados para utilizarmos nela. Exercise Adicione o c\u00f3digo a seguir no final da fun\u00e7\u00e3o loop : const FusionVector gyroscope = { proc_gyr_x , proc_gyr_y , proc_gyr_z }; const FusionVector accelerometer = { proc_acc_x , proc_acc_y , proc_acc_z }; Exercise Agora podemos realizar o processamento e obter a orienta\u00e7\u00e3o: // Tempo entre amostras float dT = 0.1 // aplica o algoritmo FusionAhrsUpdateNoMagnetometer ( & ahrs , gyroscope , accelerometer , dT ); // dados em pitch roll e yaw const FusionEuler euler = FusionQuaternionToEuler ( FusionAhrsGetQuaternion ( & ahrs )); printf ( \"Roll %0.1f, Pitch %0.1f, Yaw %0.1f \\n \" , euler . angle . roll , euler . angle . pitch , euler . angle . yaw ); Exercise O que \u00e9 roll, pitch e yaw? Answer Exercise Execute o c\u00f3digo Abra o terminal e analise o resultado","title":"Fus\u00e3o de dados"},{"location":"navigation/Labs/Lab_RTOS_imu/lab/#trabalhando-com-os-dados-parte-2","text":"Vamos detectar para onde o sistema est\u00e1 apontando, a ideia \u00e9 acender os LEDs da placa OLED da seguinte maneira: LED1: Apontando para esquerda LED2: Apontando para frente LED3: Apontando para direita Exercise Crie um enum chamado orientacao com os seguintes itens: ESQUERDA, FRENTE, DIREITA Crie uma task ( task_orientacao ) que possui uma fila e que recebe um dado do tipo orientacao e que dependendo do valor recebido, acende o LED conforme descri\u00e7\u00e3o anterior. Na task da IMU, detecta a orienta\u00e7\u00e3o e envie o dado para a fila. A refer\u00eancia da orienta\u00e7\u00e3o \u00e9 a posi\u00e7\u00e3o de quando a placa liga!","title":"Trabalhando com os dados - parte 2"},{"location":"navigation/Labs/Lab_TC_RTC_RTT/Lab-TC-RTC-RTT-Perguntas/","text":"Diagrama Com o intuito de clarificar o entendimento da interrup\u00e7\u00e3o e dos perif\u00e9ricos recentemente vistos (TC e RTC), fa\u00e7a um diagrama de blocos que contenha toda a informa\u00e7\u00e3o necess\u00e1ria para o entedimento da entrega Tick Tack . Esse diagrama deve conter ao menos os seguintes itens: Perif\u00e9ricos utilizados Interface dos perif\u00e9ricos com o CORE Pinos utilizados e como est\u00e3o conectados nos perif\u00e9ricos Numerar os pinos de cada LED (ex. PA8, PB12, ...). Deve ficar claro o que \u00e9 : uC Kit de desenvolvimento M\u00f3dulo OLED1 Deve-se ilustra as interfaces de interrup\u00e7\u00e3o entre os perif\u00e9ricos e o Core Informar os valores (ID_TC0, ID_TC1) de cada interrup\u00e7\u00e3o Pesquisa (m\u00ednimo dois itens da lista) Explique o funcionamento interno de um RTC. (como ele conta os dias/meses e anos ? gastando pouca energia). Explique como o LINUX controla e acessa o RTC do computador ( https://www.kernel.org/doc/Documentation/rtc.txt ) ( http://lxr.free-electrons.com/source/drivers/char/rtc.c ) Como o TimerCounter pode ser utilizado para medir a velocidade e posi\u00e7\u00e3o de um motor usando um encoder \u00f3tico? Qual o consumo de energia do RTC no SAME70 ? Avalia\u00e7\u00e3o Estaremos trabalhando nessa etapa os seguintes itens dos objetivos de aprendizagem : Entende a rela\u00e7\u00e3o entre o uC e o mundo externo, mas n\u00e3o consegue transpor essa rela\u00e7\u00e3o para um c\u00f3digo. Lista os pontos de execu\u00e7\u00e3o da aplica\u00e7\u00e3o relacionando HW e SW. Correlaciona os diferentes tipos de documentos e faz uso constante da documenta\u00e7\u00e3o. Correlaciona a informa\u00e7\u00e3o encontrada com outros materiais extraindo e sintetiza as informa\u00e7\u00f5es para uso futuro. Sintetiza as informa\u00e7\u00f5es em um documento externo ao c\u00f3digo.","title":"Lab TC RTC RTT Perguntas"},{"location":"navigation/Labs/Lab_TC_RTC_RTT/Lab-TC-RTC-RTT-Perguntas/#diagrama","text":"Com o intuito de clarificar o entendimento da interrup\u00e7\u00e3o e dos perif\u00e9ricos recentemente vistos (TC e RTC), fa\u00e7a um diagrama de blocos que contenha toda a informa\u00e7\u00e3o necess\u00e1ria para o entedimento da entrega Tick Tack . Esse diagrama deve conter ao menos os seguintes itens: Perif\u00e9ricos utilizados Interface dos perif\u00e9ricos com o CORE Pinos utilizados e como est\u00e3o conectados nos perif\u00e9ricos Numerar os pinos de cada LED (ex. PA8, PB12, ...). Deve ficar claro o que \u00e9 : uC Kit de desenvolvimento M\u00f3dulo OLED1 Deve-se ilustra as interfaces de interrup\u00e7\u00e3o entre os perif\u00e9ricos e o Core Informar os valores (ID_TC0, ID_TC1) de cada interrup\u00e7\u00e3o","title":"Diagrama"},{"location":"navigation/Labs/Lab_TC_RTC_RTT/Lab-TC-RTC-RTT-Perguntas/#pesquisa","text":"(m\u00ednimo dois itens da lista) Explique o funcionamento interno de um RTC. (como ele conta os dias/meses e anos ? gastando pouca energia). Explique como o LINUX controla e acessa o RTC do computador ( https://www.kernel.org/doc/Documentation/rtc.txt ) ( http://lxr.free-electrons.com/source/drivers/char/rtc.c ) Como o TimerCounter pode ser utilizado para medir a velocidade e posi\u00e7\u00e3o de um motor usando um encoder \u00f3tico? Qual o consumo de energia do RTC no SAME70 ?","title":"Pesquisa"},{"location":"navigation/Labs/Lab_TC_RTC_RTT/Lab-TC-RTC-RTT-Perguntas/#avaliacao","text":"Estaremos trabalhando nessa etapa os seguintes itens dos objetivos de aprendizagem : Entende a rela\u00e7\u00e3o entre o uC e o mundo externo, mas n\u00e3o consegue transpor essa rela\u00e7\u00e3o para um c\u00f3digo. Lista os pontos de execu\u00e7\u00e3o da aplica\u00e7\u00e3o relacionando HW e SW. Correlaciona os diferentes tipos de documentos e faz uso constante da documenta\u00e7\u00e3o. Correlaciona a informa\u00e7\u00e3o encontrada com outros materiais extraindo e sintetiza as informa\u00e7\u00f5es para uso futuro. Sintetiza as informa\u00e7\u00f5es em um documento externo ao c\u00f3digo.","title":"Avalia\u00e7\u00e3o"},{"location":"navigation/Labs/Lab_TC_RTC_RTT/Lab-TC-RTC-RTT/","text":"LAB - TC - RTC - RTT Neste laborat\u00f3rio iremos trabalhar com os perif\u00e9ricos de contagem de tempo do nosso microcontrolador. Pasta Lab4-TC-RTC-RTT Data da entrega: 18/03 Os perif\u00e9ricos apresentados neste laborat\u00f3rio s\u00e3o: Real Time Clock - RTC Timer Counter - TC Real Time Timer - RTT O laborat\u00f3rio \u00e9 formado por duas partes: Parte 1 (m\u00ednimo): Entender os exemplos (TC/RTT/RTC) Incorporar todos os exemplos em um \u00fanico projeto Pisca pisca Parte 2: C+ : fazer outro LED piscar com TC B : Exibir a hora atual no OLED A : Usar IRQ do segundos do RTC Exemplos SAME70-examples Antes de continuar atualize o reposit\u00f3rio de exemplos ele foi atualizado logo antes do lab! Nesse lab iremos trabalhar com tr\u00eas perif\u00e9ricos que lidam com \"tempo\": o TimerCounter (TC) que temos no total de quatro unidades TC (TC0 ~ TC3) e cada um com tr\u00eas contadores; o Real-time Timer (RTT) que s\u00f3 temos um e o Real-time Clock (RTC) que tamb\u00e9m s\u00f3 temos um e funciona como um rel\u00f3gio/calend\u00e1rio. Um pouco mais sobre os perif\u00e9ricos: TC: Faz v\u00e1rias coisas, mas na disciplina iremos utiliz\u00e1-lo para gerar interrup\u00e7\u00f5es de tempo maiores que 2Hz ( ele n\u00e3o consegue gerar tempos muito lentos! ) RTT: \u00c9 um contador que consegue gerar praticamente qualquer frequ\u00eancia (vamos usar para gerar frequ\u00eancias lentas) RTC: \u00c9 um como um calend\u00e1rio com rel\u00f3gio, ele conta anos, meses, dias, horas, minutos e segundos. E possui um alarme que pode ser configurado para gerar uma interrup\u00e7\u00e3o em um determinado momento. N\u00f3s fornecemos para cada perif\u00e9rico um exemplo diferente: Perif\u00e9rico exemplos Perifericos/TC-IRQ Perifericos/RTT-IRQ Perifericos/RTC-IRQ Cada exemplo possui o seu pr\u00f3prio README que explica de forma ampla os perif\u00e9ricos. Note que todos esses exemplos est\u00e3o operando por interrup\u00e7\u00e3o! Onde cada perif\u00e9rico possui o seu handler para resolver a interrup\u00e7\u00e3o. Exercise Para cada exemplo (TC, RTT e RTC): Leia o README Programe a placa (e veja os LEDs piscando!) Entenda o c\u00f3digo Progress Importante ler o README, analisar e executar cada um dos exemplos antes de seguir. Exercise Qual frase a seguir \u00e9 Correta ? O TC pode ser configurado para gerar uma frequ\u00eancia de 10s O RTC tem resoluc\u00e3o de ms O nosso microcontrolador possui at\u00e9 3 RTT Cada RTT possui tr\u00eas canais O RTT pode gerar duas interrupc\u00f5es: incremento e alarme. Answer O TC pode ser configurado para gerar uma frequ\u00eancia de 10s O tempo m\u00ednimo que ele pode contar \u00e9 1s. O RTC tem resoluc\u00e3o de ms O RTC conta segundos! O nosso microcontrolador possui at\u00e9 3 RTT N\u00e3o s\u00f3 possui um. Quem tem 3 \u00e9 o TC Cada RTT possui tr\u00eas canais N\u00e3o! Quem possui tr\u00eas canais \u00e9 o TC O RTT pode gerar duas interrupc\u00f5es: incremento e alarme. Sim!! Podemos configurar no RTT dois modos de IRQ Exercise Como deve ser a chamada de fun\u00e7\u00e3o para usarmos o TC2 canal 2 gerando interrup\u00e7\u00e3o a 20Hz? void TC_init ( Tc * TC , int ID_TC , int TC_CHANNEL , int freq ){ TC_init(TC2, ID_TC2, 1, 20); TC_init(TC2, ID_TC8, 2, 20); TC_init(TC8, ID_TC8, 8, 20); TC_init(TC8, ID_TC2, 3, 20); Answer O TC funciona diferente do PIO, onde o PIO possuia apenas uma conex\u00e3o com o NVIC para avisar a interrupc\u00e3o em qualquer um dos 32 pinos. O TC possui um sinal de conex\u00e3o com o NVIC para cada canal e esses canais possuem um ID \u00fanico, conforme figura a seguir: Exercise Se usarmos o TC1 canal 0 qual deve ser a func\u00e3o de handler? TC0_Handler TC1_Handler TC2_Handler TC3_Handler TC4_Handler TC5_Handler Answer O handler a ser usado tem realac\u00e3o com o ID do canal, no caso do canal 0 do TC1 o ID \u00e9 o ID_TC3 e o handler o TC3_Handler . Exercise Um colega est\u00e1 desenhando uma solu\u00e7\u00e3o para um sistema embarcado que precisa processar dados nas frequ\u00eancias: 1Hz, 2Hz e 44200Hz. Pensando em otimizar o uso energ\u00e9tico do uC ele prop\u00f4s usar um \u00fanico TC e configurar para cada canal uma frequ\u00eancia diferente: TC0 / ID_TC0 @ 1Hz TC0 / ID_TC1 @ 2Hz TC0 / ID_TC2 @ 44200Hz O que voc\u00ea faz? Aprova achando uma boa ideia! Fica desconfiado e n\u00e3o sabe responder. Reprova sabendo o porque n\u00e3o funciona. Answer Aqui tem uma pegadinha! Para o TC contar \"tempo\" ele precisa usar como base um clock gerado pelo PMC, o TC n\u00e3o consegue usar mais de uma base de tempo por perif\u00e9rico (a mesma base se aplica a todos os canais que ele controla). Para as frequ\u00eancias 1Hz e 2Hz pode ser que funcione usar o mesmo TC pois a base de tempo que a fun\u00e7\u00e3o tc_init vai encontrar deve ser a mesma, mas j\u00e1 para a frequ\u00eancia de 44200Hz a base deve ser outra (\u00e9 ordens de grandeza maior que as outras frequ\u00eancias) e usar o mesmo TC n\u00e3o vai funcionar! A melhor solu\u00e7\u00e3o aqui seria, usar um TC para as frequ\u00eancias mais baixas e outro apenas para a maior frequ\u00eancia: TC0 / ID_TC0 @ 1Hz TC0 / ID_TC1 @ 2Hz TC1 / ID_TC3 @ 44200Hz Essa parte da escolha da frequ\u00eancia \u00e9 realizado dentro da fun\u00e7\u00e3o TC_init nas linhas: /** Configura o TC para operar em freq hz e interrup\u00e7c\u00e3o no RC compare */ tc_find_mck_divisor ( freq , ul_sysclk , & ul_div , & ul_tcclks , ul_sysclk ); tc_init ( TC , TC_CHANNEL , ul_tcclks | TC_CMR_CPCTRG ); Exercise Qual item configura o RTT para gerar uma interrup\u00e7\u00e3o de alarme em 13s. Lembre dos argumentos da func\u00e3o: /** * Configura RTT * * arg0 pllPreScale : Frequ\u00eancia na qual o contador ir\u00e1 incrementar * arg1 IrqNPulses : Valor do alarme * arg2 rttIRQSource : Pode ser uma * - 0: * - RTT_MR_RTTINCIEN: Interrup\u00e7\u00e3o por incremento (pllPreScale) * - RTT_MR_ALMIEN : Interrup\u00e7\u00e3o por alarme */ static void RTT_init ( float freqPrescale , uint32_t IrqNPulses , uint32_t rttIRQSource ) { RTT_init(4, 13, RTT_MR_ALMIEN); RTT_init(13, 1, RTT_MR_ALMIEN); RTT_init(10, 130, RTT_MR_ALMIEN); RTT_init(1, 13, RTT_MR_ALMIEN); Answer Vamos recapitular o que a fun\u00e7\u00e3o RTT_init recebe de argumentos: arg0: define a frequ\u00eancia na qual o contador interno do RTT ir\u00e1 operar. arg1: se configurado a interrup\u00e7\u00e3o de alarme, qual o seu valor arg2: quais modos de IRQ v\u00e3o estar ativados. Agora vamos analisar as respostas: RTT_init(4, 13, RTT_MR_ALMIEN) Configura o RTT para operar a 4hz (0.25s) e configuramos o alarme para quando o contador chegar em 13, ou seja: 13*0.25 = 3.25s* . Poder\u00edamos ter colocado 52 no lugar de 13, assim o alarme estaria certo: 0.25*52 = 13s* . RTT_init(13, 1, RTT_MR_ALMIEN); Configura o RTT para operar com 13 incrementos por segundo, mas o alarme foi configurado para 1 , ou seja: 1/13 * 1 = 0.078s . RTT_init(10, 130, RTT_MR_ALMIEN); Essa aqui \u00e9 uma op\u00e7\u00e3o de resposta correta. Incremento de 10x por segundo e alarme configurado para 130, ou seja: 130/10 = 13s RTT_init(1, 13, RTT_MR_ALMIEN); Outra op\u00e7\u00e3o de resposta correta. Incremento de 1x por segundo e alarme configurado para 13, ou seja: 13/1= 13s Notem que temos duas respostas corretas, mas elas possuem uma sutil e importante diferen\u00e7a: O valor que o contador do RTT atinge antes do alarme. Exercise Imagine que voc\u00ea est\u00e1 fazendo um datalogger que armazena Valores e TimeStamp (TS), como voc\u00ea faz para: Fazer com que o RTC sincronize com o hor\u00e1rio/ calend\u00e1rio real? O que acontece se acabar a bateria do equipamento? Vamos perder a configurac\u00e3o do RTC? Answer Bom.... n\u00e3o tem uma \u00fanica resposta para essas perguntas, tudo vai depender um pouco de como \u00e9 o sistema embarcado que voc\u00ea est\u00e1 desenvolvendo/ projetando, mas vamos analisar algumas alternativas aqui. Fazer com que o RTC sincronize com o hor\u00e1rio/ calend\u00e1rio real? O sistema embarcado tem conex\u00e3o com a internet? Se tiver facilita um pouco a solu\u00e7\u00e3o. Com a internet podemos consutlar um dos servidor de rel\u00f3gio dispon\u00edvel, existe at\u00e9 um protocolo chamado de Network Time Protocol (NTP) criado para esse fim de sincronizac\u00e3o de rel\u00f3gios e v\u00e1rios servidores s\u00e3o p\u00fablicos e est\u00e3o espalhados pelo globo: Alguns servidores, fonte: http://www.pi-time.ca/ Se n\u00e3o tiver conex\u00e3o com a internet, a soluc\u00e3o \u00e9 configurar o rel\u00f3gio no pr\u00f3prio dispositivo (via bot\u00f5es e displays) ou conectar o dispositivo em algum outro device via bluetooth/usb/... e fazer a configurac\u00e3o por um programa/aplicativo pr\u00f3prio. O que acontece se acabar a bateria do equipamento? Vamos perder a configurac\u00e3o do RTC? Muitas vezes o RTC usa uma bateria auxiliar para que ele n\u00e3o se desconfigure quando o sistema principal fica sem energia. Pegue como exemplo o seu notebook, mesmo quando acaba a bateria ele volta com a hora correta. A vida \u00fatil dessa bateria depende de v\u00e1rios fatores, mas \u00e9 comum durar anos. Anti tamper RTC O RTC \u00e9 um dos itens de um sistema embarcado que os hackers gostam de atacar, deem uma olhada nisso: https://www.eetimes.com/anti-tamper-real-time-clock-rtc-make-your-embedded-system-secure/ Lab O lab faz uso da placa OLED1 e de um c\u00f3digo exemplo. Para come\u00e7ar voc\u00ea deve copiar o c\u00f3digo exemplo: SAME70-examples/Screens/OLED-Xplained-Pro-SPI/ para a pasta da entrega do seu reposit\u00f3rio Lab4-TC-RTC-RTT . Conceito C Com o c\u00f3digo do OLED1 copiado, voc\u00eas devem configurar os bot\u00f5es e os LEDs da placa OLED e ent\u00e3o utilizando os perif\u00e9ricos fazer: Que o LED1 pisque na frequ\u00eancia de 4Hz, para isso utilize o TC ; Fazer com que o LED2 pisque a uma frequ\u00eancia de 0.25Hz, para isso utilize o RTT ; Piscar o LED3 depois de 20 segundos do bot\u00e3o 1 da placa OLED ter sido pressionado, para isso utilize o alarme do RTC. Lembre de fazer o uC entrar em sleepmode sempre que n\u00e3o tiver nada para fazer. Tip Abrir o c\u00f3digo atual e o exemplo e ir trazendo as fun\u00e7\u00f5es e defines que precisa usar, n\u00e3o esque\u00e7a de chamar as fun\u00e7\u00f5es no main . Tip Voc\u00ea vai precisar incluir no ASF WIZARD os drivers do TC , RTT e RTT O TC j\u00e1 foi adicionado no c\u00f3digo exemplo (OLED-Xplained-Pro-SPI), n\u00e3o adicone o outro que vai dar problema!!!! Tip O RTC tem uma fun\u00e7\u00e3o que voc\u00ea consegue buscar no perif\u00e9rico a hora atual: rtc_get_time() , voc\u00ea pode ent\u00e3o configurar um alarme para daqui 20s. Leia a fun\u00e7\u00e3o e entenda os seus par\u00e2metros!! Exercise No c\u00f3digo do OLED1: Configurar os pinos e os LEDs da placa OLED1 Fa\u00e7a o LED da placa piscar a 5Hz usando um TC. Fazer com que o LED1 pisque a 4Hz usando o TC Fazer com que o LED2 inverta seu estado a cada 4s usando o RTT Fazer com o que o LED3 inicie apagado e pisque uma vez ap\u00f3s 20 segundos do bot\u00e3o 1 ter sido pressionado, use o RTC. Entrar em sleepmode sempre que poss\u00edvel Ao terminar o lab preencha: Carregando\u2026 Conceito B Exercise Exiba a hora no formato (HH:MM:SS) no display OLED, a hora deve ser atualizada a todo segundo! Tip Para executar isso voc\u00ea dever\u00e1 ser capaz de saber quando que o segundo mudou, duas s\u00e3o as op\u00e7\u00f5es: Usar um novo TC configurado com 1hz Pedir para o RTC gerar uma IRQ a cada mudan\u00e7a de segundo A segunda op\u00e7\u00e3o voc\u00ea faz modificando a fun\u00e7\u00e3o de init_rtc: RTC_init ( RTC , ID_RTC , rtc_initial , RTC_IER_ALREN | RTC_IER_SECEN ); E agora voc\u00ea consegue dentro do RTC_handler saber quando voc\u00ea entrou na IRQ pelo segundo: /* Verifica por qual motivo entrou * na interrupcao, se foi por segundo * ou Alarm */ if (( ul_status & RTC_SR_SEC ) == RTC_SR_SEC ) { // // Entrou por segundo! // rtc_clear_status ( RTC , RTC_SCCR_SECCLR ); } Warning Voc\u00ea nunca deve atualizar display dentro de interrup\u00e7\u00e3o ( handler )! Sempre no main. Conceito A: Melhorando Exercise Quando o bot\u00e3o 1 da placa OLED for pressionado, ap\u00f3s 20 segundos, fa\u00e7a o LED 3 piscar com um novo TC, substituindo essa fun\u00e7\u00e3o que antes era do RTC .","title":"LAB - TC - RTC - RTT"},{"location":"navigation/Labs/Lab_TC_RTC_RTT/Lab-TC-RTC-RTT/#lab-tc-rtc-rtt","text":"Neste laborat\u00f3rio iremos trabalhar com os perif\u00e9ricos de contagem de tempo do nosso microcontrolador. Pasta Lab4-TC-RTC-RTT Data da entrega: 18/03 Os perif\u00e9ricos apresentados neste laborat\u00f3rio s\u00e3o: Real Time Clock - RTC Timer Counter - TC Real Time Timer - RTT O laborat\u00f3rio \u00e9 formado por duas partes: Parte 1 (m\u00ednimo): Entender os exemplos (TC/RTT/RTC) Incorporar todos os exemplos em um \u00fanico projeto Pisca pisca Parte 2: C+ : fazer outro LED piscar com TC B : Exibir a hora atual no OLED A : Usar IRQ do segundos do RTC","title":"LAB - TC - RTC - RTT"},{"location":"navigation/Labs/Lab_TC_RTC_RTT/Lab-TC-RTC-RTT/#exemplos","text":"SAME70-examples Antes de continuar atualize o reposit\u00f3rio de exemplos ele foi atualizado logo antes do lab! Nesse lab iremos trabalhar com tr\u00eas perif\u00e9ricos que lidam com \"tempo\": o TimerCounter (TC) que temos no total de quatro unidades TC (TC0 ~ TC3) e cada um com tr\u00eas contadores; o Real-time Timer (RTT) que s\u00f3 temos um e o Real-time Clock (RTC) que tamb\u00e9m s\u00f3 temos um e funciona como um rel\u00f3gio/calend\u00e1rio. Um pouco mais sobre os perif\u00e9ricos: TC: Faz v\u00e1rias coisas, mas na disciplina iremos utiliz\u00e1-lo para gerar interrup\u00e7\u00f5es de tempo maiores que 2Hz ( ele n\u00e3o consegue gerar tempos muito lentos! ) RTT: \u00c9 um contador que consegue gerar praticamente qualquer frequ\u00eancia (vamos usar para gerar frequ\u00eancias lentas) RTC: \u00c9 um como um calend\u00e1rio com rel\u00f3gio, ele conta anos, meses, dias, horas, minutos e segundos. E possui um alarme que pode ser configurado para gerar uma interrup\u00e7\u00e3o em um determinado momento. N\u00f3s fornecemos para cada perif\u00e9rico um exemplo diferente: Perif\u00e9rico exemplos Perifericos/TC-IRQ Perifericos/RTT-IRQ Perifericos/RTC-IRQ Cada exemplo possui o seu pr\u00f3prio README que explica de forma ampla os perif\u00e9ricos. Note que todos esses exemplos est\u00e3o operando por interrup\u00e7\u00e3o! Onde cada perif\u00e9rico possui o seu handler para resolver a interrup\u00e7\u00e3o. Exercise Para cada exemplo (TC, RTT e RTC): Leia o README Programe a placa (e veja os LEDs piscando!) Entenda o c\u00f3digo Progress Importante ler o README, analisar e executar cada um dos exemplos antes de seguir. Exercise Qual frase a seguir \u00e9 Correta ? O TC pode ser configurado para gerar uma frequ\u00eancia de 10s O RTC tem resoluc\u00e3o de ms O nosso microcontrolador possui at\u00e9 3 RTT Cada RTT possui tr\u00eas canais O RTT pode gerar duas interrupc\u00f5es: incremento e alarme. Answer O TC pode ser configurado para gerar uma frequ\u00eancia de 10s O tempo m\u00ednimo que ele pode contar \u00e9 1s. O RTC tem resoluc\u00e3o de ms O RTC conta segundos! O nosso microcontrolador possui at\u00e9 3 RTT N\u00e3o s\u00f3 possui um. Quem tem 3 \u00e9 o TC Cada RTT possui tr\u00eas canais N\u00e3o! Quem possui tr\u00eas canais \u00e9 o TC O RTT pode gerar duas interrupc\u00f5es: incremento e alarme. Sim!! Podemos configurar no RTT dois modos de IRQ Exercise Como deve ser a chamada de fun\u00e7\u00e3o para usarmos o TC2 canal 2 gerando interrup\u00e7\u00e3o a 20Hz? void TC_init ( Tc * TC , int ID_TC , int TC_CHANNEL , int freq ){ TC_init(TC2, ID_TC2, 1, 20); TC_init(TC2, ID_TC8, 2, 20); TC_init(TC8, ID_TC8, 8, 20); TC_init(TC8, ID_TC2, 3, 20); Answer O TC funciona diferente do PIO, onde o PIO possuia apenas uma conex\u00e3o com o NVIC para avisar a interrupc\u00e3o em qualquer um dos 32 pinos. O TC possui um sinal de conex\u00e3o com o NVIC para cada canal e esses canais possuem um ID \u00fanico, conforme figura a seguir: Exercise Se usarmos o TC1 canal 0 qual deve ser a func\u00e3o de handler? TC0_Handler TC1_Handler TC2_Handler TC3_Handler TC4_Handler TC5_Handler Answer O handler a ser usado tem realac\u00e3o com o ID do canal, no caso do canal 0 do TC1 o ID \u00e9 o ID_TC3 e o handler o TC3_Handler . Exercise Um colega est\u00e1 desenhando uma solu\u00e7\u00e3o para um sistema embarcado que precisa processar dados nas frequ\u00eancias: 1Hz, 2Hz e 44200Hz. Pensando em otimizar o uso energ\u00e9tico do uC ele prop\u00f4s usar um \u00fanico TC e configurar para cada canal uma frequ\u00eancia diferente: TC0 / ID_TC0 @ 1Hz TC0 / ID_TC1 @ 2Hz TC0 / ID_TC2 @ 44200Hz O que voc\u00ea faz? Aprova achando uma boa ideia! Fica desconfiado e n\u00e3o sabe responder. Reprova sabendo o porque n\u00e3o funciona. Answer Aqui tem uma pegadinha! Para o TC contar \"tempo\" ele precisa usar como base um clock gerado pelo PMC, o TC n\u00e3o consegue usar mais de uma base de tempo por perif\u00e9rico (a mesma base se aplica a todos os canais que ele controla). Para as frequ\u00eancias 1Hz e 2Hz pode ser que funcione usar o mesmo TC pois a base de tempo que a fun\u00e7\u00e3o tc_init vai encontrar deve ser a mesma, mas j\u00e1 para a frequ\u00eancia de 44200Hz a base deve ser outra (\u00e9 ordens de grandeza maior que as outras frequ\u00eancias) e usar o mesmo TC n\u00e3o vai funcionar! A melhor solu\u00e7\u00e3o aqui seria, usar um TC para as frequ\u00eancias mais baixas e outro apenas para a maior frequ\u00eancia: TC0 / ID_TC0 @ 1Hz TC0 / ID_TC1 @ 2Hz TC1 / ID_TC3 @ 44200Hz Essa parte da escolha da frequ\u00eancia \u00e9 realizado dentro da fun\u00e7\u00e3o TC_init nas linhas: /** Configura o TC para operar em freq hz e interrup\u00e7c\u00e3o no RC compare */ tc_find_mck_divisor ( freq , ul_sysclk , & ul_div , & ul_tcclks , ul_sysclk ); tc_init ( TC , TC_CHANNEL , ul_tcclks | TC_CMR_CPCTRG ); Exercise Qual item configura o RTT para gerar uma interrup\u00e7\u00e3o de alarme em 13s. Lembre dos argumentos da func\u00e3o: /** * Configura RTT * * arg0 pllPreScale : Frequ\u00eancia na qual o contador ir\u00e1 incrementar * arg1 IrqNPulses : Valor do alarme * arg2 rttIRQSource : Pode ser uma * - 0: * - RTT_MR_RTTINCIEN: Interrup\u00e7\u00e3o por incremento (pllPreScale) * - RTT_MR_ALMIEN : Interrup\u00e7\u00e3o por alarme */ static void RTT_init ( float freqPrescale , uint32_t IrqNPulses , uint32_t rttIRQSource ) { RTT_init(4, 13, RTT_MR_ALMIEN); RTT_init(13, 1, RTT_MR_ALMIEN); RTT_init(10, 130, RTT_MR_ALMIEN); RTT_init(1, 13, RTT_MR_ALMIEN); Answer Vamos recapitular o que a fun\u00e7\u00e3o RTT_init recebe de argumentos: arg0: define a frequ\u00eancia na qual o contador interno do RTT ir\u00e1 operar. arg1: se configurado a interrup\u00e7\u00e3o de alarme, qual o seu valor arg2: quais modos de IRQ v\u00e3o estar ativados. Agora vamos analisar as respostas: RTT_init(4, 13, RTT_MR_ALMIEN) Configura o RTT para operar a 4hz (0.25s) e configuramos o alarme para quando o contador chegar em 13, ou seja: 13*0.25 = 3.25s* . Poder\u00edamos ter colocado 52 no lugar de 13, assim o alarme estaria certo: 0.25*52 = 13s* . RTT_init(13, 1, RTT_MR_ALMIEN); Configura o RTT para operar com 13 incrementos por segundo, mas o alarme foi configurado para 1 , ou seja: 1/13 * 1 = 0.078s . RTT_init(10, 130, RTT_MR_ALMIEN); Essa aqui \u00e9 uma op\u00e7\u00e3o de resposta correta. Incremento de 10x por segundo e alarme configurado para 130, ou seja: 130/10 = 13s RTT_init(1, 13, RTT_MR_ALMIEN); Outra op\u00e7\u00e3o de resposta correta. Incremento de 1x por segundo e alarme configurado para 13, ou seja: 13/1= 13s Notem que temos duas respostas corretas, mas elas possuem uma sutil e importante diferen\u00e7a: O valor que o contador do RTT atinge antes do alarme. Exercise Imagine que voc\u00ea est\u00e1 fazendo um datalogger que armazena Valores e TimeStamp (TS), como voc\u00ea faz para: Fazer com que o RTC sincronize com o hor\u00e1rio/ calend\u00e1rio real? O que acontece se acabar a bateria do equipamento? Vamos perder a configurac\u00e3o do RTC? Answer Bom.... n\u00e3o tem uma \u00fanica resposta para essas perguntas, tudo vai depender um pouco de como \u00e9 o sistema embarcado que voc\u00ea est\u00e1 desenvolvendo/ projetando, mas vamos analisar algumas alternativas aqui. Fazer com que o RTC sincronize com o hor\u00e1rio/ calend\u00e1rio real? O sistema embarcado tem conex\u00e3o com a internet? Se tiver facilita um pouco a solu\u00e7\u00e3o. Com a internet podemos consutlar um dos servidor de rel\u00f3gio dispon\u00edvel, existe at\u00e9 um protocolo chamado de Network Time Protocol (NTP) criado para esse fim de sincronizac\u00e3o de rel\u00f3gios e v\u00e1rios servidores s\u00e3o p\u00fablicos e est\u00e3o espalhados pelo globo: Alguns servidores, fonte: http://www.pi-time.ca/ Se n\u00e3o tiver conex\u00e3o com a internet, a soluc\u00e3o \u00e9 configurar o rel\u00f3gio no pr\u00f3prio dispositivo (via bot\u00f5es e displays) ou conectar o dispositivo em algum outro device via bluetooth/usb/... e fazer a configurac\u00e3o por um programa/aplicativo pr\u00f3prio. O que acontece se acabar a bateria do equipamento? Vamos perder a configurac\u00e3o do RTC? Muitas vezes o RTC usa uma bateria auxiliar para que ele n\u00e3o se desconfigure quando o sistema principal fica sem energia. Pegue como exemplo o seu notebook, mesmo quando acaba a bateria ele volta com a hora correta. A vida \u00fatil dessa bateria depende de v\u00e1rios fatores, mas \u00e9 comum durar anos. Anti tamper RTC O RTC \u00e9 um dos itens de um sistema embarcado que os hackers gostam de atacar, deem uma olhada nisso: https://www.eetimes.com/anti-tamper-real-time-clock-rtc-make-your-embedded-system-secure/","title":"Exemplos"},{"location":"navigation/Labs/Lab_TC_RTC_RTT/Lab-TC-RTC-RTT/#lab","text":"O lab faz uso da placa OLED1 e de um c\u00f3digo exemplo. Para come\u00e7ar voc\u00ea deve copiar o c\u00f3digo exemplo: SAME70-examples/Screens/OLED-Xplained-Pro-SPI/ para a pasta da entrega do seu reposit\u00f3rio Lab4-TC-RTC-RTT .","title":"Lab"},{"location":"navigation/Labs/Lab_TC_RTC_RTT/Lab-TC-RTC-RTT/#conceito-c","text":"Com o c\u00f3digo do OLED1 copiado, voc\u00eas devem configurar os bot\u00f5es e os LEDs da placa OLED e ent\u00e3o utilizando os perif\u00e9ricos fazer: Que o LED1 pisque na frequ\u00eancia de 4Hz, para isso utilize o TC ; Fazer com que o LED2 pisque a uma frequ\u00eancia de 0.25Hz, para isso utilize o RTT ; Piscar o LED3 depois de 20 segundos do bot\u00e3o 1 da placa OLED ter sido pressionado, para isso utilize o alarme do RTC. Lembre de fazer o uC entrar em sleepmode sempre que n\u00e3o tiver nada para fazer. Tip Abrir o c\u00f3digo atual e o exemplo e ir trazendo as fun\u00e7\u00f5es e defines que precisa usar, n\u00e3o esque\u00e7a de chamar as fun\u00e7\u00f5es no main . Tip Voc\u00ea vai precisar incluir no ASF WIZARD os drivers do TC , RTT e RTT O TC j\u00e1 foi adicionado no c\u00f3digo exemplo (OLED-Xplained-Pro-SPI), n\u00e3o adicone o outro que vai dar problema!!!! Tip O RTC tem uma fun\u00e7\u00e3o que voc\u00ea consegue buscar no perif\u00e9rico a hora atual: rtc_get_time() , voc\u00ea pode ent\u00e3o configurar um alarme para daqui 20s. Leia a fun\u00e7\u00e3o e entenda os seus par\u00e2metros!! Exercise No c\u00f3digo do OLED1: Configurar os pinos e os LEDs da placa OLED1 Fa\u00e7a o LED da placa piscar a 5Hz usando um TC. Fazer com que o LED1 pisque a 4Hz usando o TC Fazer com que o LED2 inverta seu estado a cada 4s usando o RTT Fazer com o que o LED3 inicie apagado e pisque uma vez ap\u00f3s 20 segundos do bot\u00e3o 1 ter sido pressionado, use o RTC. Entrar em sleepmode sempre que poss\u00edvel Ao terminar o lab preencha: Carregando\u2026","title":"Conceito C"},{"location":"navigation/Labs/Lab_TC_RTC_RTT/Lab-TC-RTC-RTT/#conceito-b","text":"Exercise Exiba a hora no formato (HH:MM:SS) no display OLED, a hora deve ser atualizada a todo segundo! Tip Para executar isso voc\u00ea dever\u00e1 ser capaz de saber quando que o segundo mudou, duas s\u00e3o as op\u00e7\u00f5es: Usar um novo TC configurado com 1hz Pedir para o RTC gerar uma IRQ a cada mudan\u00e7a de segundo A segunda op\u00e7\u00e3o voc\u00ea faz modificando a fun\u00e7\u00e3o de init_rtc: RTC_init ( RTC , ID_RTC , rtc_initial , RTC_IER_ALREN | RTC_IER_SECEN ); E agora voc\u00ea consegue dentro do RTC_handler saber quando voc\u00ea entrou na IRQ pelo segundo: /* Verifica por qual motivo entrou * na interrupcao, se foi por segundo * ou Alarm */ if (( ul_status & RTC_SR_SEC ) == RTC_SR_SEC ) { // // Entrou por segundo! // rtc_clear_status ( RTC , RTC_SCCR_SECCLR ); } Warning Voc\u00ea nunca deve atualizar display dentro de interrup\u00e7\u00e3o ( handler )! Sempre no main.","title":"Conceito B"},{"location":"navigation/Labs/Lab_TC_RTC_RTT/Lab-TC-RTC-RTT/#conceito-a-melhorando","text":"Exercise Quando o bot\u00e3o 1 da placa OLED for pressionado, ap\u00f3s 20 segundos, fa\u00e7a o LED 3 piscar com um novo TC, substituindo essa fun\u00e7\u00e3o que antes era do RTC .","title":"Conceito A: Melhorando"},{"location":"navigation/Labs/Lab_mutex/lab/","text":"LAB - Mutex Neste laborat\u00f3rio iremos trabalhar usar mutex no freertos para controlar o acesso ao LVGL entre m\u00faltiplas tasks. Lab Exemplo base LAB Lab7-RTOS-LCD-LVGL Lab8-RTOS-Mutex C\u00f3digo exemplo Vamos modificar o c\u00f3digo exemplo do laborat\u00f3rio passado, tudo bem se voc\u00ea n\u00e3o terminou de implementar todas as funcionalidades. Fa\u00e7a uma c\u00f3pia para o seu reposit\u00f3rio de laborat\u00f3rios renomeando para Labs8-RTOS-Mutex . Mutexes Info Sim... sim.. o mesmo mutex de sistema hardware software ( lock e unlock ): https://insper.github.io/SistemasHardwareSoftware/aulas/20-sincronizacao/ Tip Mutex vem de 'MUT'ual 'EX'clusion ou exclus\u00e3o m\u00fatua, a ideia \u00e9 para ser usado como um bast\u00e3o, que indica que o recurso est\u00e1 em uso por outra parte do programa. O LVGL n\u00e3o \u00e9 thread-safe by default , como indicado na p\u00e1gina: https://docs.lvgl.io/master/porting/os.html Isso significa que n\u00e3o podemos chamar uma fun\u00e7\u00e3o do LVGL enquanto a anterior n\u00e3o tiver terminado de executar, e caso implementemos o acesso ao LCD em v\u00e1rias partes do nosso programa corremos grande risco disso acontecer (lembrem que o RTOS interrompe uma tarefa para permitir que outra execute, e isso pode ser no meio da fun\u00e7\u00e3o por exemplo de mudar o valor do label). A documenta\u00e7\u00e3o do LVGL fala o seguinte: If you need to use real tasks or threads, you need a mutex which should be invoked before the call of lv_timer_handler and released after it. Also, you have to use the same mutex in other tasks and threads around every LVGL ( lv_... ) related function call and code. This way you can use LVGL in a real multitasking environment. Just make use of a mutex to avoid the concurrent calling of LVGL functions. Here is some pseudocode to illustrate the concept: static mutex_t lvgl_mutex ; // (1) void lvgl_thread ( void ) { while ( 1 ) { mutex_lock ( & lvgl_mutex ); // (2) lv_task_handler (); mutex_unlock ( & lvgl_mutex ); // (3) thread_sleep ( 10 ); /* sleep for 10 ms */ } } void other_thread ( void ) { /* You must always hold the mutex while using LVGL APIs */ mutex_lock ( & lvgl_mutex ); lv_obj_t * img = lv_img_create ( lv_scr_act ()); mutex_unlock ( & lvgl_mutex ); while ( 1 ) { mutex_lock ( & lvgl_mutex ); /* change to the next image */ lv_img_set_src ( img , next_image ); mutex_unlock ( & lvgl_mutex ); thread_sleep ( 2000 ); } } Cria mutex, vamos ter que usar o do freertos Indica que o recurso est\u00e1 em uso Indica a liberac\u00e3o do recurso Prioridades e Mutex Imaginem o cen\u00e1rio a seguir: Uma tarefa de baixa prioridade (L) requisita um mutex que est\u00e1 livre, no meio da execu\u00e7\u00e3o uma tarefa de alta prioridade (H) \u00e9 colocada para executar pelo escalonador e est\u00e1 tarefa necessita do mesmo mutex que a anterior. O que acontece? P\u00e2nico no sistema tudo trava? N\u00e3o! O escalonador vai permitir que a de baixa execute e a de alta n\u00e3o vai executar pois est\u00e1 esperando o mutex. Isso chama invers\u00e3o de prioridade . Invers\u00e3o de prioridade Invers\u00e3o de prioridade \u00e9 uma \"consequ\u00eancia\" que acontece quando uma tarefa de alta prioridade est\u00e1 aguardando um recurso que n\u00e3o foi liberado por uma tarefa de menor prioridade, o RTOS vai manter a tarefa de baixa prioridade executando, impedindo a de alta de executar (o que n\u00e3o \u00e9 muito desejado). O neg\u00f3cio come\u00e7a a ficar mais complicado quando inclu\u00edmos uma tarefa de m\u00e9dia prioridade na jogada, que pode impedir a de baixa e a de alta de executar, travando o sistema: Acesse o link a seguir para entender mais a respeito: https://www.digikey.com.br/en/maker/projects/introduction-to-rtos-solution-to-part-11-priority-inversion/abf4b8f7cd4a4c70bece35678d178321 Info A invers\u00e3o de prioridade quase colocou fim no Rover Pathfinder da NASA que pousou em marte em 1997, uma invers\u00e3o de prioridade fazia com que o sistema parasse de funcionar, s\u00f3 voltando a operar quando o Watchdog Timer do sistema reiniciava o rob\u00f4. Engenheiros do RTOS usado no rob\u00f4, o VxWorks, trabalharam horas na r\u00e9plica em terra do mesmo a fim de identificar o problema, depois de muito depurar o projeto eles conseguiram descobrir o causador do problema, um mutex. Para saber mais a respeito, acesse: http://www.cs.cornell.edu/courses/cs614/1999sp/papers/pathfinder.html mutex no freeRtos O mutex no FreeRTOS \u00e9 como um sem\u00e1foro bin\u00e1rio, com uma \u00fanica diferen\u00e7a: implementa heran\u00e7a priorit\u00e1ria ( priority inheritance ), que tenta minimizar os efeitos da invers\u00e3o de prioridade. Este mecanismo faz com que a tarefa de baixa prioridade herde temporariamente a prioridade da tarefa de alta que necessita do recurso, ou seja, a tarefa de prioridade baixa, passa a ter alta prioridade at\u00e9 liberar o recurso. Info A solu\u00e7\u00e3o para o Rover que foi para Marte foi a de ativar o mecanismo de heran\u00e7a priorit\u00e1ria no mutex que estava dando o problema. When created, a VxWorks mutex object accepts a boolean parameter that indicates whether priority inheritance should be performed by the mutex. The mutex in question had been initialized with the parameter off; had it been on, the low-priority meteorological thread would have inherited the priority of the high-priority data bus thread blocked on it while it held the mutex, causing it be scheduled with higher priority than the medium-priority communications task, thus preventing the priority inversion. Once diagnosed, it was clear to the JPL engineers that using priority inheritance would prevent the resets they were seeing. Exemplo A seguir um exemplo de mutex adaptado do livro do freertos. No caso a task1 necessita utilizar o printf e para isso requisita o mutex, ap\u00f3s o uso a task libera o mutex permitindo que outra task utilize o printf. SemaphoreHandle_t xMutex ; void task1 () { while ( 1 ) { /* Attempt to take the mutex, blocking indefinitely to wait for the mutex if it is not available straight away. The call to xSemaphoreTake() will only return when the mutex has been successfully obtained, so there is no need to check the function return value. If any other delay period was used then the code must check that xSemaphoreTake() returns pdTRUE before accessing the shared resource (which in this case is standard out). As noted earlier in this book, indefinite time outs are not recommended for production code. */ xSemaphoreTake ( xMutex , portMAX_DELAY ); /* The following line will only execute once the mutex has been successfully obtained. Standard out can be accessed freely now as only one task can have the mutex at any one time. */ printf ( \"%s\" , \"Ola 1\" ); // (1) fflush ( stdout ); /* The mutex MUST be given back! */ xSemaphoreGive ( xMutex ); vTaskDelay ( 100 ); } } void task2 () { while ( 1 ) { xSemaphoreTake ( xMutex , portMAX_DELAY ); printf ( \"%s\" , \"Ola 2\" ); // (2) fflush ( stdout ); xSemaphoreGive ( xMutex ); vTaskDelay ( 100 ); } } void main () { xMutex = xSemaphoreCreateMutex (); // .... } Regi\u00e3o cr\u00edtica de compartilhamento de recursos. Regi\u00e3o cr\u00edtica de compartilhamento de recursos. Tip Meio ruim ter que ficar utilizando o mutex toda hora que for realizar um printf, a solu\u00e7\u00e3o para isso \u00e9 encapsularmos em uma fun\u00e7\u00e3o o uso do mutex e usamos essa fun\u00e7\u00e3o no lugar do printf: void printfMutex ( char * s ) { xSemaphoreTake ( xMutex , portMAX_DELAY ); printf ( \"%s\" , pcString ); fflush ( stdout ); xSemaphoreGive ( xMutex ); } void task1 () { while ( 1 ) { printfMutex ( \"ol\u00e1 1\" ); vTaskDelay ( 100 ); } } void task2 () { while ( 1 ) { printfMutex ( \"ol\u00e1 2\" ); vTaskDelay ( 100 ); } } Programando Agora vamos come\u00e7ar a programar, lembrem que a documenta\u00e7\u00e3o do LVGL fala que: If you need to use real tasks or threads, you need a mutex which should be invoked before the call of lv_timer_handler and released after it. . Como estamos no RTOS estamos usando a func\u00e3o lv_task_handler no lugar da lv_timer_handler . Task mutex lv_task_handler Crie a vari\u00e1vel global que ir\u00e1 servir de mutex chamado de xMutexLVGL do tipo SemaphoreHandle_t No main crie o mutex com xSemaphoreCreateMutex(); Na task_lcd fa\u00e7a a requisi\u00e7\u00e3o do mutex antes de chamar lv_tick_inc e a libera\u00e7\u00e3o depois do lv_task_handler Execute o c\u00f3digo e verifique que NADA DEVE TER MUDADO . Estamos apenas melhorando a qualidade do nosso c\u00f3digo e garantindo que n\u00e3o teremos erros futuros. Preencher ao finalizar o lab Carregando\u2026 APS 2 Este laborat\u00f3rio serve para ajudar voc\u00eas com a APS2, agora podem ter mais de uma task atualizando partes diferentes do LCD via LVGL, lembrem apenas de requisitar o mutex antes e liberar depois de terem usado.","title":"LAB - Mutex"},{"location":"navigation/Labs/Lab_mutex/lab/#lab-mutex","text":"Neste laborat\u00f3rio iremos trabalhar usar mutex no freertos para controlar o acesso ao LVGL entre m\u00faltiplas tasks.","title":"LAB - Mutex"},{"location":"navigation/Labs/Lab_mutex/lab/#lab","text":"Exemplo base LAB Lab7-RTOS-LCD-LVGL Lab8-RTOS-Mutex C\u00f3digo exemplo Vamos modificar o c\u00f3digo exemplo do laborat\u00f3rio passado, tudo bem se voc\u00ea n\u00e3o terminou de implementar todas as funcionalidades. Fa\u00e7a uma c\u00f3pia para o seu reposit\u00f3rio de laborat\u00f3rios renomeando para Labs8-RTOS-Mutex .","title":"Lab"},{"location":"navigation/Labs/Lab_mutex/lab/#mutexes","text":"Info Sim... sim.. o mesmo mutex de sistema hardware software ( lock e unlock ): https://insper.github.io/SistemasHardwareSoftware/aulas/20-sincronizacao/ Tip Mutex vem de 'MUT'ual 'EX'clusion ou exclus\u00e3o m\u00fatua, a ideia \u00e9 para ser usado como um bast\u00e3o, que indica que o recurso est\u00e1 em uso por outra parte do programa. O LVGL n\u00e3o \u00e9 thread-safe by default , como indicado na p\u00e1gina: https://docs.lvgl.io/master/porting/os.html Isso significa que n\u00e3o podemos chamar uma fun\u00e7\u00e3o do LVGL enquanto a anterior n\u00e3o tiver terminado de executar, e caso implementemos o acesso ao LCD em v\u00e1rias partes do nosso programa corremos grande risco disso acontecer (lembrem que o RTOS interrompe uma tarefa para permitir que outra execute, e isso pode ser no meio da fun\u00e7\u00e3o por exemplo de mudar o valor do label). A documenta\u00e7\u00e3o do LVGL fala o seguinte: If you need to use real tasks or threads, you need a mutex which should be invoked before the call of lv_timer_handler and released after it. Also, you have to use the same mutex in other tasks and threads around every LVGL ( lv_... ) related function call and code. This way you can use LVGL in a real multitasking environment. Just make use of a mutex to avoid the concurrent calling of LVGL functions. Here is some pseudocode to illustrate the concept: static mutex_t lvgl_mutex ; // (1) void lvgl_thread ( void ) { while ( 1 ) { mutex_lock ( & lvgl_mutex ); // (2) lv_task_handler (); mutex_unlock ( & lvgl_mutex ); // (3) thread_sleep ( 10 ); /* sleep for 10 ms */ } } void other_thread ( void ) { /* You must always hold the mutex while using LVGL APIs */ mutex_lock ( & lvgl_mutex ); lv_obj_t * img = lv_img_create ( lv_scr_act ()); mutex_unlock ( & lvgl_mutex ); while ( 1 ) { mutex_lock ( & lvgl_mutex ); /* change to the next image */ lv_img_set_src ( img , next_image ); mutex_unlock ( & lvgl_mutex ); thread_sleep ( 2000 ); } } Cria mutex, vamos ter que usar o do freertos Indica que o recurso est\u00e1 em uso Indica a liberac\u00e3o do recurso","title":"Mutexes"},{"location":"navigation/Labs/Lab_mutex/lab/#prioridades-e-mutex","text":"Imaginem o cen\u00e1rio a seguir: Uma tarefa de baixa prioridade (L) requisita um mutex que est\u00e1 livre, no meio da execu\u00e7\u00e3o uma tarefa de alta prioridade (H) \u00e9 colocada para executar pelo escalonador e est\u00e1 tarefa necessita do mesmo mutex que a anterior. O que acontece? P\u00e2nico no sistema tudo trava? N\u00e3o! O escalonador vai permitir que a de baixa execute e a de alta n\u00e3o vai executar pois est\u00e1 esperando o mutex. Isso chama invers\u00e3o de prioridade .","title":"Prioridades e Mutex"},{"location":"navigation/Labs/Lab_mutex/lab/#inversao-de-prioridade","text":"Invers\u00e3o de prioridade \u00e9 uma \"consequ\u00eancia\" que acontece quando uma tarefa de alta prioridade est\u00e1 aguardando um recurso que n\u00e3o foi liberado por uma tarefa de menor prioridade, o RTOS vai manter a tarefa de baixa prioridade executando, impedindo a de alta de executar (o que n\u00e3o \u00e9 muito desejado). O neg\u00f3cio come\u00e7a a ficar mais complicado quando inclu\u00edmos uma tarefa de m\u00e9dia prioridade na jogada, que pode impedir a de baixa e a de alta de executar, travando o sistema: Acesse o link a seguir para entender mais a respeito: https://www.digikey.com.br/en/maker/projects/introduction-to-rtos-solution-to-part-11-priority-inversion/abf4b8f7cd4a4c70bece35678d178321 Info A invers\u00e3o de prioridade quase colocou fim no Rover Pathfinder da NASA que pousou em marte em 1997, uma invers\u00e3o de prioridade fazia com que o sistema parasse de funcionar, s\u00f3 voltando a operar quando o Watchdog Timer do sistema reiniciava o rob\u00f4. Engenheiros do RTOS usado no rob\u00f4, o VxWorks, trabalharam horas na r\u00e9plica em terra do mesmo a fim de identificar o problema, depois de muito depurar o projeto eles conseguiram descobrir o causador do problema, um mutex. Para saber mais a respeito, acesse: http://www.cs.cornell.edu/courses/cs614/1999sp/papers/pathfinder.html","title":"Invers\u00e3o de prioridade"},{"location":"navigation/Labs/Lab_mutex/lab/#mutex-no-freertos","text":"O mutex no FreeRTOS \u00e9 como um sem\u00e1foro bin\u00e1rio, com uma \u00fanica diferen\u00e7a: implementa heran\u00e7a priorit\u00e1ria ( priority inheritance ), que tenta minimizar os efeitos da invers\u00e3o de prioridade. Este mecanismo faz com que a tarefa de baixa prioridade herde temporariamente a prioridade da tarefa de alta que necessita do recurso, ou seja, a tarefa de prioridade baixa, passa a ter alta prioridade at\u00e9 liberar o recurso. Info A solu\u00e7\u00e3o para o Rover que foi para Marte foi a de ativar o mecanismo de heran\u00e7a priorit\u00e1ria no mutex que estava dando o problema. When created, a VxWorks mutex object accepts a boolean parameter that indicates whether priority inheritance should be performed by the mutex. The mutex in question had been initialized with the parameter off; had it been on, the low-priority meteorological thread would have inherited the priority of the high-priority data bus thread blocked on it while it held the mutex, causing it be scheduled with higher priority than the medium-priority communications task, thus preventing the priority inversion. Once diagnosed, it was clear to the JPL engineers that using priority inheritance would prevent the resets they were seeing.","title":"mutex no freeRtos"},{"location":"navigation/Labs/Lab_mutex/lab/#exemplo","text":"A seguir um exemplo de mutex adaptado do livro do freertos. No caso a task1 necessita utilizar o printf e para isso requisita o mutex, ap\u00f3s o uso a task libera o mutex permitindo que outra task utilize o printf. SemaphoreHandle_t xMutex ; void task1 () { while ( 1 ) { /* Attempt to take the mutex, blocking indefinitely to wait for the mutex if it is not available straight away. The call to xSemaphoreTake() will only return when the mutex has been successfully obtained, so there is no need to check the function return value. If any other delay period was used then the code must check that xSemaphoreTake() returns pdTRUE before accessing the shared resource (which in this case is standard out). As noted earlier in this book, indefinite time outs are not recommended for production code. */ xSemaphoreTake ( xMutex , portMAX_DELAY ); /* The following line will only execute once the mutex has been successfully obtained. Standard out can be accessed freely now as only one task can have the mutex at any one time. */ printf ( \"%s\" , \"Ola 1\" ); // (1) fflush ( stdout ); /* The mutex MUST be given back! */ xSemaphoreGive ( xMutex ); vTaskDelay ( 100 ); } } void task2 () { while ( 1 ) { xSemaphoreTake ( xMutex , portMAX_DELAY ); printf ( \"%s\" , \"Ola 2\" ); // (2) fflush ( stdout ); xSemaphoreGive ( xMutex ); vTaskDelay ( 100 ); } } void main () { xMutex = xSemaphoreCreateMutex (); // .... } Regi\u00e3o cr\u00edtica de compartilhamento de recursos. Regi\u00e3o cr\u00edtica de compartilhamento de recursos. Tip Meio ruim ter que ficar utilizando o mutex toda hora que for realizar um printf, a solu\u00e7\u00e3o para isso \u00e9 encapsularmos em uma fun\u00e7\u00e3o o uso do mutex e usamos essa fun\u00e7\u00e3o no lugar do printf: void printfMutex ( char * s ) { xSemaphoreTake ( xMutex , portMAX_DELAY ); printf ( \"%s\" , pcString ); fflush ( stdout ); xSemaphoreGive ( xMutex ); } void task1 () { while ( 1 ) { printfMutex ( \"ol\u00e1 1\" ); vTaskDelay ( 100 ); } } void task2 () { while ( 1 ) { printfMutex ( \"ol\u00e1 2\" ); vTaskDelay ( 100 ); } }","title":"Exemplo"},{"location":"navigation/Labs/Lab_mutex/lab/#programando","text":"Agora vamos come\u00e7ar a programar, lembrem que a documenta\u00e7\u00e3o do LVGL fala que: If you need to use real tasks or threads, you need a mutex which should be invoked before the call of lv_timer_handler and released after it. . Como estamos no RTOS estamos usando a func\u00e3o lv_task_handler no lugar da lv_timer_handler . Task mutex lv_task_handler Crie a vari\u00e1vel global que ir\u00e1 servir de mutex chamado de xMutexLVGL do tipo SemaphoreHandle_t No main crie o mutex com xSemaphoreCreateMutex(); Na task_lcd fa\u00e7a a requisi\u00e7\u00e3o do mutex antes de chamar lv_tick_inc e a libera\u00e7\u00e3o depois do lv_task_handler Execute o c\u00f3digo e verifique que NADA DEVE TER MUDADO . Estamos apenas melhorando a qualidade do nosso c\u00f3digo e garantindo que n\u00e3o teremos erros futuros. Preencher ao finalizar o lab Carregando\u2026","title":"Programando"},{"location":"navigation/Labs/Lab_mutex/lab/#aps-2","text":"Este laborat\u00f3rio serve para ajudar voc\u00eas com a APS2, agora podem ter mais de uma task atualizando partes diferentes do LCD via LVGL, lembrem apenas de requisitar o mutex antes e liberar depois de terem usado.","title":"APS 2"},{"location":"navigation/Projeto/Projeto-1-Descricao/","text":"Projeto 1 Entregas Data Entrega 1: Idealiza\u00e7\u00e3o 17/9 Entrega 2: Prot\u00f3tipo 8/10 Video Pl\u00e1gio Voc\u00ea n\u00e3o pode copiar c\u00f3digo (parcial ou total) de outro grupo (do mesmo ou de outro semestre). Voc\u00ea pode usar qualquer c\u00f3digo fornecido pela equipe. C\u00f3digo da internet? Voc\u00ea n\u00e3o pode copiar grandes trechos. C\u00f3digo da internet? Se usou alguma coisa, referencie no README. A regra completa pode ser acessada em: https://www.insper.edu.br/portaldoaluno/wp-content/uploads/2018/08/orientacoes_integridade_intelectual-Engenharias.pdf Atraso Cada entrega possui uma penaliza\u00e7\u00e3o para o atraso, detalhes nas secc\u00f5es referentes as entregas. Dupla A APS pode ser realizada em dupla. Voc\u00ea n\u00e3o pode repetir a mesma dupla da APS1. O desenvolvimento do projeto deve ser feito no reposit\u00f3rio criado pelo classroom: - https://classroom.github.com/a/ouItgqe6 Leia atentamente como trabalhar no reposit\u00f3rio: APS HowTo O projeto de computa\u00e7\u00e3o Embarcada \u00e9 de escopo fechado e tem como principal objetivo fazer com que voc\u00eas passem por todo o ciclo de desenvolvimento de um prot\u00f3tipo de um dispositivo embarcado: especifica\u00e7\u00e3o implementa\u00e7\u00e3o problemas teste problemas finaliza\u00e7\u00e3o. Neste projeto voc\u00eas ter\u00e3o que criar um controle remoto bluetooth, controlado pelo kit de desenvolvimento usado na disciplina (SAME70-XPLD), com a adi\u00e7\u00e3o de um m\u00f3dulo externo bluetooth HC-05. A entrega do projeto deve ser um prot\u00f3tipo funcional, e deve possuir todas as funcionalidades esperadas de um controle remoto bluetooth (listado a seguir). Descri\u00e7\u00e3o O controle deve ser um dispositivo que permita controlar remotamente um programa (pode ser um jogo) que estar\u00e1 sendo executado em um PC e deve ser feito espec\u00edfico para a aplica\u00e7\u00e3o em quest\u00e3o. A interface do controle com o computador ser\u00e1 via bluetooth , um programa em python far\u00e1 a leitura e processamento dos dados. Caracter\u00edsticas principais: Ao menos 4 entradas digitais e uma anal\u00f3gica Deve fornecer feedback (ao menos duas sa\u00eddas digitais) ao usu\u00e1rio no pr\u00f3prio controle Interface via bluetooh Informa\u00e7\u00e3o de controle pareado Para ter ideias do que voc\u00ea pode fazer, consulte a pagina da disciplina com os projetos que j\u00e1 foram feitos nos outos semestres: https://insper.github.io/ComputacaoEmbarcada/navigation/Projeto/Projeto-1-Lista/ Al\u00e9m das ideas que j\u00e1 foram executadas, de uma olhada nos poss\u00edveis dispositivos que voc\u00ea pode usar no controle: https://insper.github.io/ComputacaoEmbarcada/navigation/Projeto/Projeto-1-Dispositivos/ RTOS O projeto deve ser realizando usando o sistema operacional freeRTOS. Entregas O projeto vai ter tr\u00eas entregas: Idealiza\u00e7\u00e3o e descri\u00e7\u00e3o do projeto (README) Estudo de usabilidade / design (README) Prot\u00f3tipo funcional (c\u00f3digo/ prot\u00f3tipo mec\u00e2nico) Cada entrega ter\u00e1 um peso diferente na composi\u00e7\u00e3o final da nota: Etapa Entrega Peso Idealiza\u00e7\u00e3o 1 10% Prot\u00f3tipo 2 90% Come\u00e7ando Vamos come\u00e7ar pensando um pouco no controle! Para isso, fa\u00e7a em dupla a atividade no mural, essa etapa j\u00e1 vai ajudar na entrega (1): https://app.mural.co/t/elementos9119/m/elementos9119/1662992049747/bf8d978481f9680d806e1a4f21f776a6bb6e57d6?sender=ub569a9273c6e285461187641","title":"Descri\u00e7\u00e3o"},{"location":"navigation/Projeto/Projeto-1-Descricao/#projeto-1","text":"Entregas Data Entrega 1: Idealiza\u00e7\u00e3o 17/9 Entrega 2: Prot\u00f3tipo 8/10 Video Pl\u00e1gio Voc\u00ea n\u00e3o pode copiar c\u00f3digo (parcial ou total) de outro grupo (do mesmo ou de outro semestre). Voc\u00ea pode usar qualquer c\u00f3digo fornecido pela equipe. C\u00f3digo da internet? Voc\u00ea n\u00e3o pode copiar grandes trechos. C\u00f3digo da internet? Se usou alguma coisa, referencie no README. A regra completa pode ser acessada em: https://www.insper.edu.br/portaldoaluno/wp-content/uploads/2018/08/orientacoes_integridade_intelectual-Engenharias.pdf Atraso Cada entrega possui uma penaliza\u00e7\u00e3o para o atraso, detalhes nas secc\u00f5es referentes as entregas. Dupla A APS pode ser realizada em dupla. Voc\u00ea n\u00e3o pode repetir a mesma dupla da APS1. O desenvolvimento do projeto deve ser feito no reposit\u00f3rio criado pelo classroom: - https://classroom.github.com/a/ouItgqe6 Leia atentamente como trabalhar no reposit\u00f3rio: APS HowTo O projeto de computa\u00e7\u00e3o Embarcada \u00e9 de escopo fechado e tem como principal objetivo fazer com que voc\u00eas passem por todo o ciclo de desenvolvimento de um prot\u00f3tipo de um dispositivo embarcado: especifica\u00e7\u00e3o implementa\u00e7\u00e3o problemas teste problemas finaliza\u00e7\u00e3o. Neste projeto voc\u00eas ter\u00e3o que criar um controle remoto bluetooth, controlado pelo kit de desenvolvimento usado na disciplina (SAME70-XPLD), com a adi\u00e7\u00e3o de um m\u00f3dulo externo bluetooth HC-05. A entrega do projeto deve ser um prot\u00f3tipo funcional, e deve possuir todas as funcionalidades esperadas de um controle remoto bluetooth (listado a seguir).","title":"Projeto 1"},{"location":"navigation/Projeto/Projeto-1-Descricao/#descricao","text":"O controle deve ser um dispositivo que permita controlar remotamente um programa (pode ser um jogo) que estar\u00e1 sendo executado em um PC e deve ser feito espec\u00edfico para a aplica\u00e7\u00e3o em quest\u00e3o. A interface do controle com o computador ser\u00e1 via bluetooth , um programa em python far\u00e1 a leitura e processamento dos dados. Caracter\u00edsticas principais: Ao menos 4 entradas digitais e uma anal\u00f3gica Deve fornecer feedback (ao menos duas sa\u00eddas digitais) ao usu\u00e1rio no pr\u00f3prio controle Interface via bluetooh Informa\u00e7\u00e3o de controle pareado Para ter ideias do que voc\u00ea pode fazer, consulte a pagina da disciplina com os projetos que j\u00e1 foram feitos nos outos semestres: https://insper.github.io/ComputacaoEmbarcada/navigation/Projeto/Projeto-1-Lista/ Al\u00e9m das ideas que j\u00e1 foram executadas, de uma olhada nos poss\u00edveis dispositivos que voc\u00ea pode usar no controle: https://insper.github.io/ComputacaoEmbarcada/navigation/Projeto/Projeto-1-Dispositivos/","title":"Descri\u00e7\u00e3o"},{"location":"navigation/Projeto/Projeto-1-Descricao/#rtos","text":"O projeto deve ser realizando usando o sistema operacional freeRTOS.","title":"RTOS"},{"location":"navigation/Projeto/Projeto-1-Descricao/#entregas","text":"O projeto vai ter tr\u00eas entregas: Idealiza\u00e7\u00e3o e descri\u00e7\u00e3o do projeto (README) Estudo de usabilidade / design (README) Prot\u00f3tipo funcional (c\u00f3digo/ prot\u00f3tipo mec\u00e2nico) Cada entrega ter\u00e1 um peso diferente na composi\u00e7\u00e3o final da nota: Etapa Entrega Peso Idealiza\u00e7\u00e3o 1 10% Prot\u00f3tipo 2 90%","title":"Entregas"},{"location":"navigation/Projeto/Projeto-1-Descricao/#comecando","text":"Vamos come\u00e7ar pensando um pouco no controle! Para isso, fa\u00e7a em dupla a atividade no mural, essa etapa j\u00e1 vai ajudar na entrega (1): https://app.mural.co/t/elementos9119/m/elementos9119/1662992049747/bf8d978481f9680d806e1a4f21f776a6bb6e57d6?sender=ub569a9273c6e285461187641","title":"Come\u00e7ando"},{"location":"navigation/Projeto/Projeto-1-Dicas/","text":"Dicas Dicas referente ao projeto 1 Comunica\u00e7\u00e3o PC (python) -> microcontrolador Umas das rubricas da entrega pede que o computador envie dados para o microcontrolador, esse envio \u00e9 feito da mesma maneira do recebimento dos dados, via a porta virtual COM gerado na comunica\u00e7\u00e3o com o bluetooth. python Para enviar um dado do python para a porta COM e ent\u00e3o para o bluetooth utilize a fun\u00e7\u00e3o self.ser.write() Tip Codifique em ASCII o dado a ser enviado pela serial em ASCII: 'hello'.encode('ascii') ou em byte: b'h' . microcontrolador Para receber um byte no firmware devemos usar a fun\u00e7\u00e3o usart_read(USART_COM, &rx) onde o primeiro par\u00e2metro \u00e9 a USART a ser lida e o segundo uma vari\u00e1vel para salvar o valor, a fun\u00e7\u00e3o retorna 0 caso tenha lido um byte, conforme descri\u00e7\u00e3o da documenta\u00e7\u00e3o a seguir: /** * \\brief Read from USART Receive Holding Register. * * \\note Before reading user should check if rx is ready. * * \\param p_usart Pointer to a USART instance. * \\param c Pointer where the one-byte received data will be stored. * * \\retval 0 on success. * \\retval 1 if no data is available or errors. */ uint32_t usart_read ( Usart * p_usart , uint32_t * c ) { .... } Para verificar se existe um byte a ser lido na USART utilize a fun\u00e7\u00e3o a seguir: /** * \\brief Check if the received data are ready. * Check if Data have been received and loaded into USART_RHR. * * \\param p_usart Pointer to a USART instance. * * \\retval 1 Some data has been received. * \\retval 0 No data has been received. */ uint32_t usart_is_rx_ready ( Usart * p_usart ) {...}","title":"Dicas"},{"location":"navigation/Projeto/Projeto-1-Dicas/#dicas","text":"Dicas referente ao projeto 1","title":"Dicas"},{"location":"navigation/Projeto/Projeto-1-Dicas/#comunicacao-pc-python-microcontrolador","text":"Umas das rubricas da entrega pede que o computador envie dados para o microcontrolador, esse envio \u00e9 feito da mesma maneira do recebimento dos dados, via a porta virtual COM gerado na comunica\u00e7\u00e3o com o bluetooth.","title":"Comunica\u00e7\u00e3o PC (python) -&gt; microcontrolador"},{"location":"navigation/Projeto/Projeto-1-Dicas/#python","text":"Para enviar um dado do python para a porta COM e ent\u00e3o para o bluetooth utilize a fun\u00e7\u00e3o self.ser.write() Tip Codifique em ASCII o dado a ser enviado pela serial em ASCII: 'hello'.encode('ascii') ou em byte: b'h' .","title":"python"},{"location":"navigation/Projeto/Projeto-1-Dicas/#microcontrolador","text":"Para receber um byte no firmware devemos usar a fun\u00e7\u00e3o usart_read(USART_COM, &rx) onde o primeiro par\u00e2metro \u00e9 a USART a ser lida e o segundo uma vari\u00e1vel para salvar o valor, a fun\u00e7\u00e3o retorna 0 caso tenha lido um byte, conforme descri\u00e7\u00e3o da documenta\u00e7\u00e3o a seguir: /** * \\brief Read from USART Receive Holding Register. * * \\note Before reading user should check if rx is ready. * * \\param p_usart Pointer to a USART instance. * \\param c Pointer where the one-byte received data will be stored. * * \\retval 0 on success. * \\retval 1 if no data is available or errors. */ uint32_t usart_read ( Usart * p_usart , uint32_t * c ) { .... } Para verificar se existe um byte a ser lido na USART utilize a fun\u00e7\u00e3o a seguir: /** * \\brief Check if the received data are ready. * Check if Data have been received and loaded into USART_RHR. * * \\param p_usart Pointer to a USART instance. * * \\retval 1 Some data has been received. * \\retval 0 No data has been received. */ uint32_t usart_is_rx_ready ( Usart * p_usart ) {...}","title":"microcontrolador"},{"location":"navigation/Projeto/Projeto-1-Dispositivos/","text":"Dispositivos A seguir uma pequena curadoria de dispositivos que podem ser utilizado nessa entrega, no laborat\u00f3rio temos muitas outras op\u00e7\u00f5es. Digitais Nome Tipo Imagem Detalhes push buttons input V\u00e1rias opc\u00f5es de tamanho e de cores Teclado Matricial input https://www.filipeflop.com/blog/teclado-matricial-4x4-arduino/ Joystick arcade input S\u00e3o quatro bot\u00f5es um em cada canto. https://www.filipeflop.com/produto/kit-fliperama-arcade-com-joystick-e-botoes/ reed switch input Sensor magn\u00e9tico Rugged Metal Pushbutton input / output \u00c9 um bot\u00e3o com LED, ent\u00e3o conta como uma entrada e uma sa\u00edda. https://www.adafruit.com/product/560 Mini illuminated pushbutton input / output Similar ao Rugged Metal. https://www.adafruit.com/product/3105 LED output Leds de diferentes cores ou RGB Fita de LED output Fita de LED endere\u00e7\u00e1vel ou n\u00e3o Buzzer output Vibracall output Motor de vibra\u00e7\u00e3o Motores diversos output Servo motor/ passo/ DC/ .. Anal\u00f3gicos Nome Tipo Imagem Detalhes Joypad input Anal\u00f3gico X, Y e bot\u00e3o de pressionado, temos de v\u00e1rios formatos. Potenci\u00f4metro input Potenciometro de diversos formatos Microfone input Microfone MyoWare - Sensor muscular input Sensor muscular - https://www.sparkfun.com/products/13723 Strain Gauge input Extens\u00f4metro Potenciometro Motorizado input/output Potenci\u00f4metro por\u00e9m com motor (para fazer tipo mesa de som) Extras Alguns dispositivos que n\u00e3o s\u00e3o considerados \"digitais\" como 1 ou 0 e nem anal\u00f3gicos. Voc\u00ea pode substituir uma entrada anal\u00f3gica por um m\u00f3dulo desta lista. Nome Tipo Imagem Detalhes IMU MCU6050 input Aceler\u00f4metro e girosc\u00f3pio. https://www.robocore.net/sensor-robo/acelerometro-e-giroscopio-mpu6050 Qwiic Flex Glove input M\u00f3dulo com dois strain grage para ser usado nos dedos. https://learn.sparkfun.com/tutorials/qwiic-flex-glove-controller-hookup-guide/all :w","title":"Dispositivos"},{"location":"navigation/Projeto/Projeto-1-Dispositivos/#dispositivos","text":"A seguir uma pequena curadoria de dispositivos que podem ser utilizado nessa entrega, no laborat\u00f3rio temos muitas outras op\u00e7\u00f5es.","title":"Dispositivos"},{"location":"navigation/Projeto/Projeto-1-Dispositivos/#digitais","text":"Nome Tipo Imagem Detalhes push buttons input V\u00e1rias opc\u00f5es de tamanho e de cores Teclado Matricial input https://www.filipeflop.com/blog/teclado-matricial-4x4-arduino/ Joystick arcade input S\u00e3o quatro bot\u00f5es um em cada canto. https://www.filipeflop.com/produto/kit-fliperama-arcade-com-joystick-e-botoes/ reed switch input Sensor magn\u00e9tico Rugged Metal Pushbutton input / output \u00c9 um bot\u00e3o com LED, ent\u00e3o conta como uma entrada e uma sa\u00edda. https://www.adafruit.com/product/560 Mini illuminated pushbutton input / output Similar ao Rugged Metal. https://www.adafruit.com/product/3105 LED output Leds de diferentes cores ou RGB Fita de LED output Fita de LED endere\u00e7\u00e1vel ou n\u00e3o Buzzer output Vibracall output Motor de vibra\u00e7\u00e3o Motores diversos output Servo motor/ passo/ DC/ ..","title":"Digitais"},{"location":"navigation/Projeto/Projeto-1-Dispositivos/#analogicos","text":"Nome Tipo Imagem Detalhes Joypad input Anal\u00f3gico X, Y e bot\u00e3o de pressionado, temos de v\u00e1rios formatos. Potenci\u00f4metro input Potenciometro de diversos formatos Microfone input Microfone MyoWare - Sensor muscular input Sensor muscular - https://www.sparkfun.com/products/13723 Strain Gauge input Extens\u00f4metro Potenciometro Motorizado input/output Potenci\u00f4metro por\u00e9m com motor (para fazer tipo mesa de som)","title":"Anal\u00f3gicos"},{"location":"navigation/Projeto/Projeto-1-Dispositivos/#extras","text":"Alguns dispositivos que n\u00e3o s\u00e3o considerados \"digitais\" como 1 ou 0 e nem anal\u00f3gicos. Voc\u00ea pode substituir uma entrada anal\u00f3gica por um m\u00f3dulo desta lista. Nome Tipo Imagem Detalhes IMU MCU6050 input Aceler\u00f4metro e girosc\u00f3pio. https://www.robocore.net/sensor-robo/acelerometro-e-giroscopio-mpu6050 Qwiic Flex Glove input M\u00f3dulo com dois strain grage para ser usado nos dedos. https://learn.sparkfun.com/tutorials/qwiic-flex-glove-controller-hookup-guide/all :w","title":"Extras"},{"location":"navigation/Projeto/Projeto-1-Entrega1/","text":"Entrega 1 data entrega 17/9 Essa entrega representa 10% da nota final do projeto. Se entregar atrasado, nota fica em 5%. Pontos de cada item: Item Pontos Jornada do usu\u00e1rio 3 pts Comandos/ Feedback 2 pts In/ Out 3 pts Design 2 pts Nessa etapa voc\u00eas devem entregar o README do projeto com uma descri\u00e7\u00e3o detalhada da ideia do projeto de voc\u00eas. N\u00e3o fa\u00e7am de qualquer jeito, queremos capricho e um pouco de dedica\u00e7\u00e3o. A ideia aqui \u00e9 voc\u00eas pensarem no software que v\u00e3o controlar e o como um controle poderia funcionar com ele. Acontece que normalmente os softwares n\u00e3o foram pensados para serem utilizadas com um controle remoto, ou fora da interface de um computador/ celular. Voc\u00eas ter\u00e3o que fazer a adequa\u00e7\u00e3o. Info O README do projeto de voc\u00eas j\u00e1 possui o template, basta adicionar as informa\u00e7\u00f5es. Tip O README deve ser resultado do que foi planejado no Mural. Ideia Descreva aqui em poucas palavras qual a ideia do seu controle. Se ele vai ser de jogo ou de aplica\u00e7\u00e3o Nome De um nome ao seu controle! A ideia \u00e9 voc\u00eas se apropriarem dele. Usu\u00e1rios Descreva aqui quem seriam os poss\u00edveis usu\u00e1rios deste controle. Software/Jogo Qual software que seu controle vai controlar? Jornada do usu\u00e1rios (3 pts) Descreva ao menos duas jornadas de usu\u00e1rios distintos, \u00e9 para caprichar! Comandos/ Feedbacks (2 pts) Quais s\u00e3o os comandos/ opera\u00e7\u00f5es poss\u00edveis do seu controle? Quais os feedbacks que seu controle vai fornecer ao usu\u00e1rio? In/OUT (3 pts) Para cada Comando/ Feedback do seu controle, associei qual sensores/ atuadores pretende utilizar? Faca em formato de lista Exemplo: Avanca m\u00fasica: Push button amarelo Racional: Como avan\u00e7ar \u00e9 uma ac\u00e3o bin\u00e1ria, esse bot\u00e3o resolve. Se o usu\u00e1rio manter o bot\u00e3o pressionado o personagem continua com a acao de avan\u00e7ar. Volume da m\u00fasica: Fita de LED indicando pot\u00eancia do som Racional: Queremos fornece ao usu\u00e1rio um feedback do volume do som e deixar o controle com um ar moderno, a fita de LED pode ser embutida dentro do controle. Design (2 pts) Faca um esboco de como seria esse controle (vai ter uma etapa que ter\u00e3o que detalhar melhor isso).","title":"Entrega 1"},{"location":"navigation/Projeto/Projeto-1-Entrega1/#entrega-1","text":"data entrega 17/9 Essa entrega representa 10% da nota final do projeto. Se entregar atrasado, nota fica em 5%. Pontos de cada item: Item Pontos Jornada do usu\u00e1rio 3 pts Comandos/ Feedback 2 pts In/ Out 3 pts Design 2 pts Nessa etapa voc\u00eas devem entregar o README do projeto com uma descri\u00e7\u00e3o detalhada da ideia do projeto de voc\u00eas. N\u00e3o fa\u00e7am de qualquer jeito, queremos capricho e um pouco de dedica\u00e7\u00e3o. A ideia aqui \u00e9 voc\u00eas pensarem no software que v\u00e3o controlar e o como um controle poderia funcionar com ele. Acontece que normalmente os softwares n\u00e3o foram pensados para serem utilizadas com um controle remoto, ou fora da interface de um computador/ celular. Voc\u00eas ter\u00e3o que fazer a adequa\u00e7\u00e3o. Info O README do projeto de voc\u00eas j\u00e1 possui o template, basta adicionar as informa\u00e7\u00f5es. Tip O README deve ser resultado do que foi planejado no Mural.","title":"Entrega 1"},{"location":"navigation/Projeto/Projeto-1-Entrega1/#ideia","text":"Descreva aqui em poucas palavras qual a ideia do seu controle. Se ele vai ser de jogo ou de aplica\u00e7\u00e3o","title":"Ideia"},{"location":"navigation/Projeto/Projeto-1-Entrega1/#nome","text":"De um nome ao seu controle! A ideia \u00e9 voc\u00eas se apropriarem dele.","title":"Nome"},{"location":"navigation/Projeto/Projeto-1-Entrega1/#usuarios","text":"Descreva aqui quem seriam os poss\u00edveis usu\u00e1rios deste controle.","title":"Usu\u00e1rios"},{"location":"navigation/Projeto/Projeto-1-Entrega1/#softwarejogo","text":"Qual software que seu controle vai controlar?","title":"Software/Jogo"},{"location":"navigation/Projeto/Projeto-1-Entrega1/#jornada-do-usuarios-3-pts","text":"Descreva ao menos duas jornadas de usu\u00e1rios distintos, \u00e9 para caprichar!","title":"Jornada do usu\u00e1rios (3 pts)"},{"location":"navigation/Projeto/Projeto-1-Entrega1/#comandos-feedbacks-2-pts","text":"Quais s\u00e3o os comandos/ opera\u00e7\u00f5es poss\u00edveis do seu controle? Quais os feedbacks que seu controle vai fornecer ao usu\u00e1rio?","title":"Comandos/ Feedbacks (2 pts)"},{"location":"navigation/Projeto/Projeto-1-Entrega1/#inout-3-pts","text":"Para cada Comando/ Feedback do seu controle, associei qual sensores/ atuadores pretende utilizar? Faca em formato de lista Exemplo: Avanca m\u00fasica: Push button amarelo Racional: Como avan\u00e7ar \u00e9 uma ac\u00e3o bin\u00e1ria, esse bot\u00e3o resolve. Se o usu\u00e1rio manter o bot\u00e3o pressionado o personagem continua com a acao de avan\u00e7ar. Volume da m\u00fasica: Fita de LED indicando pot\u00eancia do som Racional: Queremos fornece ao usu\u00e1rio um feedback do volume do som e deixar o controle com um ar moderno, a fita de LED pode ser embutida dentro do controle.","title":"In/OUT (3 pts)"},{"location":"navigation/Projeto/Projeto-1-Entrega1/#design-2-pts","text":"Faca um esboco de como seria esse controle (vai ter uma etapa que ter\u00e3o que detalhar melhor isso).","title":"Design (2 pts)"},{"location":"navigation/Projeto/Projeto-1-Entrega3/","text":"Entrega 2 Tip Ao terminar preencha o forms a seguir: https://forms.gle/kSsmELV2Ty5DRD3SA Loading\u2026 A rubrica a seguir ser\u00e1 aplicada para gerar a nota final: Info Para atingir conceito maior que C sera necess\u00e1rio fechar as issues criadas ap\u00f3s a entrega (qualidade de c\u00f3digo) A+ Testa controle com pessoa externa ao projeto (filma intera\u00e7\u00e3o) A (cada item = meio conceito) Possibilita usu\u00e1rio Ligar e Desligar controle (sleep mode) Deve ajustar o python para reconhecer quando o controle ligar novamente Programa em python envia informa\u00e7\u00f5es ao controle e isso \u00e9 exibido ao usu\u00e1rio. B Grupo cria um primeiro prot\u00f3tipo conceitual mec\u00e2nico para o controle (pode usar papel\u00e3o, massinha, modelo cad 3d, ...), n\u00e3o precisa ligar a parte el\u00e9trica ao mec\u00e2nico, \u00e9 s\u00f3 para termos uma ideia de como seria. Cria uma task dedicada para receber e processar dados da comunica\u00e7\u00e3o (computador \u2192 uC). Info A ideia aqui \u00e9 que o PC se comunique com o uC, para isso voc\u00eas podem usar a func\u00e3o self.ser.write() que ir\u00e1 enviar um char para o bluetooth e por consequ\u00eancia para o uC. No uC voc\u00ea pode ler esse dado usando: char status = usart_read(USART_COM, &readChar); Se status for 1 isso indica que um dado v\u00e1lido foi salvo em readChar . Nessa comunica\u00e7\u00e3o voc\u00eas podem mandar qualquer coisa, j\u00e1 teve um grupo que enviou o nome da m\u00fasica do spotify que estava sendo tocada e exibiu a m\u00fasica no OELD. N\u00e3o precisa ser algo t\u00e3o complexo, podem enviar apenas um housekeeping da comunica\u00e7\u00e3o ou um ACK do recebimento do comando. C+ No lugar de v\u00e1rios sem\u00e1foros usa uma \u00fanica fila para comunicar IRQ com task_bluetooth . C Controle desenvolvido para aplica\u00e7\u00e3o espec\u00edfica. Utiliza interrup\u00e7\u00e3o nos bot\u00f5es. Possuir quatro entradas digitais (bot\u00f5es). Uma entrada anal\u00f3gica. 2x Feedbacks ao usu\u00e1rio: um de uso geral outro deve indicar ao usu\u00e1rio o controle est\u00e1 pronto para uso (software PC reconhece controle, precisa de hand shake aqui). Comunica\u00e7\u00e3o com o computador (bluetooth/ USB-UART). Faz uso de RTOS Grava v\u00eddeo de uso","title":"Entrega 2"},{"location":"navigation/Projeto/Projeto-1-Entrega3/#entrega-2","text":"Tip Ao terminar preencha o forms a seguir: https://forms.gle/kSsmELV2Ty5DRD3SA Loading\u2026 A rubrica a seguir ser\u00e1 aplicada para gerar a nota final: Info Para atingir conceito maior que C sera necess\u00e1rio fechar as issues criadas ap\u00f3s a entrega (qualidade de c\u00f3digo) A+ Testa controle com pessoa externa ao projeto (filma intera\u00e7\u00e3o) A (cada item = meio conceito) Possibilita usu\u00e1rio Ligar e Desligar controle (sleep mode) Deve ajustar o python para reconhecer quando o controle ligar novamente Programa em python envia informa\u00e7\u00f5es ao controle e isso \u00e9 exibido ao usu\u00e1rio. B Grupo cria um primeiro prot\u00f3tipo conceitual mec\u00e2nico para o controle (pode usar papel\u00e3o, massinha, modelo cad 3d, ...), n\u00e3o precisa ligar a parte el\u00e9trica ao mec\u00e2nico, \u00e9 s\u00f3 para termos uma ideia de como seria. Cria uma task dedicada para receber e processar dados da comunica\u00e7\u00e3o (computador \u2192 uC). Info A ideia aqui \u00e9 que o PC se comunique com o uC, para isso voc\u00eas podem usar a func\u00e3o self.ser.write() que ir\u00e1 enviar um char para o bluetooth e por consequ\u00eancia para o uC. No uC voc\u00ea pode ler esse dado usando: char status = usart_read(USART_COM, &readChar); Se status for 1 isso indica que um dado v\u00e1lido foi salvo em readChar . Nessa comunica\u00e7\u00e3o voc\u00eas podem mandar qualquer coisa, j\u00e1 teve um grupo que enviou o nome da m\u00fasica do spotify que estava sendo tocada e exibiu a m\u00fasica no OELD. N\u00e3o precisa ser algo t\u00e3o complexo, podem enviar apenas um housekeeping da comunica\u00e7\u00e3o ou um ACK do recebimento do comando. C+ No lugar de v\u00e1rios sem\u00e1foros usa uma \u00fanica fila para comunicar IRQ com task_bluetooth . C Controle desenvolvido para aplica\u00e7\u00e3o espec\u00edfica. Utiliza interrup\u00e7\u00e3o nos bot\u00f5es. Possuir quatro entradas digitais (bot\u00f5es). Uma entrada anal\u00f3gica. 2x Feedbacks ao usu\u00e1rio: um de uso geral outro deve indicar ao usu\u00e1rio o controle est\u00e1 pronto para uso (software PC reconhece controle, precisa de hand shake aqui). Comunica\u00e7\u00e3o com o computador (bluetooth/ USB-UART). Faz uso de RTOS Grava v\u00eddeo de uso","title":"Entrega 2"},{"location":"navigation/Projeto/Projeto-1-Lista/","text":"Anos passados 2022-a Integrantes Descri\u00e7\u00e3o V\u00eddeo CESAR EZRA ADES;KEIYA NISHIO Nosso projeto \u00e9 um controle para youtube, com diversas funcionalidades, sendo elas: Ligar o controle, Mute, Pause/Play, Full screen, Passa/Volta o tempo(10 seg), Passa o para o pr\u00f3ximo v\u00eddeo Ele foi feito para que os usu\u00e1rios possam controlar o youtube remotamente, deitados em suas camas e sof\u00e1s sem ter o trabalho de se mover. Ao abrir nosso reposit\u00f3rio poder\u00e1 encontrar mais informa\u00e7\u00f5es sobre nosso projeto. https://www.youtube.com/watch?v=UQKn9XYL6Q0&t=1s BRUNO FREITAS DO NASCIMENTO RODRIGUES;NICOLAS BYUNG KWAN CHO Contralar um jogo com ativa\u00e7\u00e3o por som https://youtu.be/lWeQFMWuBXA CAROLINA HIRSCHHEIMER;PAULO WOOK KIM Fizemos um teclado matricial com um controle de volume. Ao apertar as teclas do teclado matricial, s\u00e3o emuladas as teclas como um numpad, conforme descrito no readme.md. Al\u00e9m disso, usamos um potenci\u00f4metro como controle de volume. Tamb\u00e9m temos uma resposta do LED quando recebe o handshake \u00e9 feito. https://youtu.be/eSaDR4vKHcA RODRIGO NIGRI GRINER;NAT\u00c1LIA QUEIROZ MENEZES CARRERAS A nossa ideia consiste em fazer uma mesa de efeitos especiais (sonoros e luminosos) para enfeitar a casa na \u00e9poca de Halloween. https://drive.google.com/file/d/134OgbOIbWBsuOg77UYchF803UxvCDvJB/view?usp=sharing HENRIQUE MARTINELLI FREZZATTI;L\u00cdVIA SAYURI MAKUTA O projeto simula um controle de PS4 com os quatro bot\u00f5es de uso (Quadrado, tri\u00e2ngulo, X e bola) e os dois anal\u00f3gicos, tanto o da esquerda para movimenta\u00e7\u00e3o geral, como o da direita para mover a c\u00e2mera nos jogos. Tendo em vista esse intuito, constru\u00edmos esse controle para test\u00e1-lo em jogos e verificar sua funcionalidade. https://youtu.be/MFPypHldZAY JOS\u00c9 RAFAEL MARTINS FERNANDES;LUCCA BARUFATTI VELINI SANCHES O projeto \u00e9 um controle bluetooth para o jogo que n\u00f3s desenvolvemos na disciplina de Design de Software, o Foxer. O controle tem 4 bot\u00f5es que emulam as setas do teclado e um potenci\u00f4metro respons\u00e1vel por aumentar e diminuir o volume do computador. Al\u00e9m disso, existem 2 leds, 1 indicando que o handshake foi feito e o controle est\u00e1 pronto para uso e outro respons\u00e1vel por avisar ao usu\u00e1rio que o PC est\u00e1 mutado. Por fim, existe um buzzer que emite um som toda vez que um bot\u00e3o \u00e9 apertado. https://youtu.be/j4WElf03OTk FRANCISCO AUGUSTO BUZOLIN VASCONCELLOS DA COSTA;FERNANDO PERES MARQUES GAMEIRO FRAN\u00c7A Controlador para o aplicativo Spotify. O diferencial do projeto \u00e9 o fato do controle interagir com a API do software e n\u00e3o com o software em si. Isso permite que o usu\u00e1rio possa controlar seu player do Spotify em qualquer dispositivo. https://youtu.be/_FJskPKnLcA RODRIGO GUIMAR\u00c3ES COELHO;RAPHAEL LAHIRY CABILIO MAMMANA DE BARROS O objetivo do nosso projeto era criar um controle de pinball online, mais especificamente para esse site: http://letsplay.ouigo.com/ . Nosso controle possui dois controles para os dois lados do batedor no jogo e um sensor de press\u00e3o que \u00e9 respons\u00e1vel por lan\u00e7ar a bola. Quanto mais for\u00e7a no sensor mais forte a bola \u00e9 lan\u00e7ada. Al\u00e9m disso, temos 2 indicadores para o usu\u00e1rio. Um deles para mostrar que o handshake foi feito e outro para mostrar o quanto de for\u00e7a foi aplicada no sensor de press\u00e3o numa escala de 0 a 10. https://www.youtube.com/watch?v=vKhJ2k98Hrs Davi Reis Vieira de Souza;GUILHERME ROSADA Controlador de Multim\u00eddia para o Spotify. Destinado para pessoas que queiram controlar sua m\u00fasica sem estar pr\u00f3xima do PC ou que queiram dar esse poder a terceiros, como filhos, por exemplo. https://youtu.be/tVuRww94FWc FABRICIO NERI LIMA;JEAN SILAS FERREIRA SANANDREZ A ideia consiste em criar um controle para o jogo CS (Counter Strike). Por meio de sistemas embarcados, pretendemos criar um controle mais imersivo, em que o jogador n\u00e3o precisa do teclado para jogar, podendo atirar, agachar, trocar de arma, e se locomover atrav\u00e9s do novo controle. https://www.youtube.com/watch?v=3tfhDoeAuwk ARTHUR GOMES CHIEPPE;VINICIUS GRANDO ELLER O projeto consiste em um controle para o jogo Golf It!. Usamos o potenci\u00f4metro para controlar a tacada, o encoder para ajustar a dire\u00e7\u00e3o e bot\u00f5es para usos diversos. https://youtu.be/MCCGAc4vXvg RAFAEL EVANGELISTA MONTEIRO;ESTHER GALLO DAGIR Esse projeto \u00e9 um controle bluetooth para o Spotify e tem as seguintes funcionalidades: 4 Bot\u00f5es: 1 de play/pause, 1 de avan\u00e7ar, 1 de retornar e 1 de shuffle 1 Potenciometro para mudar o volume 1 led para sinalizar quando est\u00e1 no mudo 1 buzzer para sinalizar que o controle est\u00e1 funcionando (fez o handshake) https://www.youtube.com/watch?v=scw-tIG19hs FRANCISCO PINHEIRO JANELA;NICOLAS MACIEL QUEIROGA O projeto foi desenvolvido para criar um controle bluetooth para o rob\u00f4 turtlebot, capaz de controlar a dire\u00e7\u00e3o e receber feedback de dist\u00e2ncia. https://youtu.be/vy48HiP2h_8 LUCA COUTINHO MEL\u00c3O;PAULO SOUZA CHADE A nossa aplica\u00e7\u00e3o consiste em um programa que recebe uma melodia e consegue traduzir isso para os pinos que devem ser tocados. No caso, tais pinos correspondem \u00e0s teclas de um piano, os quais v\u00e3o acender um LED no tempo em que devem ser tocados. https://youtu.be/_KdAMJ1dxks GUILHERME CARNEIRO LUNETTA;JOAO ZSIGMOND O nosso controle serve para jogar Counter Strike, um jogo famoso no computador. Utiliza alguns bot\u00f5es e tem os feedbacks com LED e Buzzer. https://youtu.be/Y3TvsveXXT0 JO\u00c3O VITOR MENEZES DE MAGALH\u00c3ES;FELIPE BANZATO PINTO DE LEMOS Nosso projeto \u00e9 um controle utilizado para mexer no youtube https://drive.google.com/file/d/13C9wXUb-MhIjcAD1htUl9d2xwCZRJF8B/view?usp=sharing JAMESSON LEANDRO PAIVA SANTOS;IVAN DE ALCANTARA BARBOSA BARROS O projeto consiste em um controle bluetooth voltado para gamers de jogos de guerra de avi\u00e3o. https://youtu.be/fmUkZNA9ECc ANA CAROLINA LEAL GARCIA DE SOUZA;JO\u00c3O PEDRO FARIAS DE ARAUJO Um controle via VJoy para jogar Tennis no Wii Sports emulado no computador https://youtu.be/hSnb8Q8nyII CAROLINE CHAIM DE LIMA CARNEIRO;TIAGO VITORINO SEIXAS Um controle para jogar PokeMMO, um emulador multiplayer de pokemon cl\u00e1ssico (Nintendo DS e Game Boy) para computador https://www.youtube.com/watch?v=apzu8N4fvoo BERNARDO CUNHA CAPOFERRI;GUILHERME DANTAS RAMEH Um MPU que controla o pitch e roll de um avi\u00e3o de um jogo, com um flex\u00f4metro que controla a acelera\u00e7\u00e3o e desacelera\u00e7\u00e3o, quatro bot\u00f5es para simular um gamepad. https://youtu.be/ggW0K9r1OmY LUIZA VALEZIM AUGUSTO PINTO;ELLEN BEATRIZ SHEN O BlueTiles \u00e9 um teclado bluetooth que, com apenas uma oitava, permite de voc\u00ea tocar piano. Ele possui 13 boto\u00f5es (contando com o de desligar e ligar), al\u00e9m do mixer de volume anal\u00f3gico. https://photos.app.goo.gl/qG2aSzBmn8NUd6JP7 BRUNO BOLDRIM SABOYA;MATHEUS KWON Nosso projeto serve para aqueles aspirantes em m\u00fasica e Dj, ele serve como um LaunchPad que simula o teclado do nosso aplicativo para tocarmos as musicas ou samples, ou os beats. Sua portabilidade e praticidade facilita a vida daqueles que estejam sempre em movimentam e n\u00e3o podem levar todos os equipamentos que eles tenham. https://youtu.be/QAn-dmwzwRM 2021-a Integrantes Descri\u00e7\u00e3o andrevt1@al.insper.edu.br antoniovf@al.insper.edu.br Nosso projeto \u00e9 um controle de spotify, onde \u00e9 poss\u00edvel pausar, pular, voltar uma m\u00fasica, al\u00e9m de colocar no aleatorio. Tamb\u00e9m \u00e9 poss\u00edvel diminuir o volume com o potenciometro. Existem 2 feedbacks no controle, o primeiro para mostrar que ele esta funcionando, e o segundo para mostrar que a musica esta tocando https://youtu.be/S1r84FI3KBc carlosed3@al.insper.edu.br joaopga1@al.insper.edu.br Streamer Deck abre e controla Spotify e discord https://drive.google.com/file/d/1kfur3mRJsDKVAodVRDUrgFhxTD39MrOp/view?usp=sharing fernandocfbf@al.insper.edu.br laisns@al.insper.edu.br \u00c9 um controle que simula teclas do computador, especificamente para jogar mario forever, um jogo 2D da franquia Mario Bros https://drive.google.com/file/d/1Hqs_8FaSw8498iqNCPvv2qaeIVWyDXeG/view gabrielamb2@al.insper.edu.br theobr@al.insper.edu.br O projeto \u00e9 um controle pra quando voc\u00ea estiver deitado ou longe do computador voc\u00ea poder avancar, pausar, voltar, e navegar pelo netflix. https://drive.google.com/drive/folders/1rrGf4iEp__eRmZ5b_8DClmLhRHW1VDCK?usp=sharing edgardaon@al.insper.edu.br edgardaon@al.insper.edu.br O meu projeto \u00e9 um controle remoto para youtube, que pode controlar comandos como avan\u00e7ar 10 sec, voltar 10 sec, pausar/play, \"mutar\" e controlar o volume. https://drive.google.com/file/d/1uTgitwNWOPgxl38o9NRJORxXXD4T1KzW/view?usp=sharing manuelc@al.insper.edu.br andrebr@al.insper.edu.br O projeto serve como um controle para o jogo Pokemon. Os bot\u00f5es representam os bot\u00f5es do gameboy tradicional. O joystick \u00e9 utilizado para substituir as setinhas do gameboy. Assim, \u00e9 poss\u00edvel usar esse controle para jogar Pokemon no emulador, de uma maneira mais confort\u00e1vel. O controle tamb\u00e9m tem sinais que indicam quando o handshake j\u00e1 aconteceu e tamb\u00e9m um sinal para quando algum bot\u00e3o \u00e9 apertado. https://youtu.be/Y8Mk-5F9A5M beatrizrb@al.insper.edu.br joaogcfa@al.insper.edu.br Para controlar um filme que est\u00e1 passando na netflix, aumentando o volume do computador, fazendo ele adiantar 10s, voltar 10s, pausar e ficar em full screen. https://drive.google.com/file/d/1zT3H6ElKJmXK1VDe5W1cP9J_WdPgVJEF/view?usp=sharing marcompp@al.insper.edu.br gabrielaym@al.insper.edu.br Controle para jogos com quatro bot\u00f5es na placa e joystick anal\u00f3gico. Manda os inputs da placa para o computador atravez do bluetooth. O computador recebe e coloca o comando no vjoy. https://user-images.githubusercontent.com/49621844/116785879-4543d880-aa72-11eb-8608-d7a31734fa36.mp4 lucaskf@al.insper.edu.br lucaskf@al.insper.edu.br controle para jogar mario kart (funciona para a maioria dos titulos) https://drive.google.com/file/d/1zDWovRPSyZkq9ojfmIOqJn2uUqmInrfc/view?usp=sharing arthurfc2@al.insper.edu.br victorvaac@al.insper.edu.br Controle para tinder https://youtu.be/WOtw07sDUcE luisfml@al.insper.edu.br luisfsc@al.insper.edu.br Nosso projeto consiste em um controle para o Netflix. Assim o usu\u00e1rio poder\u00e1 mutar, avan\u00e7ar/retornar, aumentar/diminuir volume, pausar/iniciar o filme por meio do controle bluetooth. \u00c9 crescente o acesso ao Netflix por meio de laptop/PC em detrimento da televis\u00e3o, assim, criamos um controle que deixa mais c\u00f4modo para o usu\u00e1rio realizar alguma a\u00e7\u00e3o na aplica\u00e7\u00e3o. https://drive.google.com/file/d/1nZ7k6wScidorKgvy9_6jWWmS4qFRsXmu/view?usp=sharing gabriellaec@al.insper.edu.br gabriellaec@al.insper.edu.br Controle para Spotify. Pode ser usado para atividades ao ar livre ou indoors. O usu\u00e1rio pode selecionar as m\u00fasicas (next, previous), dar play/pause, controlar o volume e ver o nome da m\u00fasica na tela https://drive.google.com/file/d/1a_VB78qZptOJtcHlvJKCefFXe7hSUKM6/view?usp=sharing anaccf5@al.insper.edu.br matheusfs2@al.insper.edu.br O projeto simula 4 teclas de um teclado e tamb\u00e9m possibilita que se mude o volume por meio de um potenci\u00f4metro. Ele foi feito pensando na Netflix, mas tamb\u00e9m \u00e9 poss\u00edvel us\u00e1-lo no Youtube por exemplo. Por ser Bluetooth, \u00e9 legal que conseguimos usar ele enquanto deitado na cama, sem precisar ficar levantando para mexer no teclado (para quem v\u00ea Netflix no Note, que \u00e9 o meu caso :) ). https://drive.google.com/file/d/1c-v-JKd7TPEW6tCwFvmUv1Fmi8MrmOCf/view?usp=sharing marcelocm8@al.insper.edu.br eikily@al.insper.edu.br O nosso projeto foi feito para o Game Boy Advanced (GBA), um videogame port\u00e1til que muitos de n\u00f3s quando crian\u00e7a costumavam jogar. A \u00fanica diferen\u00e7a est\u00e1 nos bot\u00f5es, onde foi trocado as setas do GBA pelo anal\u00f3gico. O bot\u00e3o do microchip desliga o controle e os 3 bot\u00f5es do oled mais o anal\u00f3gico s\u00e3o para o GBA. https://drive.google.com/file/d/1F8L-5CndQH_tv9GsXUg2ffL10yzaO8ez/view?usp=sharing thalials@al.insper.edu.br williamars@al.insper.edu.br \u00c9 um controle de Spotify, que tem 5 bot\u00f5es digitais - pause/play, voltar m\u00fasica, passar m\u00fasica, desligar/ligar controle e fechar aplicativo. Al\u00e9m disso, tem-se um potenci\u00f4metro, que controla o volume do aplicativo. https://youtu.be/yAgvNxoVyQY henriquert@al.insper.edu.br victoran@al.insper.edu.br O projeto serve para o usuario poder controlar seu spotify pelo controle. Muitas vezes conectamos o computador na caixa de som em uma festa, porem ficar indo ate o computador \u00e9 muitas vezes cansativo. Para isso, o usuario agora pode controlar a musica de qualquer lugar da festa. Podendo pular, voltar, pausar, dar mute ou mudar o volume. https://drive.google.com/file/d/1f2u5uk4MmlBQwN7ZCqfsWvSLBX3D3PXu/view?usp=sharing henriquemm3@al.insper.edu.br henriquemm3@al.insper.edu.br Controlar a distancia a netflix e outros programas possivelmente j\u00e1 que vc tem um mouse! https://youtu.be/FiB4-OAT5q8 gabrielmk@al.insper.edu.br murilolcm@al.insper.edu.br O objetivo do nosso projeto era fazer um controle para Counter Strike, que permitisse o jogador a conduzir uma sess\u00e3o de treino. Para isso, fizemos quatro bot\u00f5es (atirar, recarregar, pular, e agachar), e um joystick que permita o movimento b\u00e1sico do jogador. Dessa forma, conseguimos fazer uma sess\u00e3o de pr\u00e1tica com feedback ao usu\u00e1rio, ao que o LED da placa pisca quando a arma est\u00e1 recarregando, e para de piscar quando o jogador pode atirar de novo. Al\u00e9m disso, fizemos o handshake para indicar que o controle est\u00e1 pronto para uso. https://drive.google.com/file/d/1OEcru01oLmWyqU2K_WWS6g8ndwnVfwtG/view?usp=sharing rafaella2@al.insper.edu.br giovannicps@al.insper.edu.br Um controle de netflix para utilizar enquanto esta sentado no sofa com o laptop ligado na tv para fun\u00e7oes simples de controle de midia. https://youtu.be/eedJblbAScE beatrizmcs@al.insper.edu.br sophiaks@al.insper.edu.br O projeto \u00e9 basicamente um controle de OSU. A ideia \u00e9 deixar esse jogo mais dif\u00edcil que j\u00e1 \u00e9. T\u00eam bot\u00f5es de ajustar o volume, de clicar e segurar (duas features espec\u00edficas do OSU) e entrada anal\u00f3gica para mover o mouse. https://www.dropbox.com/s/tinff55p06xjqhc/20210502_225334.mp4?dl=0 cicerotcv@al.insper.edu.br cicerotcv@al.insper.edu.br Com o controle, \u00e9 poss\u00edvel interagir com videos do youtube, avan\u00e7ando, voltando, ativando o mudo, desativando o mudo e possivelmente aumentando e diminuindo o volume. https://studio.youtube.com/video/Iibz1snDbgs/edit thiagolmm@al.insper.edu.br thiagolmm@al.insper.edu.br controle para netflix, conseuge pausar o v\u00eddeo, colocar e sair do fullscreen, adiantar e voltar 10s https://drive.google.com/file/d/1EcPOi22NdXx_5S6Y9EV7QhaZU5aEm-k4/view?usp=sharing 2020-1 Devido ao corona cancelamos o projeto. Mas as ideias eram: Tipo Nome Descri\u00e7\u00e3o Controle BoomBox Controle de Som GABRIEL ZANETTI TRAUMULLER KAWALL HENRY FURQUIM ROCHA MATHEUS PELLIZZON Controle Control Craft Controle do minecraft com sensor de batida JOS\u00c9 H\u00c9LIO PAIVA NETO LUCAS LEAL VALE RAFAEL ALVES DE MELLO ALMADA Controle Controle Pausa para Pipoca (PPP) EVANDRO FONTANA ROMEIRO MICHEL JOS\u00c9 HANOCH VIEIRA DE MORAES Controle ContRos Controle do rob\u00f4 de rob\u00f4tica ROGER RIBEIRO FAVA PINA SAMUEL NAASSOM DO NASCIMENTO PORTO Controle Dance Mat Tapete de dan\u00e7a BEATRIZ MIE KOTSUBO KUWABARA GABRIELA IANNINI CARUSO LUIZA RODRIGUES SILVEIRA Controle HandShooter Controle jogo tiro, que parece uma luva ANDR\u00c9 ELIMELEK DE WEBER GUILHERME TEIXEIRA BATISTA GUSTAVO BELTR\u00c3O BRAGA Controle Joystick Invisible Controle de jogo com 2 luvas JO\u00c3O PEDRO MONTEFELTRO JUNQUEIRA MEIRELLES PEDRO VERO FONTES RAFAEL DOS SANTOS Controle One Hand Controller Controle para megaman ABEL CAVALCANTE DE ANDRADE NETO RODRIGO DE JESUS OLIVEIRA JUNIOR Controle PC Control Macros para executar no PC BRUNO SIGNORELLI DOMINGUES GABRIEL MAGALH\u00c3ES DUARTE THOMAS DE QUEIROZ BARROS SCHNEIDER Controle SPOTIFAR Controle Spotify MANUELA CASTILLA RUSSO CORREA THIAGO VERARDO COSTA DOS SANTOS VITOR CALCETE MARQUES Controle TraderScan Controle que mostra dados da bolsa de valores CAIO HORSCHUTZ FAUZA LUIZ VITOR GERMANOS TEIXEIRA PEDRO PAULO MENDON\u00c7A TELHO Controle UmDrone Controle para drones - ROS GABRIEL FRIGO ZEZZE PEDRO LUIZ DA COSTA BRAGA VITOR GRANDO ELLER Controle YouControl Controle para youtube ERIC FERNANDO OTOFUJI ABRANTES JO\u00c3O VICTOR RODRIGUES SILVA Vending Machine 4Tune Roleta de m&m GIOVANNA SARDELLA CABRAL LUCAS MUCHALUAT MOREIRA MAYRA PETER DA ROCHA LOURES Vending Machine Camisinhas?? M\u00e1quina de venda de camisinhas MATHEUS PELLIZZON PEDRO TE\u00d3FILO RAMOS Vending Machine Coffe? Venda de c\u00e1psulas de nespresso EMANUELLE SILVA MO\u00c7O LEONARDO MENDES DE MORAES PEDRO HENRIQUE CARVALHO DAHER Vending Machine Quick Dray Venda de refil de cigarros eletr\u00f4nicos GABRIEL NOAL OLIVA GUSTAVO MOLINA FRENEDA BENITES 2019 Vending Machine Descri\u00e7\u00e3o --- --- --- Maquina caca niquel, com M&M de recompensa Vinicius Lima Gabriel Francato Samuel Granato Vending machine de drinks (alco\u00f3licos ou n\u00e3o). Alessandra Blucher Giulia Passarelli Warlen Rodrigues Imprima a qualquer momento suas notas favoritas Andre Ejzenmesser David Fogelman Wesley Silva Controle Descri\u00e7\u00e3o --- --- --- Interface de controle que cria atalhos para utilizar com Google Docs (Docs, Sheets, Apresenta\u00e7\u00f5es) em um navegador. Por ser ferramenta de produtividade que fica dentro de outro app (navegador), diversos comandos ficam de mais dif\u00edcil acesso por conflitarem com os do pr\u00f3prio navegador. O teclado especial tem por objetivo facilitar e agilizar o uso daqueles que usam as ferramentas de produtividade do Google. Eric Fernando Otofuji Abrantes Francisco Ciol Rodrigues Aveiro Jos\u00e9 Fernando Melo Cruz controle para o jogo GuitarHero Jorge Augusto Iago Mendes Faremos um controle bluetooth para o VLC usando conceitos de computa\u00e7\u00e3o embarcada. Teremos bot\u00f5es de volume, um motor slider para o time do filme e um start/stop. Sabrina Machado Matteo Iannoni Manoela Campos um teclado musical embarcado Guilherme de Moraes Lucas Vaz Felippe Teracini Luva para controle de um drone Lucca Delchiaro Costabile Antonio Andraues Raphael Azevedo Controle remoto universal para fun\u00e7\u00f5es dom\u00e9sticas Gabriel Monteiro Hugo Carl Bruno Arthur Controle bluetooth de Netflix para computador Juan Jorge Garcia Vitor Liu Vitor Satyro Usando um ARM SAME70 para criar uma vers\u00e3o de um stream deck , amplamente utilizado por streamers e editores de v\u00eddeo para tornar a\u00e7\u00f5es como o uso de shortcuts mais simples de serem realizadas com bot\u00f5es dedicados para algumas fun\u00e7\u00f5es e uma maior visualiza\u00e7\u00e3o de dados. Gustavo Gobetti Guilherme Leite Rafael Vieira Joystick de Arcade com 8 botoes Arthur Olga Bruno Costa Uma caixa a prova de \u00e1gua para controlar a m\u00fasica que est\u00e1 tocando no computador enquanto a pessoa est\u00e1 tomando banho. Eli jose abi ghosn Maria eduarda bicalho Gabriel moura Um teclado controlador que remixa diferentes sons Gabriel Monteiro Hugo Carl Bruno Arthur Controle para jogar Super Mario World (super nintendo) Alexandre Almeida Edington Victor Moura","title":"Anos passados"},{"location":"navigation/Projeto/Projeto-1-Lista/#anos-passados","text":"","title":"Anos passados"},{"location":"navigation/Projeto/Projeto-1-Lista/#2022-a","text":"Integrantes Descri\u00e7\u00e3o V\u00eddeo CESAR EZRA ADES;KEIYA NISHIO Nosso projeto \u00e9 um controle para youtube, com diversas funcionalidades, sendo elas: Ligar o controle, Mute, Pause/Play, Full screen, Passa/Volta o tempo(10 seg), Passa o para o pr\u00f3ximo v\u00eddeo Ele foi feito para que os usu\u00e1rios possam controlar o youtube remotamente, deitados em suas camas e sof\u00e1s sem ter o trabalho de se mover. Ao abrir nosso reposit\u00f3rio poder\u00e1 encontrar mais informa\u00e7\u00f5es sobre nosso projeto. https://www.youtube.com/watch?v=UQKn9XYL6Q0&t=1s BRUNO FREITAS DO NASCIMENTO RODRIGUES;NICOLAS BYUNG KWAN CHO Contralar um jogo com ativa\u00e7\u00e3o por som https://youtu.be/lWeQFMWuBXA CAROLINA HIRSCHHEIMER;PAULO WOOK KIM Fizemos um teclado matricial com um controle de volume. Ao apertar as teclas do teclado matricial, s\u00e3o emuladas as teclas como um numpad, conforme descrito no readme.md. Al\u00e9m disso, usamos um potenci\u00f4metro como controle de volume. Tamb\u00e9m temos uma resposta do LED quando recebe o handshake \u00e9 feito. https://youtu.be/eSaDR4vKHcA RODRIGO NIGRI GRINER;NAT\u00c1LIA QUEIROZ MENEZES CARRERAS A nossa ideia consiste em fazer uma mesa de efeitos especiais (sonoros e luminosos) para enfeitar a casa na \u00e9poca de Halloween. https://drive.google.com/file/d/134OgbOIbWBsuOg77UYchF803UxvCDvJB/view?usp=sharing HENRIQUE MARTINELLI FREZZATTI;L\u00cdVIA SAYURI MAKUTA O projeto simula um controle de PS4 com os quatro bot\u00f5es de uso (Quadrado, tri\u00e2ngulo, X e bola) e os dois anal\u00f3gicos, tanto o da esquerda para movimenta\u00e7\u00e3o geral, como o da direita para mover a c\u00e2mera nos jogos. Tendo em vista esse intuito, constru\u00edmos esse controle para test\u00e1-lo em jogos e verificar sua funcionalidade. https://youtu.be/MFPypHldZAY JOS\u00c9 RAFAEL MARTINS FERNANDES;LUCCA BARUFATTI VELINI SANCHES O projeto \u00e9 um controle bluetooth para o jogo que n\u00f3s desenvolvemos na disciplina de Design de Software, o Foxer. O controle tem 4 bot\u00f5es que emulam as setas do teclado e um potenci\u00f4metro respons\u00e1vel por aumentar e diminuir o volume do computador. Al\u00e9m disso, existem 2 leds, 1 indicando que o handshake foi feito e o controle est\u00e1 pronto para uso e outro respons\u00e1vel por avisar ao usu\u00e1rio que o PC est\u00e1 mutado. Por fim, existe um buzzer que emite um som toda vez que um bot\u00e3o \u00e9 apertado. https://youtu.be/j4WElf03OTk FRANCISCO AUGUSTO BUZOLIN VASCONCELLOS DA COSTA;FERNANDO PERES MARQUES GAMEIRO FRAN\u00c7A Controlador para o aplicativo Spotify. O diferencial do projeto \u00e9 o fato do controle interagir com a API do software e n\u00e3o com o software em si. Isso permite que o usu\u00e1rio possa controlar seu player do Spotify em qualquer dispositivo. https://youtu.be/_FJskPKnLcA RODRIGO GUIMAR\u00c3ES COELHO;RAPHAEL LAHIRY CABILIO MAMMANA DE BARROS O objetivo do nosso projeto era criar um controle de pinball online, mais especificamente para esse site: http://letsplay.ouigo.com/ . Nosso controle possui dois controles para os dois lados do batedor no jogo e um sensor de press\u00e3o que \u00e9 respons\u00e1vel por lan\u00e7ar a bola. Quanto mais for\u00e7a no sensor mais forte a bola \u00e9 lan\u00e7ada. Al\u00e9m disso, temos 2 indicadores para o usu\u00e1rio. Um deles para mostrar que o handshake foi feito e outro para mostrar o quanto de for\u00e7a foi aplicada no sensor de press\u00e3o numa escala de 0 a 10. https://www.youtube.com/watch?v=vKhJ2k98Hrs Davi Reis Vieira de Souza;GUILHERME ROSADA Controlador de Multim\u00eddia para o Spotify. Destinado para pessoas que queiram controlar sua m\u00fasica sem estar pr\u00f3xima do PC ou que queiram dar esse poder a terceiros, como filhos, por exemplo. https://youtu.be/tVuRww94FWc FABRICIO NERI LIMA;JEAN SILAS FERREIRA SANANDREZ A ideia consiste em criar um controle para o jogo CS (Counter Strike). Por meio de sistemas embarcados, pretendemos criar um controle mais imersivo, em que o jogador n\u00e3o precisa do teclado para jogar, podendo atirar, agachar, trocar de arma, e se locomover atrav\u00e9s do novo controle. https://www.youtube.com/watch?v=3tfhDoeAuwk ARTHUR GOMES CHIEPPE;VINICIUS GRANDO ELLER O projeto consiste em um controle para o jogo Golf It!. Usamos o potenci\u00f4metro para controlar a tacada, o encoder para ajustar a dire\u00e7\u00e3o e bot\u00f5es para usos diversos. https://youtu.be/MCCGAc4vXvg RAFAEL EVANGELISTA MONTEIRO;ESTHER GALLO DAGIR Esse projeto \u00e9 um controle bluetooth para o Spotify e tem as seguintes funcionalidades: 4 Bot\u00f5es: 1 de play/pause, 1 de avan\u00e7ar, 1 de retornar e 1 de shuffle 1 Potenciometro para mudar o volume 1 led para sinalizar quando est\u00e1 no mudo 1 buzzer para sinalizar que o controle est\u00e1 funcionando (fez o handshake) https://www.youtube.com/watch?v=scw-tIG19hs FRANCISCO PINHEIRO JANELA;NICOLAS MACIEL QUEIROGA O projeto foi desenvolvido para criar um controle bluetooth para o rob\u00f4 turtlebot, capaz de controlar a dire\u00e7\u00e3o e receber feedback de dist\u00e2ncia. https://youtu.be/vy48HiP2h_8 LUCA COUTINHO MEL\u00c3O;PAULO SOUZA CHADE A nossa aplica\u00e7\u00e3o consiste em um programa que recebe uma melodia e consegue traduzir isso para os pinos que devem ser tocados. No caso, tais pinos correspondem \u00e0s teclas de um piano, os quais v\u00e3o acender um LED no tempo em que devem ser tocados. https://youtu.be/_KdAMJ1dxks GUILHERME CARNEIRO LUNETTA;JOAO ZSIGMOND O nosso controle serve para jogar Counter Strike, um jogo famoso no computador. Utiliza alguns bot\u00f5es e tem os feedbacks com LED e Buzzer. https://youtu.be/Y3TvsveXXT0 JO\u00c3O VITOR MENEZES DE MAGALH\u00c3ES;FELIPE BANZATO PINTO DE LEMOS Nosso projeto \u00e9 um controle utilizado para mexer no youtube https://drive.google.com/file/d/13C9wXUb-MhIjcAD1htUl9d2xwCZRJF8B/view?usp=sharing JAMESSON LEANDRO PAIVA SANTOS;IVAN DE ALCANTARA BARBOSA BARROS O projeto consiste em um controle bluetooth voltado para gamers de jogos de guerra de avi\u00e3o. https://youtu.be/fmUkZNA9ECc ANA CAROLINA LEAL GARCIA DE SOUZA;JO\u00c3O PEDRO FARIAS DE ARAUJO Um controle via VJoy para jogar Tennis no Wii Sports emulado no computador https://youtu.be/hSnb8Q8nyII CAROLINE CHAIM DE LIMA CARNEIRO;TIAGO VITORINO SEIXAS Um controle para jogar PokeMMO, um emulador multiplayer de pokemon cl\u00e1ssico (Nintendo DS e Game Boy) para computador https://www.youtube.com/watch?v=apzu8N4fvoo BERNARDO CUNHA CAPOFERRI;GUILHERME DANTAS RAMEH Um MPU que controla o pitch e roll de um avi\u00e3o de um jogo, com um flex\u00f4metro que controla a acelera\u00e7\u00e3o e desacelera\u00e7\u00e3o, quatro bot\u00f5es para simular um gamepad. https://youtu.be/ggW0K9r1OmY LUIZA VALEZIM AUGUSTO PINTO;ELLEN BEATRIZ SHEN O BlueTiles \u00e9 um teclado bluetooth que, com apenas uma oitava, permite de voc\u00ea tocar piano. Ele possui 13 boto\u00f5es (contando com o de desligar e ligar), al\u00e9m do mixer de volume anal\u00f3gico. https://photos.app.goo.gl/qG2aSzBmn8NUd6JP7 BRUNO BOLDRIM SABOYA;MATHEUS KWON Nosso projeto serve para aqueles aspirantes em m\u00fasica e Dj, ele serve como um LaunchPad que simula o teclado do nosso aplicativo para tocarmos as musicas ou samples, ou os beats. Sua portabilidade e praticidade facilita a vida daqueles que estejam sempre em movimentam e n\u00e3o podem levar todos os equipamentos que eles tenham. https://youtu.be/QAn-dmwzwRM","title":"2022-a"},{"location":"navigation/Projeto/Projeto-1-Lista/#2021-a","text":"Integrantes Descri\u00e7\u00e3o andrevt1@al.insper.edu.br antoniovf@al.insper.edu.br Nosso projeto \u00e9 um controle de spotify, onde \u00e9 poss\u00edvel pausar, pular, voltar uma m\u00fasica, al\u00e9m de colocar no aleatorio. Tamb\u00e9m \u00e9 poss\u00edvel diminuir o volume com o potenciometro. Existem 2 feedbacks no controle, o primeiro para mostrar que ele esta funcionando, e o segundo para mostrar que a musica esta tocando https://youtu.be/S1r84FI3KBc carlosed3@al.insper.edu.br joaopga1@al.insper.edu.br Streamer Deck abre e controla Spotify e discord https://drive.google.com/file/d/1kfur3mRJsDKVAodVRDUrgFhxTD39MrOp/view?usp=sharing fernandocfbf@al.insper.edu.br laisns@al.insper.edu.br \u00c9 um controle que simula teclas do computador, especificamente para jogar mario forever, um jogo 2D da franquia Mario Bros https://drive.google.com/file/d/1Hqs_8FaSw8498iqNCPvv2qaeIVWyDXeG/view gabrielamb2@al.insper.edu.br theobr@al.insper.edu.br O projeto \u00e9 um controle pra quando voc\u00ea estiver deitado ou longe do computador voc\u00ea poder avancar, pausar, voltar, e navegar pelo netflix. https://drive.google.com/drive/folders/1rrGf4iEp__eRmZ5b_8DClmLhRHW1VDCK?usp=sharing edgardaon@al.insper.edu.br edgardaon@al.insper.edu.br O meu projeto \u00e9 um controle remoto para youtube, que pode controlar comandos como avan\u00e7ar 10 sec, voltar 10 sec, pausar/play, \"mutar\" e controlar o volume. https://drive.google.com/file/d/1uTgitwNWOPgxl38o9NRJORxXXD4T1KzW/view?usp=sharing manuelc@al.insper.edu.br andrebr@al.insper.edu.br O projeto serve como um controle para o jogo Pokemon. Os bot\u00f5es representam os bot\u00f5es do gameboy tradicional. O joystick \u00e9 utilizado para substituir as setinhas do gameboy. Assim, \u00e9 poss\u00edvel usar esse controle para jogar Pokemon no emulador, de uma maneira mais confort\u00e1vel. O controle tamb\u00e9m tem sinais que indicam quando o handshake j\u00e1 aconteceu e tamb\u00e9m um sinal para quando algum bot\u00e3o \u00e9 apertado. https://youtu.be/Y8Mk-5F9A5M beatrizrb@al.insper.edu.br joaogcfa@al.insper.edu.br Para controlar um filme que est\u00e1 passando na netflix, aumentando o volume do computador, fazendo ele adiantar 10s, voltar 10s, pausar e ficar em full screen. https://drive.google.com/file/d/1zT3H6ElKJmXK1VDe5W1cP9J_WdPgVJEF/view?usp=sharing marcompp@al.insper.edu.br gabrielaym@al.insper.edu.br Controle para jogos com quatro bot\u00f5es na placa e joystick anal\u00f3gico. Manda os inputs da placa para o computador atravez do bluetooth. O computador recebe e coloca o comando no vjoy. https://user-images.githubusercontent.com/49621844/116785879-4543d880-aa72-11eb-8608-d7a31734fa36.mp4 lucaskf@al.insper.edu.br lucaskf@al.insper.edu.br controle para jogar mario kart (funciona para a maioria dos titulos) https://drive.google.com/file/d/1zDWovRPSyZkq9ojfmIOqJn2uUqmInrfc/view?usp=sharing arthurfc2@al.insper.edu.br victorvaac@al.insper.edu.br Controle para tinder https://youtu.be/WOtw07sDUcE luisfml@al.insper.edu.br luisfsc@al.insper.edu.br Nosso projeto consiste em um controle para o Netflix. Assim o usu\u00e1rio poder\u00e1 mutar, avan\u00e7ar/retornar, aumentar/diminuir volume, pausar/iniciar o filme por meio do controle bluetooth. \u00c9 crescente o acesso ao Netflix por meio de laptop/PC em detrimento da televis\u00e3o, assim, criamos um controle que deixa mais c\u00f4modo para o usu\u00e1rio realizar alguma a\u00e7\u00e3o na aplica\u00e7\u00e3o. https://drive.google.com/file/d/1nZ7k6wScidorKgvy9_6jWWmS4qFRsXmu/view?usp=sharing gabriellaec@al.insper.edu.br gabriellaec@al.insper.edu.br Controle para Spotify. Pode ser usado para atividades ao ar livre ou indoors. O usu\u00e1rio pode selecionar as m\u00fasicas (next, previous), dar play/pause, controlar o volume e ver o nome da m\u00fasica na tela https://drive.google.com/file/d/1a_VB78qZptOJtcHlvJKCefFXe7hSUKM6/view?usp=sharing anaccf5@al.insper.edu.br matheusfs2@al.insper.edu.br O projeto simula 4 teclas de um teclado e tamb\u00e9m possibilita que se mude o volume por meio de um potenci\u00f4metro. Ele foi feito pensando na Netflix, mas tamb\u00e9m \u00e9 poss\u00edvel us\u00e1-lo no Youtube por exemplo. Por ser Bluetooth, \u00e9 legal que conseguimos usar ele enquanto deitado na cama, sem precisar ficar levantando para mexer no teclado (para quem v\u00ea Netflix no Note, que \u00e9 o meu caso :) ). https://drive.google.com/file/d/1c-v-JKd7TPEW6tCwFvmUv1Fmi8MrmOCf/view?usp=sharing marcelocm8@al.insper.edu.br eikily@al.insper.edu.br O nosso projeto foi feito para o Game Boy Advanced (GBA), um videogame port\u00e1til que muitos de n\u00f3s quando crian\u00e7a costumavam jogar. A \u00fanica diferen\u00e7a est\u00e1 nos bot\u00f5es, onde foi trocado as setas do GBA pelo anal\u00f3gico. O bot\u00e3o do microchip desliga o controle e os 3 bot\u00f5es do oled mais o anal\u00f3gico s\u00e3o para o GBA. https://drive.google.com/file/d/1F8L-5CndQH_tv9GsXUg2ffL10yzaO8ez/view?usp=sharing thalials@al.insper.edu.br williamars@al.insper.edu.br \u00c9 um controle de Spotify, que tem 5 bot\u00f5es digitais - pause/play, voltar m\u00fasica, passar m\u00fasica, desligar/ligar controle e fechar aplicativo. Al\u00e9m disso, tem-se um potenci\u00f4metro, que controla o volume do aplicativo. https://youtu.be/yAgvNxoVyQY henriquert@al.insper.edu.br victoran@al.insper.edu.br O projeto serve para o usuario poder controlar seu spotify pelo controle. Muitas vezes conectamos o computador na caixa de som em uma festa, porem ficar indo ate o computador \u00e9 muitas vezes cansativo. Para isso, o usuario agora pode controlar a musica de qualquer lugar da festa. Podendo pular, voltar, pausar, dar mute ou mudar o volume. https://drive.google.com/file/d/1f2u5uk4MmlBQwN7ZCqfsWvSLBX3D3PXu/view?usp=sharing henriquemm3@al.insper.edu.br henriquemm3@al.insper.edu.br Controlar a distancia a netflix e outros programas possivelmente j\u00e1 que vc tem um mouse! https://youtu.be/FiB4-OAT5q8 gabrielmk@al.insper.edu.br murilolcm@al.insper.edu.br O objetivo do nosso projeto era fazer um controle para Counter Strike, que permitisse o jogador a conduzir uma sess\u00e3o de treino. Para isso, fizemos quatro bot\u00f5es (atirar, recarregar, pular, e agachar), e um joystick que permita o movimento b\u00e1sico do jogador. Dessa forma, conseguimos fazer uma sess\u00e3o de pr\u00e1tica com feedback ao usu\u00e1rio, ao que o LED da placa pisca quando a arma est\u00e1 recarregando, e para de piscar quando o jogador pode atirar de novo. Al\u00e9m disso, fizemos o handshake para indicar que o controle est\u00e1 pronto para uso. https://drive.google.com/file/d/1OEcru01oLmWyqU2K_WWS6g8ndwnVfwtG/view?usp=sharing rafaella2@al.insper.edu.br giovannicps@al.insper.edu.br Um controle de netflix para utilizar enquanto esta sentado no sofa com o laptop ligado na tv para fun\u00e7oes simples de controle de midia. https://youtu.be/eedJblbAScE beatrizmcs@al.insper.edu.br sophiaks@al.insper.edu.br O projeto \u00e9 basicamente um controle de OSU. A ideia \u00e9 deixar esse jogo mais dif\u00edcil que j\u00e1 \u00e9. T\u00eam bot\u00f5es de ajustar o volume, de clicar e segurar (duas features espec\u00edficas do OSU) e entrada anal\u00f3gica para mover o mouse. https://www.dropbox.com/s/tinff55p06xjqhc/20210502_225334.mp4?dl=0 cicerotcv@al.insper.edu.br cicerotcv@al.insper.edu.br Com o controle, \u00e9 poss\u00edvel interagir com videos do youtube, avan\u00e7ando, voltando, ativando o mudo, desativando o mudo e possivelmente aumentando e diminuindo o volume. https://studio.youtube.com/video/Iibz1snDbgs/edit thiagolmm@al.insper.edu.br thiagolmm@al.insper.edu.br controle para netflix, conseuge pausar o v\u00eddeo, colocar e sair do fullscreen, adiantar e voltar 10s https://drive.google.com/file/d/1EcPOi22NdXx_5S6Y9EV7QhaZU5aEm-k4/view?usp=sharing","title":"2021-a"},{"location":"navigation/Projeto/Projeto-1-Lista/#2020-1","text":"Devido ao corona cancelamos o projeto. Mas as ideias eram: Tipo Nome Descri\u00e7\u00e3o Controle BoomBox Controle de Som GABRIEL ZANETTI TRAUMULLER KAWALL HENRY FURQUIM ROCHA MATHEUS PELLIZZON Controle Control Craft Controle do minecraft com sensor de batida JOS\u00c9 H\u00c9LIO PAIVA NETO LUCAS LEAL VALE RAFAEL ALVES DE MELLO ALMADA Controle Controle Pausa para Pipoca (PPP) EVANDRO FONTANA ROMEIRO MICHEL JOS\u00c9 HANOCH VIEIRA DE MORAES Controle ContRos Controle do rob\u00f4 de rob\u00f4tica ROGER RIBEIRO FAVA PINA SAMUEL NAASSOM DO NASCIMENTO PORTO Controle Dance Mat Tapete de dan\u00e7a BEATRIZ MIE KOTSUBO KUWABARA GABRIELA IANNINI CARUSO LUIZA RODRIGUES SILVEIRA Controle HandShooter Controle jogo tiro, que parece uma luva ANDR\u00c9 ELIMELEK DE WEBER GUILHERME TEIXEIRA BATISTA GUSTAVO BELTR\u00c3O BRAGA Controle Joystick Invisible Controle de jogo com 2 luvas JO\u00c3O PEDRO MONTEFELTRO JUNQUEIRA MEIRELLES PEDRO VERO FONTES RAFAEL DOS SANTOS Controle One Hand Controller Controle para megaman ABEL CAVALCANTE DE ANDRADE NETO RODRIGO DE JESUS OLIVEIRA JUNIOR Controle PC Control Macros para executar no PC BRUNO SIGNORELLI DOMINGUES GABRIEL MAGALH\u00c3ES DUARTE THOMAS DE QUEIROZ BARROS SCHNEIDER Controle SPOTIFAR Controle Spotify MANUELA CASTILLA RUSSO CORREA THIAGO VERARDO COSTA DOS SANTOS VITOR CALCETE MARQUES Controle TraderScan Controle que mostra dados da bolsa de valores CAIO HORSCHUTZ FAUZA LUIZ VITOR GERMANOS TEIXEIRA PEDRO PAULO MENDON\u00c7A TELHO Controle UmDrone Controle para drones - ROS GABRIEL FRIGO ZEZZE PEDRO LUIZ DA COSTA BRAGA VITOR GRANDO ELLER Controle YouControl Controle para youtube ERIC FERNANDO OTOFUJI ABRANTES JO\u00c3O VICTOR RODRIGUES SILVA Vending Machine 4Tune Roleta de m&m GIOVANNA SARDELLA CABRAL LUCAS MUCHALUAT MOREIRA MAYRA PETER DA ROCHA LOURES Vending Machine Camisinhas?? M\u00e1quina de venda de camisinhas MATHEUS PELLIZZON PEDRO TE\u00d3FILO RAMOS Vending Machine Coffe? Venda de c\u00e1psulas de nespresso EMANUELLE SILVA MO\u00c7O LEONARDO MENDES DE MORAES PEDRO HENRIQUE CARVALHO DAHER Vending Machine Quick Dray Venda de refil de cigarros eletr\u00f4nicos GABRIEL NOAL OLIVA GUSTAVO MOLINA FRENEDA BENITES","title":"2020-1"},{"location":"navigation/Projeto/Projeto-1-Lista/#2019","text":"","title":"2019"},{"location":"navigation/Projeto/Projeto-1-Lista/#vending-machine","text":"Descri\u00e7\u00e3o --- --- --- Maquina caca niquel, com M&M de recompensa Vinicius Lima Gabriel Francato Samuel Granato Vending machine de drinks (alco\u00f3licos ou n\u00e3o). Alessandra Blucher Giulia Passarelli Warlen Rodrigues Imprima a qualquer momento suas notas favoritas Andre Ejzenmesser David Fogelman Wesley Silva","title":"Vending Machine"},{"location":"navigation/Projeto/Projeto-1-Lista/#controle","text":"Descri\u00e7\u00e3o --- --- --- Interface de controle que cria atalhos para utilizar com Google Docs (Docs, Sheets, Apresenta\u00e7\u00f5es) em um navegador. Por ser ferramenta de produtividade que fica dentro de outro app (navegador), diversos comandos ficam de mais dif\u00edcil acesso por conflitarem com os do pr\u00f3prio navegador. O teclado especial tem por objetivo facilitar e agilizar o uso daqueles que usam as ferramentas de produtividade do Google. Eric Fernando Otofuji Abrantes Francisco Ciol Rodrigues Aveiro Jos\u00e9 Fernando Melo Cruz controle para o jogo GuitarHero Jorge Augusto Iago Mendes Faremos um controle bluetooth para o VLC usando conceitos de computa\u00e7\u00e3o embarcada. Teremos bot\u00f5es de volume, um motor slider para o time do filme e um start/stop. Sabrina Machado Matteo Iannoni Manoela Campos um teclado musical embarcado Guilherme de Moraes Lucas Vaz Felippe Teracini Luva para controle de um drone Lucca Delchiaro Costabile Antonio Andraues Raphael Azevedo Controle remoto universal para fun\u00e7\u00f5es dom\u00e9sticas Gabriel Monteiro Hugo Carl Bruno Arthur Controle bluetooth de Netflix para computador Juan Jorge Garcia Vitor Liu Vitor Satyro Usando um ARM SAME70 para criar uma vers\u00e3o de um stream deck , amplamente utilizado por streamers e editores de v\u00eddeo para tornar a\u00e7\u00f5es como o uso de shortcuts mais simples de serem realizadas com bot\u00f5es dedicados para algumas fun\u00e7\u00f5es e uma maior visualiza\u00e7\u00e3o de dados. Gustavo Gobetti Guilherme Leite Rafael Vieira Joystick de Arcade com 8 botoes Arthur Olga Bruno Costa Uma caixa a prova de \u00e1gua para controlar a m\u00fasica que est\u00e1 tocando no computador enquanto a pessoa est\u00e1 tomando banho. Eli jose abi ghosn Maria eduarda bicalho Gabriel moura Um teclado controlador que remixa diferentes sons Gabriel Monteiro Hugo Carl Bruno Arthur Controle para jogar Super Mario World (super nintendo) Alexandre Almeida Edington Victor Moura","title":"Controle"},{"location":"navigation/Projeto/Projeto-2-2019-Lista/","text":"Lista dos projetos de 2019 Controle","title":"Lista dos projetos de 2019"},{"location":"navigation/Projeto/Projeto-2-2019-Lista/#lista-dos-projetos-de-2019","text":"","title":"Lista dos projetos de 2019"},{"location":"navigation/Projeto/Projeto-2-2019-Lista/#controle","text":"","title":"Controle"},{"location":"navigation/Projeto/Projeto-2-Lista/","text":"Projeto 2 - Anos anteriores 2019 Nome do prot\u00f3tipo (invente um!) Pequena descri\u00e7\u00e3o Integrantes git Nightscout Alarm Clock Rel\u00f3gio de mesa que exibe glicemia da nuvem Gabriel Monteiro Guilherme Leite https://github.com/gabriellm1/NightscoutAlarmClock BarInABox Uma vending machina que faz drinks personalizados. Alessandra Bl\u00fccher Giulia Passarelli Warlen Rodrigues https://github.com/aleblucher/BarInABox smart piano Um piano que toca uma musica automaticamente. O usu\u00e1rio escolhe a musica e o piano faz o resto Andre Manoela https://github.com/manucirne/tecladoProjeto2.git Weather Data Monitora a temperatura, n\u00edvel de CO2, press\u00e3o, umidade do ar, presen\u00e7a de \u00e1gua no ch\u00e3o. Os dados s\u00e3o salvos em um SDCARD e qualquer evento inesperado relacionado \u00e0 essas caracter\u00edsticas, \u00e9 enviado uma mensagem por internet. Juan Jorge Garcia Vitor Liu Vitor Satyro https://github.com/LiuSeeker/Projeto2-Embarcados Insper Arcade Box Controle de fliperama bluetooth Bruno Arruda Camargo Paulino Costa Arthur Quintella de Mello Olga https://github.com/ThunderSly/Projeto1-Embarcados slide race Medidor de velocidade do escorregador do insper David Fogelman Wesley Gabriel https://github.com/Fogelman/slide-race Speedtest Verifica velocidade de internet para download e ping. Eric Fernando Otofuji Abrantes Francisco Ciol Rodrigues Aveiro Jose Fernando de Melo Cruz https://github.com/franciol/projeto-2-embarcados Guitar Controller Guitarra do jogo Guitar Hero refeita em SAME70 com Bluetooth Iago R. Mendes Jorge Augusto Ehrhardt https://github.com/ehrhardt98/GuitarController Sound Mixer Caixa de efeitos em \u00e1udio Felippe Teracini Guilherme Moraes Lucas Vaz https://github.com/TeraByte900/Sound_Mixer ZikaNiquel \u00c9 um ca\u00e7a n\u00edquel que da m&m de recompensa Gabriel Valente Francato Vinicius Lima Samuel Granato https://github.com/vinigl/caca_niquel Home coffeeshop Cafeteira que funciona via um servidor Matteo Iannoni Sabrina Machado https://github.com/SabrinaMB/Projeto2-Embarcados Download Speedometer Um sistema que mede a velocidade de download de uma rede Alexandre Edington Francisco Ciol Rodrigues Aveiro https://github.com/franciol/projeto-2-embarcados.git Controladora MIDI O projeto consiste em uma controladora midi que toca samples de instrumentos e sons para musicos ou djs. Hugo Bruno Arthur https://github.com/brunoartc/EmbarcadosP1 Water Sensor Nosso produto foi feito para ser colocado na caixa d'\u00e1gua. Ele media a altura da agua, quanto estava saindo, e a qualidade Maria Eduarda Eli Jose https://github.com/mariaeduardabicalho/Projeto2_Embarcada Stream Deck Um aparelho que realiza controles na transmiss\u00e3o de live streams juntamente com um software de broadcasting. Rafael Vieira Rosenzvaig Gustavo Gobetti Victor Moura https://github.com/GustavoGB/streamDeck Auera receptor A ideia era fazer um painel com a matriz de led que escreve o numero de acessos e o numero de pedidos baseado em servidor nicolas stegmann gabriel moura https://github.com/nicolasbss/projeto2-embarcados Controle mario 64 Controle, com funcionamento bluetooth, criado especificamente para o jogo super mario 64 Pedro Azambuja Guilherme Aliperti https://github.com/pedrooa/Projeto2-Embarcados Drone Gauntlet Uma luva que controla um drone pelos movimentos da m\u00e3o Antonio Andraues Raphael Azevedo Lucca Delchiaro https://github.com/AntonioAndraues/Embarcados_Controle_Drone.git Arcade Insper Controle de fliperama bluetooth com SAME70 Bruno Costa Arthur Olga https://github.com/ThunderSly/Projeto2-Embarcados 2018 Nome do projeto Pequeno descritivo Integrantes git Gaveta autom\u00e1tica A gaveta autom\u00e1tica que iremos construir ser\u00e1 aberta automaticamente por meio de um servo motor, quando um bot\u00e3o estiver sendo pressionado. E ser\u00e1 fechada quando o outro bot\u00e3o for pressionado. Martim Ferreira e Lucas Chen https://gitlab.com/martimfj/Computacao-Embarcada-Projetos Screaming Charmander Quando o sensor de fogo detecta uma chama, o buzzer come\u00e7a a apitar e o led vermelho a piscar. O bot\u00e3o desativa o alarme. Eduardo Tirta e Guilherme Graicer https://github.com/eduardotp1/screaming-charmander MolhaAsPranta Regador Autom\u00e1tico que \u00e9 acionado por um sensor de umidade do solo, atuando sobre uma v\u00e1lvula de vaz\u00e3o. Leonardo Medeiros e Pedro de La Pe\u00f1a https://gitlab.com/LeonardoMedeiros/MolhaAsPranta Confrin Um simulador de cofre controlado pelo keypad num\u00e9rico Raphael Costa e Frederico Curti https://github.com/fredericocurti/compemb Home AutoBot Um sistema embarcado que controla a ilumina\u00e7\u00e3o e um ventilador da sua casa. Sua luz acender\u00e1 quando voc\u00ea entrar na sua casa (sensor de presen\u00e7a) e voc\u00ea poder\u00e1 ligar seu ventilador com um bot\u00e3o touch estrategicamente posicionado. Filipe Borba, Gabriel Moreira, Hugo Mendes https://github.com/filipefborba/homeautobot Alarme de invas\u00e3o A ideia do projeto \u00e9 fazer um sistema de alarme de invas\u00e3o, usando um sensor de presen\u00e7a, um buzzer e dois LEDs (o da placa e um externo). O sensor quando for ativado, aciona buzzer e o led da placa. J\u00e1 bot\u00e3o, um led externo, o da placa e o buzzer. Bruna Kimura e Elisa Malzoni https://gitlab.com/elisamalzoni/embarcados-proj1","title":"Projeto 2 - Anos anteriores"},{"location":"navigation/Projeto/Projeto-2-Lista/#projeto-2-anos-anteriores","text":"","title":"Projeto 2 - Anos anteriores"},{"location":"navigation/Projeto/Projeto-2-Lista/#2019","text":"Nome do prot\u00f3tipo (invente um!) Pequena descri\u00e7\u00e3o Integrantes git Nightscout Alarm Clock Rel\u00f3gio de mesa que exibe glicemia da nuvem Gabriel Monteiro Guilherme Leite https://github.com/gabriellm1/NightscoutAlarmClock BarInABox Uma vending machina que faz drinks personalizados. Alessandra Bl\u00fccher Giulia Passarelli Warlen Rodrigues https://github.com/aleblucher/BarInABox smart piano Um piano que toca uma musica automaticamente. O usu\u00e1rio escolhe a musica e o piano faz o resto Andre Manoela https://github.com/manucirne/tecladoProjeto2.git Weather Data Monitora a temperatura, n\u00edvel de CO2, press\u00e3o, umidade do ar, presen\u00e7a de \u00e1gua no ch\u00e3o. Os dados s\u00e3o salvos em um SDCARD e qualquer evento inesperado relacionado \u00e0 essas caracter\u00edsticas, \u00e9 enviado uma mensagem por internet. Juan Jorge Garcia Vitor Liu Vitor Satyro https://github.com/LiuSeeker/Projeto2-Embarcados Insper Arcade Box Controle de fliperama bluetooth Bruno Arruda Camargo Paulino Costa Arthur Quintella de Mello Olga https://github.com/ThunderSly/Projeto1-Embarcados slide race Medidor de velocidade do escorregador do insper David Fogelman Wesley Gabriel https://github.com/Fogelman/slide-race Speedtest Verifica velocidade de internet para download e ping. Eric Fernando Otofuji Abrantes Francisco Ciol Rodrigues Aveiro Jose Fernando de Melo Cruz https://github.com/franciol/projeto-2-embarcados Guitar Controller Guitarra do jogo Guitar Hero refeita em SAME70 com Bluetooth Iago R. Mendes Jorge Augusto Ehrhardt https://github.com/ehrhardt98/GuitarController Sound Mixer Caixa de efeitos em \u00e1udio Felippe Teracini Guilherme Moraes Lucas Vaz https://github.com/TeraByte900/Sound_Mixer ZikaNiquel \u00c9 um ca\u00e7a n\u00edquel que da m&m de recompensa Gabriel Valente Francato Vinicius Lima Samuel Granato https://github.com/vinigl/caca_niquel Home coffeeshop Cafeteira que funciona via um servidor Matteo Iannoni Sabrina Machado https://github.com/SabrinaMB/Projeto2-Embarcados Download Speedometer Um sistema que mede a velocidade de download de uma rede Alexandre Edington Francisco Ciol Rodrigues Aveiro https://github.com/franciol/projeto-2-embarcados.git Controladora MIDI O projeto consiste em uma controladora midi que toca samples de instrumentos e sons para musicos ou djs. Hugo Bruno Arthur https://github.com/brunoartc/EmbarcadosP1 Water Sensor Nosso produto foi feito para ser colocado na caixa d'\u00e1gua. Ele media a altura da agua, quanto estava saindo, e a qualidade Maria Eduarda Eli Jose https://github.com/mariaeduardabicalho/Projeto2_Embarcada Stream Deck Um aparelho que realiza controles na transmiss\u00e3o de live streams juntamente com um software de broadcasting. Rafael Vieira Rosenzvaig Gustavo Gobetti Victor Moura https://github.com/GustavoGB/streamDeck Auera receptor A ideia era fazer um painel com a matriz de led que escreve o numero de acessos e o numero de pedidos baseado em servidor nicolas stegmann gabriel moura https://github.com/nicolasbss/projeto2-embarcados Controle mario 64 Controle, com funcionamento bluetooth, criado especificamente para o jogo super mario 64 Pedro Azambuja Guilherme Aliperti https://github.com/pedrooa/Projeto2-Embarcados Drone Gauntlet Uma luva que controla um drone pelos movimentos da m\u00e3o Antonio Andraues Raphael Azevedo Lucca Delchiaro https://github.com/AntonioAndraues/Embarcados_Controle_Drone.git Arcade Insper Controle de fliperama bluetooth com SAME70 Bruno Costa Arthur Olga https://github.com/ThunderSly/Projeto2-Embarcados","title":"2019"},{"location":"navigation/Projeto/Projeto-2-Lista/#2018","text":"Nome do projeto Pequeno descritivo Integrantes git Gaveta autom\u00e1tica A gaveta autom\u00e1tica que iremos construir ser\u00e1 aberta automaticamente por meio de um servo motor, quando um bot\u00e3o estiver sendo pressionado. E ser\u00e1 fechada quando o outro bot\u00e3o for pressionado. Martim Ferreira e Lucas Chen https://gitlab.com/martimfj/Computacao-Embarcada-Projetos Screaming Charmander Quando o sensor de fogo detecta uma chama, o buzzer come\u00e7a a apitar e o led vermelho a piscar. O bot\u00e3o desativa o alarme. Eduardo Tirta e Guilherme Graicer https://github.com/eduardotp1/screaming-charmander MolhaAsPranta Regador Autom\u00e1tico que \u00e9 acionado por um sensor de umidade do solo, atuando sobre uma v\u00e1lvula de vaz\u00e3o. Leonardo Medeiros e Pedro de La Pe\u00f1a https://gitlab.com/LeonardoMedeiros/MolhaAsPranta Confrin Um simulador de cofre controlado pelo keypad num\u00e9rico Raphael Costa e Frederico Curti https://github.com/fredericocurti/compemb Home AutoBot Um sistema embarcado que controla a ilumina\u00e7\u00e3o e um ventilador da sua casa. Sua luz acender\u00e1 quando voc\u00ea entrar na sua casa (sensor de presen\u00e7a) e voc\u00ea poder\u00e1 ligar seu ventilador com um bot\u00e3o touch estrategicamente posicionado. Filipe Borba, Gabriel Moreira, Hugo Mendes https://github.com/filipefborba/homeautobot Alarme de invas\u00e3o A ideia do projeto \u00e9 fazer um sistema de alarme de invas\u00e3o, usando um sensor de presen\u00e7a, um buzzer e dois LEDs (o da placa e um externo). O sensor quando for ativado, aciona buzzer e o led da placa. J\u00e1 bot\u00e3o, um led externo, o da placa e o buzzer. Bruna Kimura e Elisa Malzoni https://gitlab.com/elisamalzoni/embarcados-proj1","title":"2018"},{"location":"navigation/Projeto/vjoy/","text":"Vjoy e pyautogui Dicas para de uso do vjoy, pyautogui e controle de volume do Windows. vjoy N\u00f3s utilizamos o pacote pyvjoy que possibilita controlarmos o vjoy via python. Ele \u00e9 apenas uma camada de abstra\u00e7\u00e3o do vjoy. https://github.com/tidzo/pyvjoy N\u00f3s sugerimos voc\u00eas trabalharem com a monitor do vjoy aberto, para conseguirem depurar visualmente o que est\u00e1 acontecendo com o controle. Criando Criando um joystick import pyvjoy j = pyvjoy . VJoyDevice ( 1 ) Acionando um bot\u00e3o Acionando o bot\u00e3o 15 j . set_button ( 15 , 1 ) Info O vjoy mant\u00e9m o valor mesmo com o programa reiniciado, se apertar o bot\u00e3o 15 e deixar ele apertado, da pr\u00f3xima vez que for usar o controle ele vai continuar apertado. Soltando o bot\u00e3o 15 j . set_button ( 15 , 0 ) Notem que o j.set_button recebe: (buttonID,state) Anal\u00f3gico O vjoy possui v\u00e1rias entradas anal\u00f3gicas , sendo as principais: HID_USAGE_X HID_USAGE_Y HID_USAGE_Z HID_USAGE_RX HID_USAGE_RY HID_USAGE_RZ O range da entrada anal\u00f3gica \u00e9 de 1 (total esquerda) at\u00e9 32768 (total direita). # total esquerda j . set_axis ( pyvjoy . HID_USAGE_X , 0x1 ) # total direita j . set_axis ( pyvjoy . HID_USAGE_X , 32768 ) pyautogui O pyautogui \u00e9 um lib que permite emularmos a\u00e7\u00f5es do teclado e mouse via python. Manter tecla pressionada Por padr\u00e3o a lib n\u00e3o permite manter uma tecla pressionada (e ficar repetitivamente enviando o mesmo valor), para desativar basta remover o delay: def __init__ ( self , port , baudrate ): pyautogui . PAUSE = 0 ## remove delay Agora uma tecla \"pressionada\" ira ser enviada repetitivamente keyboard https://pyautogui.readthedocs.io/en/latest/keyboard.html# O pyautogui disponibiliza duas formas diferentes de apertarmos uma tecla: press que \u00e9 uma a\u00e7\u00e3o de apertar e soltar uma tecla keyDown e keyUp que s\u00e3o a\u0107oes distintas de apertar e soltar pyautogui . keyDown ( 'shift' ) # hold down the shift key pyautogui . press ( 'left' ) # press the left arrow key pyautogui . press ( 'left' ) # press the left arrow key pyautogui . press ( 'left' ) # press the left arrow key pyautogui . keyUp ( 'shift' ) # release the shift key Para uma lista des teclas suportas acesse: https://pyautogui.readthedocs.io/en/latest/keyboard.html#keyboard-keys Se precisar fazer um combo (hotkeys) de teclas como o: ctrl + alt + f4 , use o hotkeys : pyautogui . hotkey ( 'ctrl' , 'shift' , 'f4' ) Emulando mouse A documentac\u00e3o oficial \u00e9 muito boa: https://pyautogui.readthedocs.io/en/latest/mouse.html Volume Para o controle do volume do windows, podemos usar o pycaw : from pycaw.pycaw import AudioUtilities , IAudioEndpointVolume devices = AudioUtilities . GetSpeakers () interface = devices . Activate ( IAudioEndpointVolume . _iid_ , CLSCTX_ALL , None ) volume = cast ( . interface , POINTER ( IAudioEndpointVolume )) E agora podemos definir o volume com: volume . SetMasterVolumeLevel ( VALUE , None ) Sendo VALUE um valor em decib\u00e9is (0 \u00e9 m\u00e1ximo e -51 m\u00ednimo), use a tabela a seguir como escala: volume2decibal = { 0.00 : - 51 , 0.05 : - 40 , 0.10 : - 30.848 , 0.15 : - 26 , 0.20 : - 22.477 , 0.25 : - 20 , 0.30 : - 17.111 , 0.35 : - 15 , 0.40 : - 13.152 , 0.45 : - 11 , 0.50 : - 10.015 , 0.55 : - 8.5 , 0.60 : - 7.415 , 0.65 : - 6 , 0.70 : - 4.991 , 0.75 : - 4 , 0.80 : - 3.26 , 0.85 : - 2 , 0.90 : - 1.381 , 0.95 : - 0.6 , 1 : 0 }","title":"Vjoy e pyautogui"},{"location":"navigation/Projeto/vjoy/#vjoy-e-pyautogui","text":"Dicas para de uso do vjoy, pyautogui e controle de volume do Windows.","title":"Vjoy e pyautogui"},{"location":"navigation/Projeto/vjoy/#vjoy","text":"N\u00f3s utilizamos o pacote pyvjoy que possibilita controlarmos o vjoy via python. Ele \u00e9 apenas uma camada de abstra\u00e7\u00e3o do vjoy. https://github.com/tidzo/pyvjoy N\u00f3s sugerimos voc\u00eas trabalharem com a monitor do vjoy aberto, para conseguirem depurar visualmente o que est\u00e1 acontecendo com o controle.","title":"vjoy"},{"location":"navigation/Projeto/vjoy/#criando","text":"Criando um joystick import pyvjoy j = pyvjoy . VJoyDevice ( 1 )","title":"Criando"},{"location":"navigation/Projeto/vjoy/#acionando-um-botao","text":"Acionando o bot\u00e3o 15 j . set_button ( 15 , 1 ) Info O vjoy mant\u00e9m o valor mesmo com o programa reiniciado, se apertar o bot\u00e3o 15 e deixar ele apertado, da pr\u00f3xima vez que for usar o controle ele vai continuar apertado. Soltando o bot\u00e3o 15 j . set_button ( 15 , 0 ) Notem que o j.set_button recebe: (buttonID,state)","title":"Acionando um bot\u00e3o"},{"location":"navigation/Projeto/vjoy/#analogico","text":"O vjoy possui v\u00e1rias entradas anal\u00f3gicas , sendo as principais: HID_USAGE_X HID_USAGE_Y HID_USAGE_Z HID_USAGE_RX HID_USAGE_RY HID_USAGE_RZ O range da entrada anal\u00f3gica \u00e9 de 1 (total esquerda) at\u00e9 32768 (total direita). # total esquerda j . set_axis ( pyvjoy . HID_USAGE_X , 0x1 ) # total direita j . set_axis ( pyvjoy . HID_USAGE_X , 32768 )","title":"Anal\u00f3gico"},{"location":"navigation/Projeto/vjoy/#pyautogui","text":"O pyautogui \u00e9 um lib que permite emularmos a\u00e7\u00f5es do teclado e mouse via python.","title":"pyautogui"},{"location":"navigation/Projeto/vjoy/#manter-tecla-pressionada","text":"Por padr\u00e3o a lib n\u00e3o permite manter uma tecla pressionada (e ficar repetitivamente enviando o mesmo valor), para desativar basta remover o delay: def __init__ ( self , port , baudrate ): pyautogui . PAUSE = 0 ## remove delay Agora uma tecla \"pressionada\" ira ser enviada repetitivamente","title":"Manter tecla pressionada"},{"location":"navigation/Projeto/vjoy/#keyboard","text":"https://pyautogui.readthedocs.io/en/latest/keyboard.html# O pyautogui disponibiliza duas formas diferentes de apertarmos uma tecla: press que \u00e9 uma a\u00e7\u00e3o de apertar e soltar uma tecla keyDown e keyUp que s\u00e3o a\u0107oes distintas de apertar e soltar pyautogui . keyDown ( 'shift' ) # hold down the shift key pyautogui . press ( 'left' ) # press the left arrow key pyautogui . press ( 'left' ) # press the left arrow key pyautogui . press ( 'left' ) # press the left arrow key pyautogui . keyUp ( 'shift' ) # release the shift key Para uma lista des teclas suportas acesse: https://pyautogui.readthedocs.io/en/latest/keyboard.html#keyboard-keys Se precisar fazer um combo (hotkeys) de teclas como o: ctrl + alt + f4 , use o hotkeys : pyautogui . hotkey ( 'ctrl' , 'shift' , 'f4' )","title":"keyboard"},{"location":"navigation/Projeto/vjoy/#emulando-mouse","text":"A documentac\u00e3o oficial \u00e9 muito boa: https://pyautogui.readthedocs.io/en/latest/mouse.html","title":"Emulando mouse"},{"location":"navigation/Projeto/vjoy/#volume","text":"Para o controle do volume do windows, podemos usar o pycaw : from pycaw.pycaw import AudioUtilities , IAudioEndpointVolume devices = AudioUtilities . GetSpeakers () interface = devices . Activate ( IAudioEndpointVolume . _iid_ , CLSCTX_ALL , None ) volume = cast ( . interface , POINTER ( IAudioEndpointVolume )) E agora podemos definir o volume com: volume . SetMasterVolumeLevel ( VALUE , None ) Sendo VALUE um valor em decib\u00e9is (0 \u00e9 m\u00e1ximo e -51 m\u00ednimo), use a tabela a seguir como escala: volume2decibal = { 0.00 : - 51 , 0.05 : - 40 , 0.10 : - 30.848 , 0.15 : - 26 , 0.20 : - 22.477 , 0.25 : - 20 , 0.30 : - 17.111 , 0.35 : - 15 , 0.40 : - 13.152 , 0.45 : - 11 , 0.50 : - 10.015 , 0.55 : - 8.5 , 0.60 : - 7.415 , 0.65 : - 6 , 0.70 : - 4.991 , 0.75 : - 4 , 0.80 : - 3.26 , 0.85 : - 2 , 0.90 : - 1.381 , 0.95 : - 0.6 , 1 : 0 }","title":"Volume"},{"location":"navigation/Util/Sobre-Ferramental/","text":"Ferramental Sobre o hardware e software utilizados no curso. Software: Microchip Studio Hardware: SAME70 (Cortex M7) Softwares Linux e MAC A infra s\u00f3 funciona no Windows! Se for virtualizar, n\u00e3o funciona no VirtualBox! Deve utilizar o VMware como m\u00e1quina virtual (ou parallels). O MicrochipStudio, IDE utilizado para programa\u00e7\u00e3o dos microcontroladores ARM da microchip (usado no curso), \u00e9 nativo Windows . Se for virtualizar, utilizar o VMware Player pois o VirtualBox possui problemas com o driver USB do gravador. Note At\u00e9 2021 o nome do programa era AtmelStudio, mas recentemente mudou de nome para Microchip Studio . Para mais infomra\u00e7\u00f5es sobre o software, acesse: https://www.microchip.com/en-us/development-tools-tools-and-software/microchip-studio-for-avr-and-sam-devices Windows 10 reservar 2h para instala\u00e7\u00e3o Instalar os seguintes softwares no Windows: Microchip Studio 7 - Instalar a vers\u00e3o WEB Serial Port for MicrochipStudio git/github Linux/ MAC reservar 4h para instala\u00e7\u00e3o Instalar o VMWare player e instalar o Windows 10 na m\u00e1quina virtual. MAC, pode usar o Parallels para virtual. N\u00c3O USAR VIRTUALBOX, USAR VMWARE PLAYER Efetuar o boot no pendrive. Instalar os softwares listados na sec\u00e7\u00e3o Windows. Alerta para usu\u00e1rios de Linux e Windows N\u00e3o funciona no VirtualBox! Deve utilizar o VMware como m\u00e1quina virtual Kit de desenvolvimento - ATSAME70-XPLD O kit de desenvolvimento escolhido para o curso \u00e9 o SAM E70 Xplained ^3 desenvolvido pela Microchip e possui como principais caracter\u00edsticas: SAM-E70 high-performance ARM Cortex-M7 core-based MCU Ethernet, HS USB, SD card Embedded debugger Arquitetura do uC Processador ARM: Possui ampla domina\u00e7\u00e3o do mercado de microprocessadores/controladores ^1 ; n\u00e3o \u00e9 exclusivo de um \u00fanico fabricante[^2]; arquitetura de 32 bits. Cortex M: fam\u00edlia M \u00e9 classificada como a de microcontroladores, possuindo uma arquitetura interna menos sofisticadas das demais (A,R), possibilitando um melhor entendimento de seu funcionamento. [^2]: ARM n\u00e3o produz CIs mas fornece a arquitetura para fabricantes de chips (Microchip, Texas, Nvidia,...)","title":"Ferramental"},{"location":"navigation/Util/Sobre-Ferramental/#ferramental","text":"Sobre o hardware e software utilizados no curso. Software: Microchip Studio Hardware: SAME70 (Cortex M7)","title":"Ferramental"},{"location":"navigation/Util/Sobre-Ferramental/#softwares","text":"Linux e MAC A infra s\u00f3 funciona no Windows! Se for virtualizar, n\u00e3o funciona no VirtualBox! Deve utilizar o VMware como m\u00e1quina virtual (ou parallels). O MicrochipStudio, IDE utilizado para programa\u00e7\u00e3o dos microcontroladores ARM da microchip (usado no curso), \u00e9 nativo Windows . Se for virtualizar, utilizar o VMware Player pois o VirtualBox possui problemas com o driver USB do gravador. Note At\u00e9 2021 o nome do programa era AtmelStudio, mas recentemente mudou de nome para Microchip Studio . Para mais infomra\u00e7\u00f5es sobre o software, acesse: https://www.microchip.com/en-us/development-tools-tools-and-software/microchip-studio-for-avr-and-sam-devices","title":"Softwares"},{"location":"navigation/Util/Sobre-Ferramental/#windows-10","text":"reservar 2h para instala\u00e7\u00e3o Instalar os seguintes softwares no Windows: Microchip Studio 7 - Instalar a vers\u00e3o WEB Serial Port for MicrochipStudio git/github","title":"Windows 10"},{"location":"navigation/Util/Sobre-Ferramental/#linux-mac","text":"reservar 4h para instala\u00e7\u00e3o Instalar o VMWare player e instalar o Windows 10 na m\u00e1quina virtual. MAC, pode usar o Parallels para virtual. N\u00c3O USAR VIRTUALBOX, USAR VMWARE PLAYER Efetuar o boot no pendrive. Instalar os softwares listados na sec\u00e7\u00e3o Windows. Alerta para usu\u00e1rios de Linux e Windows N\u00e3o funciona no VirtualBox! Deve utilizar o VMware como m\u00e1quina virtual","title":"Linux/ MAC"},{"location":"navigation/Util/Sobre-Ferramental/#kit-de-desenvolvimento-atsame70-xpld","text":"O kit de desenvolvimento escolhido para o curso \u00e9 o SAM E70 Xplained ^3 desenvolvido pela Microchip e possui como principais caracter\u00edsticas: SAM-E70 high-performance ARM Cortex-M7 core-based MCU Ethernet, HS USB, SD card Embedded debugger","title":"Kit de desenvolvimento - ATSAME70-XPLD"},{"location":"navigation/Util/Sobre-Ferramental/#arquitetura-do-uc","text":"Processador ARM: Possui ampla domina\u00e7\u00e3o do mercado de microprocessadores/controladores ^1 ; n\u00e3o \u00e9 exclusivo de um \u00fanico fabricante[^2]; arquitetura de 32 bits. Cortex M: fam\u00edlia M \u00e9 classificada como a de microcontroladores, possuindo uma arquitetura interna menos sofisticadas das demais (A,R), possibilitando um melhor entendimento de seu funcionamento. [^2]: ARM n\u00e3o produz CIs mas fornece a arquitetura para fabricantes de chips (Microchip, Texas, Nvidia,...)","title":"Arquitetura do uC"},{"location":"navigation/Util/Util-Documentos/","text":"Manual Descri\u00e7\u00e3o SAME70.pdf Manual do microcontrolador SAME70-XPLD.pdf Manual do kit de desenvolvimento OLED1 Xplained Pro User Guide Manual da placa OLED1 Cartilhas Descri\u00e7\u00e3o Cartilhas - Computa\u00e7\u00e3o Embarcada (INSPER) Reposit\u00f3rio de cartilhas: Cartilhas do KIT de CompEmb; PINOUT; Tabela ASCII; Esquemas de conex\u00f5es da placa.","title":"Util Documentos"},{"location":"navigation/Util/Util-Erros/","text":"Erros comum Aqui est\u00e3o listados os erros mais frequentes que aparecem na hora de programar a placa SAME70-XPLD. USB errada Muitas das vezes que o AtmelStudio n\u00e3o reconhece a placa \u00e9 porque foi ligada na porta USB errada. O Kit de desenvolvimento possui duas portas USB, uma para programar o microcontrolador e outra para conectar dispositivos no microcontrolador (host/device). Este \u00e9 o erro mais comum! PORTA USB CERTA PORTA USB ERRADA Chip Errado Configurando vers\u00e3o Para alterar a vers\u00e3o do chip dentro do Atmel Studio basta realizar os seguintes passos: 1 - Clique no bot\u00e3o Device: 2 - Clique no bot\u00e3o Change Device: 3 - Selecione a vers\u00e3o correta do chip e clique em OK, agora seu gravador(EDBG) dever\u00e1 ser reconhecido pela IDE: 4 - Dentro da aba Tools, v\u00e1 at\u00e9 o menu drop-down Select debugger/programmer e selecione o seu gravador, no caso desse gif: As placas SAME70-XPLD possuem o Microcontrolador ATSAME70Q21, contudo ele possui 2 vers\u00f5es, a ATSAME70Q21 (Rev. A) e a vers\u00e3o ATSAME70Q21**B** (Rev. B). Caso a vers\u00e3o n\u00e3o esteja correta na IDE Atmel Studio, o c\u00f3digo a ser transferido para a placa pode n\u00e3o ser gravado corretamente e pode at\u00e9 nem ser reconhecida pela IDE. Os exemplos s\u00e3o todos configurados para a vers\u00e3o B da placa, se voc\u00ea possuir a A deve fazer a configura\u00e7\u00e3o a seguir. Para saber a vers\u00e3o do seu chip, basta olhar o c\u00f3digo impresso em cima do CI do Microcontrolador: REV. A REV B Info \u00c9 bem dif\u00edcil ver essas letras. Jumpers Erase Em algumas situa\u00e7\u00f5es \u00e9 necess\u00e1rio que a mem\u00f3ria seja apagada (zerada), para isso siga os passos a seguir: Energize a placa Coloque o Jumper Retire o cabo USB Coloque o cabo USB Retire o jumper Retire e coloque o cabo USB novamente O Kit possui dois jumpers: Current Measurement e Erase . O primeiro deve estar conectado e o segundo n\u00e3o. Current Measurement: Serve para medirmos a corrente que vai para o uC a fim de aferir a pot\u00eancia el\u00e9trica que est\u00e1 sendo consumida. Erase: Serve para apagar a mem\u00f3ria de programa do uC. Limpando build Dentro do AtmelStudio clique no menubar: Build Clean Solution . Isso ir\u00e1 remover todos os arquivos da compila\u00e7\u00e3o anterior das pastas. Instalando Terminal Window no Microchip Studio Instalando Clique em Tools Extensions and Update Pesquise Terminal na caixa de busca a direita, depois clique em download. Ap\u00f3s a instala\u00e7\u00e3o o Atmel Studio dever\u00e1 reiniciar. Para verificar se o Terminal Windows foi instalado, clique em View > Terminal Window Caso n\u00e3o encontre o terminal em View Terminal Window (Imagem abaixo), voc\u00ea deve seguir os passos para instala\u00e7\u00e3o do mesmo. Driver EDBG (USB) n\u00e3o est\u00e1 sendo reconhecido Downgrade do driver EDBG Fa\u00e7a o download do software Zadig : Vers\u00e3o 2.5 Com a placa conectada, execute o software e selecione Options > List All Devices , feito isso selecione a op\u00e7\u00e3o EDBG Data Gateway ** e em seguida clique em **Downgrade Driver : O driver dever\u00e1 ser reconhecido pelo Atmel Studio, conforme a imagem abaixo: Abra qualquer um dos projetos da disciplina Computa\u00e7\u00e3o Embarcada e conecte a placa, confira se o chip configurado na interface \u00e9 o mesmo que voc\u00ea est\u00e1 utilizando, sen\u00e3o volte a sess\u00e3o 2: Caso o driver EDGB (gravador) n\u00e3o tenha sido reconhecido (imagem abaixo) ser\u00e1 necess\u00e1rio fazer o Downgrade do driver EDBG:","title":"Erros comum"},{"location":"navigation/Util/Util-Erros/#erros-comum","text":"Aqui est\u00e3o listados os erros mais frequentes que aparecem na hora de programar a placa SAME70-XPLD.","title":"Erros comum"},{"location":"navigation/Util/Util-Erros/#usb-errada","text":"Muitas das vezes que o AtmelStudio n\u00e3o reconhece a placa \u00e9 porque foi ligada na porta USB errada. O Kit de desenvolvimento possui duas portas USB, uma para programar o microcontrolador e outra para conectar dispositivos no microcontrolador (host/device). Este \u00e9 o erro mais comum! PORTA USB CERTA PORTA USB ERRADA","title":"USB errada"},{"location":"navigation/Util/Util-Erros/#chip-errado","text":"Configurando vers\u00e3o Para alterar a vers\u00e3o do chip dentro do Atmel Studio basta realizar os seguintes passos: 1 - Clique no bot\u00e3o Device: 2 - Clique no bot\u00e3o Change Device: 3 - Selecione a vers\u00e3o correta do chip e clique em OK, agora seu gravador(EDBG) dever\u00e1 ser reconhecido pela IDE: 4 - Dentro da aba Tools, v\u00e1 at\u00e9 o menu drop-down Select debugger/programmer e selecione o seu gravador, no caso desse gif: As placas SAME70-XPLD possuem o Microcontrolador ATSAME70Q21, contudo ele possui 2 vers\u00f5es, a ATSAME70Q21 (Rev. A) e a vers\u00e3o ATSAME70Q21**B** (Rev. B). Caso a vers\u00e3o n\u00e3o esteja correta na IDE Atmel Studio, o c\u00f3digo a ser transferido para a placa pode n\u00e3o ser gravado corretamente e pode at\u00e9 nem ser reconhecida pela IDE. Os exemplos s\u00e3o todos configurados para a vers\u00e3o B da placa, se voc\u00ea possuir a A deve fazer a configura\u00e7\u00e3o a seguir. Para saber a vers\u00e3o do seu chip, basta olhar o c\u00f3digo impresso em cima do CI do Microcontrolador: REV. A REV B Info \u00c9 bem dif\u00edcil ver essas letras.","title":"Chip Errado"},{"location":"navigation/Util/Util-Erros/#jumpers","text":"Erase Em algumas situa\u00e7\u00f5es \u00e9 necess\u00e1rio que a mem\u00f3ria seja apagada (zerada), para isso siga os passos a seguir: Energize a placa Coloque o Jumper Retire o cabo USB Coloque o cabo USB Retire o jumper Retire e coloque o cabo USB novamente O Kit possui dois jumpers: Current Measurement e Erase . O primeiro deve estar conectado e o segundo n\u00e3o. Current Measurement: Serve para medirmos a corrente que vai para o uC a fim de aferir a pot\u00eancia el\u00e9trica que est\u00e1 sendo consumida. Erase: Serve para apagar a mem\u00f3ria de programa do uC.","title":"Jumpers"},{"location":"navigation/Util/Util-Erros/#limpando-build","text":"Dentro do AtmelStudio clique no menubar: Build Clean Solution . Isso ir\u00e1 remover todos os arquivos da compila\u00e7\u00e3o anterior das pastas.","title":"Limpando build"},{"location":"navigation/Util/Util-Erros/#instalando-terminal-window-no-microchip-studio","text":"Instalando Clique em Tools Extensions and Update Pesquise Terminal na caixa de busca a direita, depois clique em download. Ap\u00f3s a instala\u00e7\u00e3o o Atmel Studio dever\u00e1 reiniciar. Para verificar se o Terminal Windows foi instalado, clique em View > Terminal Window Caso n\u00e3o encontre o terminal em View Terminal Window (Imagem abaixo), voc\u00ea deve seguir os passos para instala\u00e7\u00e3o do mesmo.","title":"Instalando Terminal Window no Microchip Studio"},{"location":"navigation/Util/Util-Erros/#driver-edbg-usb-nao-esta-sendo-reconhecido","text":"Downgrade do driver EDBG Fa\u00e7a o download do software Zadig : Vers\u00e3o 2.5 Com a placa conectada, execute o software e selecione Options > List All Devices , feito isso selecione a op\u00e7\u00e3o EDBG Data Gateway ** e em seguida clique em **Downgrade Driver : O driver dever\u00e1 ser reconhecido pelo Atmel Studio, conforme a imagem abaixo: Abra qualquer um dos projetos da disciplina Computa\u00e7\u00e3o Embarcada e conecte a placa, confira se o chip configurado na interface \u00e9 o mesmo que voc\u00ea est\u00e1 utilizando, sen\u00e3o volte a sess\u00e3o 2: Caso o driver EDGB (gravador) n\u00e3o tenha sido reconhecido (imagem abaixo) ser\u00e1 necess\u00e1rio fazer o Downgrade do driver EDBG:","title":"Driver EDBG (USB) n\u00e3o est\u00e1 sendo reconhecido"},{"location":"navigation/Util/Util-Perifericos/","text":"Perif\u00e9ricos Um pequeno resumo de como utilizar os perif\u00e9ricos do microcontrolador SAME70 no kit SAME70-XPLD. https://asf.microchip.com/docs/latest/search.html?device=same70 PIO - Parallel Input Output Exemplos Perifericos-uC/PIO-IO/ Perifericos-uC/PIO-IRQ/ output Use defines para facilitar: // LED da placa #define LED_PIO PIOC #define LED_PIO_ID ID_PIOC #define LED_IDX 8 #define LED_IDX_MASK (1 << LED_IDX) Configura o PC8 como sendo output: pmc_enable_periph_clk ( LED_PIO_ID ); pio_configure ( LED_PIO , PIO_OUTPUT_0 , LED_IDX_MASK , PIO_DEFAULT ); Acionando o pino: pio_set ( LED_PIO , LED_IDX_MASK ); // coloca pino em 1 pio_clear ( LED_PIO , LED_IDX_MASK ); // coloca pino em 0 input Use defines para facilitar: //Defines dos bot\u00f5es #define BUT_PIO PIOA #define BUT_PIO_ID ID_PIOA #define BUT_IDX 11 #define BUT_IDX_MASK (1 << BUT_IDX) Defina a fun\u00e7\u00e3o de callback: //Callback da IRQ do bot\u00e3o void but_callback ( void ){ // ----------------------// // seu c\u00f3digo vem aqui! // // ----------------------// } Configura PA11 com interrup\u00e7\u00e3o na borda de descida configurando a fun\u00e7\u00e3o but_callback para ser chamada sempre que acontece uma interrup\u00e7\u00e3o. Esse exemplo ativa debounce de 60hz nesse pino. pmc_enable_periph_clk ( BUT_PIO_ID ); pio_configure ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK , PIO_PULLUP ); pio_handler_set ( BUT_PIO , BUT_PIO_ID , BUT_IDX_MASK , PIO_IT_FALL_EDGE , but_callback ); pio_set_debounce_filter ( LED_PIO , LED_IDX_MASK , 60 ); pio_enable_interrupt ( BUT_PIO , BUT_IDX_MASK ); pio_get_interrupt_status ( BUT_PIO ); NVIC_SetPriority ( BUT_PIO_ID , 4 ); NVIC_EnableIRQ ( BUT_PIO_ID ); Para ler o pino: uint32_t pin = pio_get ( BUT_PIO , BUT_IDX_MASK ); pin > 0 : Pinos em 1 pin = 0 : Pinos em 0 TC - Timer Counter Exemplos Perifericos-uC/TC-IRQ/ Biblioteca https://asf.microchip.com/docs/latest/same70/html/group__asfdoc__sam__drivers__tc__group.html A fam\u00edlia SAM E70 possui 3 TCs, cada TC possui 3 canais (0, 1 e 2): CH0 CH1 CH2 TC0: ID_TC0 ID_TC1 ID_TC2 TC1 ID_TC3 ID_TC4 ID_TC5 TC2 ID_TC6 ID_TC7 ID_TC8 Exemplo para configura\u00e7\u00e3o do TC2 - Canal 1 ( ID_TC7 ) a 4 Hz Defina a fun\u00e7\u00e3o Handler que ser\u00e1 chamada quando ocorrer uma interrup\u00e7\u00e3o: void TC7_Handler ( void ){ volatile uint32_t ul_dummy ; ul_dummy = tc_get_status ( TC2 , 1 ); // ID_TC7 -> TC2 - Canal 1 UNUSED ( ul_dummy ); // ----------------------// // seu c\u00f3digo vem aqui! // // ----------------------// } Defina a fun\u00e7\u00e3o TC_init que ajuda na configura\u00e7\u00e3o do TC void TC_init ( Tc * TC , int ID_TC , int TC_CHANNEL , int freq ){ uint32_t ul_div ; uint32_t ul_tcclks ; uint32_t ul_sysclk = sysclk_get_cpu_hz (); pmc_enable_periph_clk ( ID_TC ); tc_find_mck_divisor ( freq , ul_sysclk , & ul_div , & ul_tcclks , ul_sysclk ); tc_init ( TC , TC_CHANNEL , ul_tcclks | TC_CMR_CPCTRG ); tc_write_rc ( TC , TC_CHANNEL , ( ul_sysclk / ul_div ) / freq ); NVIC_SetPriority ( ID_TC , 4 ); NVIC_EnableIRQ (( IRQn_Type ) ID_TC ); tc_enable_interrupt ( TC , TC_CHANNEL , TC_IER_CPCS ); } Chame a fun\u00e7\u00e3o quando for querer inicializar o TC int canal_ID_TC7 = 2 ; // Canal 2 int freq = 4 ; // 4 Hz, a interrup\u00e7\u00e3o acontece 4 vezes por segundo // Configura timer TC2, canal 1 TC_init ( TC2 , ID_TC7 , canal_ID_TC7 , freq ); // Inicalize o TC tc_start ( TC , TC_CHANNEL ); Tip Se quiser parar a contagem do TC tc_stop(TC, TC_CHANNEL); RTC - Real Time Counter Defina o struct para ajudar typedef struct { uint32_t year ; uint32_t month ; uint32_t day ; uint32_t week ; uint32_t hour ; uint32_t minute ; uint32_t seccond ; } calendar Configure o handler para ser chamado na interrup\u00e7\u00e3o void RTC_Handler ( void ){ uint32_t ul_status = rtc_get_status ( RTC ); // Instru\u00e7\u00e3o a ser executada quando a IRQ por SEGUNDO for ativada if (( ul_status & RTC_SR_SEC ) == RTC_SR_SEC ){ rtc_clear_status ( RTC , RTC_SCCR_SECCLR ); // ----------------------// // seu c\u00f3digo vem aqui! // // ----------------------// } // Instru\u00e7\u00e3o a ser executada quando a IRQ por ALARME for ativada if (( ul_status & RTC_SR_ALARM ) == RTC_SR_ALARM ){ rtc_clear_status ( RTC , RTC_SCCR_ALRCLR ); // ----------------------// // seu c\u00f3digo vem aqui! // // ----------------------// } rtc_clear_status ( RTC , RTC_SCCR_ACKCLR ); rtc_clear_status ( RTC , RTC_SCCR_TIMCLR ); rtc_clear_status ( RTC , RTC_SCCR_CALCLR ); rtc_clear_status ( RTC , RTC_SCCR_TDERRCLR ); } Declare a fun\u00e7\u00e3o de configura\u00e7\u00e3o do RTC void RTC_init ( Rtc * rtc , uint32_t id_rtc , calendar t , uint32_t irq_type ){ pmc_enable_periph_clk ( ID_RTC ); rtc_set_hour_mode ( rtc , 0 ); rtc_set_date ( rtc , t . year , t . month , t . day , t . week ); rtc_set_time ( rtc , t . hour , t . minute , t . seccond ); NVIC_DisableIRQ ( id_rtc ); NVIC_ClearPendingIRQ ( id_rtc ); NVIC_SetPriority ( id_rtc , 4 ); NVIC_EnableIRQ ( id_rtc ); rtc_enable_interrupt ( rtc , irq_type ); } RTT com IRQ de segundos calendar rtc_initial = { 2020 , 7 , 10 , 28 , 15 , 45 , 1 }; //RTC_IER_SECEN - IRQ por SEGUNDO RTC_init ( RTC , ID_RTC , rtc_initial , RTC_IER_SECEN ); RTT com IRQ de segundos e alarme calendar rtc_initial = { 2020 , 7 , 10 , 28 , 15 , 45 , 1 }; //RTC_IER_ALREN - IRQ por ALARME //RTC_IER_SECEN - IRQ por SEGUNDO RTC_init ( RTC , ID_RTC , rtc_initial , RTC_IER_ALREN | RTC_IER_SECEN ); /* configura alarme do RTC */ rtc_set_date_alarm ( RTC , 1 , rtc_initial . month , 1 , rtc_initial . day ); rtc_set_time_alarm ( RTC , 1 , rtc_initial . hour , 1 , rtc_initial . minute , 1 , rtc_initial . seccond + 10 ); Nesse exemplo uma alarme \u00e9 configurado para +10 segundos ap\u00f3s a inicializa\u00e7\u00e3o. RTT - Real Time Timer void RTT_Handler ( void ) { uint32_t ul_status ; ul_status = rtt_get_status ( RTT ); // instru\u00e7\u00e3o a ser executada quando a IRQ por TICK (pllPreScale) for ativada if (( ul_status & RTT_SR_RTTINC ) == RTT_SR_RTTINC ) { // ----------------------// // seu c\u00f3digo vem aqui! // // ----------------------// } // instru\u00e7\u00e3o a ser executada quando a IRQ por ALARME for ativada if (( ul_status & RTT_SR_ALMS ) == RTT_SR_ALMS ) { // ----------------------// // seu c\u00f3digo vem aqui! // // ----------------------// } } static void RTT_init ( uint16_t pllPreScale , uint32_t IrqNPulses ) { uint32_t ul_previous_time ; /* Configure RTT for a 1 second tick interrupt */ rtt_sel_source ( RTT , false ); rtt_init ( RTT , pllPreScale ); ul_previous_time = rtt_read_timer_value ( RTT ); while ( ul_previous_time == rtt_read_timer_value ( RTT )); rtt_write_alarm_time ( RTT , IrqNPulses + ul_previous_time ); /* Enable RTT interrupt */ NVIC_DisableIRQ ( RTT_IRQn ); NVIC_ClearPendingIRQ ( RTT_IRQn ); NVIC_SetPriority ( RTT_IRQn , 4 ); NVIC_EnableIRQ ( RTT_IRQn ); rtt_enable_interrupt ( RTT , RTT_MR_ALMIEN | RTT_MR_RTTINCIEN ); } int main ( void ){ ... uint16_t pllPreScale = ( int ) ((( float ) 32768 ) / 4.0 ); uint32_t irqRTTvalue = 8 ; // reinicia RTT para gerar um novo IRQ RTT_init ( pllPreScale , irqRTTvalue ); ... } Alert O RTT n\u00e3o possui reinicializa\u00e7\u00e3o autom\u00e1tica, quando ocorrer a interrup\u00e7\u00e3o \u00e9 necess\u00e1rio inici\u00e1-lo novamente. UART AFEC / ADC - Analog Front End Converter","title":"\tPerif\u00e9ricos"},{"location":"navigation/Util/Util-Perifericos/#perifericos","text":"Um pequeno resumo de como utilizar os perif\u00e9ricos do microcontrolador SAME70 no kit SAME70-XPLD. https://asf.microchip.com/docs/latest/search.html?device=same70","title":"Perif\u00e9ricos"},{"location":"navigation/Util/Util-Perifericos/#pio-parallel-input-output","text":"Exemplos Perifericos-uC/PIO-IO/ Perifericos-uC/PIO-IRQ/","title":"PIO - Parallel Input Output"},{"location":"navigation/Util/Util-Perifericos/#output","text":"Use defines para facilitar: // LED da placa #define LED_PIO PIOC #define LED_PIO_ID ID_PIOC #define LED_IDX 8 #define LED_IDX_MASK (1 << LED_IDX) Configura o PC8 como sendo output: pmc_enable_periph_clk ( LED_PIO_ID ); pio_configure ( LED_PIO , PIO_OUTPUT_0 , LED_IDX_MASK , PIO_DEFAULT ); Acionando o pino: pio_set ( LED_PIO , LED_IDX_MASK ); // coloca pino em 1 pio_clear ( LED_PIO , LED_IDX_MASK ); // coloca pino em 0","title":"output"},{"location":"navigation/Util/Util-Perifericos/#input","text":"Use defines para facilitar: //Defines dos bot\u00f5es #define BUT_PIO PIOA #define BUT_PIO_ID ID_PIOA #define BUT_IDX 11 #define BUT_IDX_MASK (1 << BUT_IDX) Defina a fun\u00e7\u00e3o de callback: //Callback da IRQ do bot\u00e3o void but_callback ( void ){ // ----------------------// // seu c\u00f3digo vem aqui! // // ----------------------// } Configura PA11 com interrup\u00e7\u00e3o na borda de descida configurando a fun\u00e7\u00e3o but_callback para ser chamada sempre que acontece uma interrup\u00e7\u00e3o. Esse exemplo ativa debounce de 60hz nesse pino. pmc_enable_periph_clk ( BUT_PIO_ID ); pio_configure ( BUT_PIO , PIO_INPUT , BUT_IDX_MASK , PIO_PULLUP ); pio_handler_set ( BUT_PIO , BUT_PIO_ID , BUT_IDX_MASK , PIO_IT_FALL_EDGE , but_callback ); pio_set_debounce_filter ( LED_PIO , LED_IDX_MASK , 60 ); pio_enable_interrupt ( BUT_PIO , BUT_IDX_MASK ); pio_get_interrupt_status ( BUT_PIO ); NVIC_SetPriority ( BUT_PIO_ID , 4 ); NVIC_EnableIRQ ( BUT_PIO_ID ); Para ler o pino: uint32_t pin = pio_get ( BUT_PIO , BUT_IDX_MASK ); pin > 0 : Pinos em 1 pin = 0 : Pinos em 0","title":"input"},{"location":"navigation/Util/Util-Perifericos/#tc-timer-counter","text":"Exemplos Perifericos-uC/TC-IRQ/ Biblioteca https://asf.microchip.com/docs/latest/same70/html/group__asfdoc__sam__drivers__tc__group.html A fam\u00edlia SAM E70 possui 3 TCs, cada TC possui 3 canais (0, 1 e 2): CH0 CH1 CH2 TC0: ID_TC0 ID_TC1 ID_TC2 TC1 ID_TC3 ID_TC4 ID_TC5 TC2 ID_TC6 ID_TC7 ID_TC8 Exemplo para configura\u00e7\u00e3o do TC2 - Canal 1 ( ID_TC7 ) a 4 Hz Defina a fun\u00e7\u00e3o Handler que ser\u00e1 chamada quando ocorrer uma interrup\u00e7\u00e3o: void TC7_Handler ( void ){ volatile uint32_t ul_dummy ; ul_dummy = tc_get_status ( TC2 , 1 ); // ID_TC7 -> TC2 - Canal 1 UNUSED ( ul_dummy ); // ----------------------// // seu c\u00f3digo vem aqui! // // ----------------------// } Defina a fun\u00e7\u00e3o TC_init que ajuda na configura\u00e7\u00e3o do TC void TC_init ( Tc * TC , int ID_TC , int TC_CHANNEL , int freq ){ uint32_t ul_div ; uint32_t ul_tcclks ; uint32_t ul_sysclk = sysclk_get_cpu_hz (); pmc_enable_periph_clk ( ID_TC ); tc_find_mck_divisor ( freq , ul_sysclk , & ul_div , & ul_tcclks , ul_sysclk ); tc_init ( TC , TC_CHANNEL , ul_tcclks | TC_CMR_CPCTRG ); tc_write_rc ( TC , TC_CHANNEL , ( ul_sysclk / ul_div ) / freq ); NVIC_SetPriority ( ID_TC , 4 ); NVIC_EnableIRQ (( IRQn_Type ) ID_TC ); tc_enable_interrupt ( TC , TC_CHANNEL , TC_IER_CPCS ); } Chame a fun\u00e7\u00e3o quando for querer inicializar o TC int canal_ID_TC7 = 2 ; // Canal 2 int freq = 4 ; // 4 Hz, a interrup\u00e7\u00e3o acontece 4 vezes por segundo // Configura timer TC2, canal 1 TC_init ( TC2 , ID_TC7 , canal_ID_TC7 , freq ); // Inicalize o TC tc_start ( TC , TC_CHANNEL ); Tip Se quiser parar a contagem do TC tc_stop(TC, TC_CHANNEL);","title":"TC - Timer Counter"},{"location":"navigation/Util/Util-Perifericos/#rtc-real-time-counter","text":"Defina o struct para ajudar typedef struct { uint32_t year ; uint32_t month ; uint32_t day ; uint32_t week ; uint32_t hour ; uint32_t minute ; uint32_t seccond ; } calendar Configure o handler para ser chamado na interrup\u00e7\u00e3o void RTC_Handler ( void ){ uint32_t ul_status = rtc_get_status ( RTC ); // Instru\u00e7\u00e3o a ser executada quando a IRQ por SEGUNDO for ativada if (( ul_status & RTC_SR_SEC ) == RTC_SR_SEC ){ rtc_clear_status ( RTC , RTC_SCCR_SECCLR ); // ----------------------// // seu c\u00f3digo vem aqui! // // ----------------------// } // Instru\u00e7\u00e3o a ser executada quando a IRQ por ALARME for ativada if (( ul_status & RTC_SR_ALARM ) == RTC_SR_ALARM ){ rtc_clear_status ( RTC , RTC_SCCR_ALRCLR ); // ----------------------// // seu c\u00f3digo vem aqui! // // ----------------------// } rtc_clear_status ( RTC , RTC_SCCR_ACKCLR ); rtc_clear_status ( RTC , RTC_SCCR_TIMCLR ); rtc_clear_status ( RTC , RTC_SCCR_CALCLR ); rtc_clear_status ( RTC , RTC_SCCR_TDERRCLR ); } Declare a fun\u00e7\u00e3o de configura\u00e7\u00e3o do RTC void RTC_init ( Rtc * rtc , uint32_t id_rtc , calendar t , uint32_t irq_type ){ pmc_enable_periph_clk ( ID_RTC ); rtc_set_hour_mode ( rtc , 0 ); rtc_set_date ( rtc , t . year , t . month , t . day , t . week ); rtc_set_time ( rtc , t . hour , t . minute , t . seccond ); NVIC_DisableIRQ ( id_rtc ); NVIC_ClearPendingIRQ ( id_rtc ); NVIC_SetPriority ( id_rtc , 4 ); NVIC_EnableIRQ ( id_rtc ); rtc_enable_interrupt ( rtc , irq_type ); } RTT com IRQ de segundos calendar rtc_initial = { 2020 , 7 , 10 , 28 , 15 , 45 , 1 }; //RTC_IER_SECEN - IRQ por SEGUNDO RTC_init ( RTC , ID_RTC , rtc_initial , RTC_IER_SECEN ); RTT com IRQ de segundos e alarme calendar rtc_initial = { 2020 , 7 , 10 , 28 , 15 , 45 , 1 }; //RTC_IER_ALREN - IRQ por ALARME //RTC_IER_SECEN - IRQ por SEGUNDO RTC_init ( RTC , ID_RTC , rtc_initial , RTC_IER_ALREN | RTC_IER_SECEN ); /* configura alarme do RTC */ rtc_set_date_alarm ( RTC , 1 , rtc_initial . month , 1 , rtc_initial . day ); rtc_set_time_alarm ( RTC , 1 , rtc_initial . hour , 1 , rtc_initial . minute , 1 , rtc_initial . seccond + 10 ); Nesse exemplo uma alarme \u00e9 configurado para +10 segundos ap\u00f3s a inicializa\u00e7\u00e3o.","title":"RTC - Real Time Counter"},{"location":"navigation/Util/Util-Perifericos/#rtt-real-time-timer","text":"void RTT_Handler ( void ) { uint32_t ul_status ; ul_status = rtt_get_status ( RTT ); // instru\u00e7\u00e3o a ser executada quando a IRQ por TICK (pllPreScale) for ativada if (( ul_status & RTT_SR_RTTINC ) == RTT_SR_RTTINC ) { // ----------------------// // seu c\u00f3digo vem aqui! // // ----------------------// } // instru\u00e7\u00e3o a ser executada quando a IRQ por ALARME for ativada if (( ul_status & RTT_SR_ALMS ) == RTT_SR_ALMS ) { // ----------------------// // seu c\u00f3digo vem aqui! // // ----------------------// } } static void RTT_init ( uint16_t pllPreScale , uint32_t IrqNPulses ) { uint32_t ul_previous_time ; /* Configure RTT for a 1 second tick interrupt */ rtt_sel_source ( RTT , false ); rtt_init ( RTT , pllPreScale ); ul_previous_time = rtt_read_timer_value ( RTT ); while ( ul_previous_time == rtt_read_timer_value ( RTT )); rtt_write_alarm_time ( RTT , IrqNPulses + ul_previous_time ); /* Enable RTT interrupt */ NVIC_DisableIRQ ( RTT_IRQn ); NVIC_ClearPendingIRQ ( RTT_IRQn ); NVIC_SetPriority ( RTT_IRQn , 4 ); NVIC_EnableIRQ ( RTT_IRQn ); rtt_enable_interrupt ( RTT , RTT_MR_ALMIEN | RTT_MR_RTTINCIEN ); } int main ( void ){ ... uint16_t pllPreScale = ( int ) ((( float ) 32768 ) / 4.0 ); uint32_t irqRTTvalue = 8 ; // reinicia RTT para gerar um novo IRQ RTT_init ( pllPreScale , irqRTTvalue ); ... } Alert O RTT n\u00e3o possui reinicializa\u00e7\u00e3o autom\u00e1tica, quando ocorrer a interrup\u00e7\u00e3o \u00e9 necess\u00e1rio inici\u00e1-lo novamente.","title":"RTT - Real Time Timer"},{"location":"navigation/Util/Util-Perifericos/#uart","text":"","title":"UART"},{"location":"navigation/Util/Util-Perifericos/#afec-adc-analog-front-end-converter","text":"","title":"AFEC / ADC - Analog Front End Converter"},{"location":"navigation/Util/Util-Recados/","text":"23/3 Bem vindos de volta! Recados: 1. Adapta\u00e7\u00e3o da disciplina (avalia\u00e7\u00e3o e projetos). 1. Kit de Expans\u00e3o (APS3 - APS4) 1. Criar bancadas virtuais e din\u00e2mica de atendimento. - Segundas: Estudio para APS. - Quartas e Quintas: Labs. 1. Simulado AV1 (AI) - Vamos liberar ainda essa semana! Aula de hoje: 1. Lab de IRQ para quem n\u00e3o teve - \u00c1udio aberto durante expositiva. - Depois cada um para a sua bancada! - Iniciar v\u00eddeo. - Convidar eu, edu e Marco - D\u00favidas? Preencher o forms. 1. Quem j\u00e1 fez? - Pode terminar, ou trabalhar na APS. - D\u00favidas? Preencher o forms.","title":"Util Recados"},{"location":"navigation/Util/Util-Recados/#233-bem-vindos-de-volta","text":"Recados: 1. Adapta\u00e7\u00e3o da disciplina (avalia\u00e7\u00e3o e projetos). 1. Kit de Expans\u00e3o (APS3 - APS4) 1. Criar bancadas virtuais e din\u00e2mica de atendimento. - Segundas: Estudio para APS. - Quartas e Quintas: Labs. 1. Simulado AV1 (AI) - Vamos liberar ainda essa semana! Aula de hoje: 1. Lab de IRQ para quem n\u00e3o teve - \u00c1udio aberto durante expositiva. - Depois cada um para a sua bancada! - Iniciar v\u00eddeo. - Convidar eu, edu e Marco - D\u00favidas? Preencher o forms. 1. Quem j\u00e1 fez? - Pode terminar, ou trabalhar na APS. - D\u00favidas? Preencher o forms.","title":"23/3 Bem vindos de volta!"},{"location":"navigation/Util/Util-Startup/","text":"Startup Dicas de como come\u00e7ar usar o kit de desenvolvimento SAME70. Info Voc\u00ea deve ter instalado o software Microchip Studio . Note O v\u00eddeo faz refer\u00eancia ao reposit\u00f3rio: https://github.com/Insper/SAME70-examples Tip N\u00e3o funcionou? Resolva preferencialmente da seguinte maneira: Teste com a placa de outro colega. Procure algu\u00e9m da equipe, ficamos no laborat\u00f3rio de Arquitetura de Computadores - 4 andar PD2. Mande mensagem no whats do seu professor \ud83e\uddb8\u200d\u2642\ufe0f. Passo a passo para voc\u00eas executarem o primeiro programa na placa e testarem: Conectar OLED1 ao EXT1 Ligar o USB na porta DEBUG Clonar reposit\u00f3rio: https://github.com/Insper/SAME70-examples Abrir projeto Screens/OLED-Xplained-Pro-SPI/OLED-Xplained-Pro-SPI no microchip Studio (icone vermelho ou amarelo) Programar microcontrolador. !!! video https://www.youtube.com/embed/1b8lW2ALdy0","title":"Startup"},{"location":"navigation/Util/Util-Startup/#startup","text":"Dicas de como come\u00e7ar usar o kit de desenvolvimento SAME70. Info Voc\u00ea deve ter instalado o software Microchip Studio . Note O v\u00eddeo faz refer\u00eancia ao reposit\u00f3rio: https://github.com/Insper/SAME70-examples Tip N\u00e3o funcionou? Resolva preferencialmente da seguinte maneira: Teste com a placa de outro colega. Procure algu\u00e9m da equipe, ficamos no laborat\u00f3rio de Arquitetura de Computadores - 4 andar PD2. Mande mensagem no whats do seu professor \ud83e\uddb8\u200d\u2642\ufe0f. Passo a passo para voc\u00eas executarem o primeiro programa na placa e testarem: Conectar OLED1 ao EXT1 Ligar o USB na porta DEBUG Clonar reposit\u00f3rio: https://github.com/Insper/SAME70-examples Abrir projeto Screens/OLED-Xplained-Pro-SPI/OLED-Xplained-Pro-SPI no microchip Studio (icone vermelho ou amarelo) Programar microcontrolador. !!! video https://www.youtube.com/embed/1b8lW2ALdy0","title":"Startup"},{"location":"navigation/Util/Util-corona/","text":"Corona Adapta\u00e7\u00e3o do curso Computa\u00e7\u00e3o Embarcada para o ensino online devido ao v\u00edrus. Projeto 1 e Projeto 2 Tip Projeto 1 e Projeto 2 cancelados Os projetos ser\u00e3o cancelados, o trabalho remoto n\u00e3o possibilita que executemos esses dois projetos pelos seguintes motivos: Somente um integrante do grupo possui todos os componentes montados em sua placa Previa uma demanda grande do fablab Eles sair\u00e3o da rubrica de avalia\u00e7\u00e3o, o que foi feito at\u00e9 agora podemos tratar como um aprendizado. Quem ainda tem o interesse em desenvolver o controle ou a vending machine pode me procurar e planejamos fazer como atividade extra quando as aulas voltarem ao normal. APS Tip APS v\u00e3o virar mini projetos n\u00e3o pode repetir duplas m\u00e9dia simples entre as notas APS crit\u00e9rio de barreira: m\u00e9dia >= C As APS v\u00e3o virar mini projetos, o curso original previa 3 APS, mas agora v\u00e3o ser 4. Elas ser\u00e3o realizadas em dupla, que precisa revesar (n\u00e3o pode repetir a dupla nas entregas). As APS ser\u00e3o: Buzzer - m\u00fasica Ciclo computador Misterioso (n\u00e3o defini ainda) IoT com Wifi Labs Tip um lab por semana vai come\u00e7ar a valer nota (entrega ao final da aula) m\u00e9dia simples entre as notas (exclui pior nota) crit\u00e9rio de barreira: m\u00e9dia >= C Vamos continuar tendo um LAB por semana, as turmas ainda ser\u00e3o divididas em 2 para facilitar atendimento, por\u00e9m agora os Labs v\u00e3o valer nota, cada lab vai ter um rubrica. Teremos um total de 11 labs, mas a nota vai come\u00e7ar a partir do 4 (pode haver mudan\u00e7a nos labs): PIO Driver PIO IRQ (uma parte ainda n\u00e3o teve esse lab!) TC, RTC RTOS - LCD Imagem RTOS - ADC RTOS - UART RTOS - PWM RTOS - WIFI RTOS - FILTRO DIGITAL RTOS - DMA / AES Avalia\u00e7\u00f5es Individuais Tip 3 avalia\u00e7\u00f5es individuais, pr\u00e1ticas e remotas m\u00e9dia simples crit\u00e9rio de barreira: m\u00e9dia >= C Vamos continuar tendo 3 avalia\u00e7\u00f5es individuais, elas ser\u00e3o remotas e envolvem programa\u00e7\u00e3o. Nota final Atingindo o crit\u00e9rio de barreira: M\u00e9dia >= C nas APS M\u00e9dia >= C nos LABs M\u00e9dia >= C nas Avalia\u00e7\u00f5es Individuais A nota final se\u0155ia a m\u00e9dia entre: nota APS, nota Labs e nota Avalia\u00e7\u00f5es-Individuais","title":"Corona"},{"location":"navigation/Util/Util-corona/#corona","text":"Adapta\u00e7\u00e3o do curso Computa\u00e7\u00e3o Embarcada para o ensino online devido ao v\u00edrus.","title":"Corona"},{"location":"navigation/Util/Util-corona/#projeto-1-e-projeto-2","text":"Tip Projeto 1 e Projeto 2 cancelados Os projetos ser\u00e3o cancelados, o trabalho remoto n\u00e3o possibilita que executemos esses dois projetos pelos seguintes motivos: Somente um integrante do grupo possui todos os componentes montados em sua placa Previa uma demanda grande do fablab Eles sair\u00e3o da rubrica de avalia\u00e7\u00e3o, o que foi feito at\u00e9 agora podemos tratar como um aprendizado. Quem ainda tem o interesse em desenvolver o controle ou a vending machine pode me procurar e planejamos fazer como atividade extra quando as aulas voltarem ao normal.","title":"Projeto 1 e Projeto 2"},{"location":"navigation/Util/Util-corona/#aps","text":"Tip APS v\u00e3o virar mini projetos n\u00e3o pode repetir duplas m\u00e9dia simples entre as notas APS crit\u00e9rio de barreira: m\u00e9dia >= C As APS v\u00e3o virar mini projetos, o curso original previa 3 APS, mas agora v\u00e3o ser 4. Elas ser\u00e3o realizadas em dupla, que precisa revesar (n\u00e3o pode repetir a dupla nas entregas). As APS ser\u00e3o: Buzzer - m\u00fasica Ciclo computador Misterioso (n\u00e3o defini ainda) IoT com Wifi","title":"APS"},{"location":"navigation/Util/Util-corona/#labs","text":"Tip um lab por semana vai come\u00e7ar a valer nota (entrega ao final da aula) m\u00e9dia simples entre as notas (exclui pior nota) crit\u00e9rio de barreira: m\u00e9dia >= C Vamos continuar tendo um LAB por semana, as turmas ainda ser\u00e3o divididas em 2 para facilitar atendimento, por\u00e9m agora os Labs v\u00e3o valer nota, cada lab vai ter um rubrica. Teremos um total de 11 labs, mas a nota vai come\u00e7ar a partir do 4 (pode haver mudan\u00e7a nos labs): PIO Driver PIO IRQ (uma parte ainda n\u00e3o teve esse lab!) TC, RTC RTOS - LCD Imagem RTOS - ADC RTOS - UART RTOS - PWM RTOS - WIFI RTOS - FILTRO DIGITAL RTOS - DMA / AES","title":"Labs"},{"location":"navigation/Util/Util-corona/#avaliacoes-individuais","text":"Tip 3 avalia\u00e7\u00f5es individuais, pr\u00e1ticas e remotas m\u00e9dia simples crit\u00e9rio de barreira: m\u00e9dia >= C Vamos continuar tendo 3 avalia\u00e7\u00f5es individuais, elas ser\u00e3o remotas e envolvem programa\u00e7\u00e3o.","title":"Avalia\u00e7\u00f5es Individuais"},{"location":"navigation/Util/Util-corona/#nota-final","text":"Atingindo o crit\u00e9rio de barreira: M\u00e9dia >= C nas APS M\u00e9dia >= C nos LABs M\u00e9dia >= C nas Avalia\u00e7\u00f5es Individuais A nota final se\u0155ia a m\u00e9dia entre: nota APS, nota Labs e nota Avalia\u00e7\u00f5es-Individuais","title":"Nota final"},{"location":"navigation/Videos/Util-Videos/","text":"V\u00eddeos / Tutoriais V\u00eddeos de suporte a disciplina Conectando coisas Estou come\u00e7ando agora, pode me ajudar?? Assista as dicas para conectar o m\u00f3dulo OLED e a utiliza\u00e7\u00e3o da protoboard para conectar bot\u00e3o e LED na sua placa de desenvolvimento e como programar e gravar o c\u00f3digo utilizando o Microchip Studio. Debugando Seu c\u00f3digo n\u00e3o est\u00e1 funcionando como deveria? n\u00e3o sabe por onde come\u00e7ar para tentar resolver?? Assista as Dicas de como debugar o seu c\u00f3digo utilizando os recursos da Microchip Studio. B\u00e1sico: Avan\u00e7ado: Modulo Bluetooth HC-05 Est\u00e1 com dificuldades para conectar o m\u00f3dulo Bluetooth com a placa de desenvolvimento? Calma, assiste o video, fique atento nas dicas que voc\u00ea vai conseguir resolver.","title":"V\u00eddeos"},{"location":"navigation/Videos/Util-Videos/#videos-tutoriais","text":"V\u00eddeos de suporte a disciplina","title":"V\u00eddeos / Tutoriais"},{"location":"navigation/Videos/Util-Videos/#conectando-coisas","text":"Estou come\u00e7ando agora, pode me ajudar?? Assista as dicas para conectar o m\u00f3dulo OLED e a utiliza\u00e7\u00e3o da protoboard para conectar bot\u00e3o e LED na sua placa de desenvolvimento e como programar e gravar o c\u00f3digo utilizando o Microchip Studio.","title":"Conectando coisas"},{"location":"navigation/Videos/Util-Videos/#debugando","text":"Seu c\u00f3digo n\u00e3o est\u00e1 funcionando como deveria? n\u00e3o sabe por onde come\u00e7ar para tentar resolver?? Assista as Dicas de como debugar o seu c\u00f3digo utilizando os recursos da Microchip Studio. B\u00e1sico: Avan\u00e7ado:","title":"Debugando"},{"location":"navigation/Videos/Util-Videos/#modulo-bluetooth-hc-05","text":"Est\u00e1 com dificuldades para conectar o m\u00f3dulo Bluetooth com a placa de desenvolvimento? Calma, assiste o video, fique atento nas dicas que voc\u00ea vai conseguir resolver.","title":"Modulo Bluetooth HC-05"}]}